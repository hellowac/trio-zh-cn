<!DOCTYPE html>

<html class="no-js" data-content_root="../" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="light dark" name="color-scheme"/><meta content="width=device-width, initial-scale=1" name="viewport">
<link href="../genindex.html" rel="index" title="索引"/><link href="../search.html" rel="search" title="搜索"/><link href="note_async_generator.html" rel="next" title="异步生成器注意事项"/><link href="task_local_storeage.html" rel="prev" title="任务存储"/>
<link href="../_static/favicon-32.png" rel="shortcut icon"/><!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
<title>任务同步和通信 - Trio 0.27.0+dev 文档</title>
<link href="../_static/pygments.css?v=fa44fd50" rel="stylesheet" type="text/css"/>
<link href="../_static/styles/furo.css?v=354aac6f" rel="stylesheet" type="text/css"/>
<link href="../_static/sphinx-codeautolink.css?v=125d5c1c" rel="stylesheet" type="text/css"/>
<link href="../_static/tabs.css?v=4c969af8" rel="stylesheet" type="text/css"/>
<link href="../_static/copybutton.css?v=76b2166b" rel="stylesheet" type="text/css"/>
<link href="../_static/hackrtd.css?v=2d9fc201" rel="stylesheet" type="text/css"/>
<link href="../_static/styles/furo-extensions.css?v=302659d7" rel="stylesheet" type="text/css"/>
<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></meta></head>
<body>
<script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<symbol id="svg-toc" viewbox="0 0 24 24">
<title>Contents</title>
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 1024 1024">
<path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"></path>
</svg>
</symbol>
<symbol id="svg-menu" viewbox="0 0 24 24">
<title>Menu</title>
<svg class="feather-menu" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<line x1="3" x2="21" y1="12" y2="12"></line>
<line x1="3" x2="21" y1="6" y2="6"></line>
<line x1="3" x2="21" y1="18" y2="18"></line>
</svg>
</symbol>
<symbol id="svg-arrow-right" viewbox="0 0 24 24">
<title>Expand</title>
<svg class="feather-chevron-right" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<polyline points="9 18 15 12 9 6"></polyline>
</svg>
</symbol>
<symbol id="svg-sun" viewbox="0 0 24 24">
<title>Light mode</title>
<svg class="feather-sun" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="5"></circle>
<line x1="12" x2="12" y1="1" y2="3"></line>
<line x1="12" x2="12" y1="21" y2="23"></line>
<line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line>
<line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line>
<line x1="1" x2="3" y1="12" y2="12"></line>
<line x1="21" x2="23" y1="12" y2="12"></line>
<line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line>
<line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>
</svg>
</symbol>
<symbol id="svg-moon" viewbox="0 0 24 24">
<title>Dark mode</title>
<svg class="icon-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
</svg>
</symbol>
<symbol id="svg-sun-with-moon" viewbox="0 0 24 24">
<title>Auto light/dark, in light mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z" style="opacity: 50%"></path>
<line x1="14.5" x2="14.5" y1="3.25" y2="1.25"></line>
<line x1="14.5" x2="14.5" y1="15.85" y2="17.85"></line>
<line x1="10.044" x2="8.63" y1="5.094" y2="3.68"></line>
<line x1="19" x2="20.414" y1="14.05" y2="15.464"></line>
<line x1="8.2" x2="6.2" y1="9.55" y2="9.55"></line>
<line x1="20.8" x2="22.8" y1="9.55" y2="9.55"></line>
<line x1="10.044" x2="8.63" y1="14.006" y2="15.42"></line>
<line x1="19" x2="20.414" y1="5.05" y2="3.636"></line>
<circle cx="14.5" cy="9.55" r="3.6"></circle>
</svg>
</symbol>
<symbol id="svg-moon-with-sun" viewbox="0 0 24 24">
<title>Auto light/dark, in dark mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"></path>
<line style="opacity: 50%" x1="18" x2="18" y1="3.705" y2="2.5"></line>
<line style="opacity: 50%" x1="18" x2="18" y1="11.295" y2="12.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="4.816" y2="3.964"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="10.212" y2="11.063"></line>
<line style="opacity: 50%" x1="14.205" x2="13.001" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="21.795" x2="23" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="10.184" y2="11.036"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="4.789" y2="3.937"></line>
<circle cx="18" cy="7.5" r="2.169" style="opacity: 50%"></circle>
</svg>
</symbol>
<symbol id="svg-pencil" viewbox="0 0 24 24">
<svg class="icon-tabler-pencil-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4"></path>
<path d="M13.5 6.5l4 4"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
<symbol id="svg-eye" viewbox="0 0 24 24">
<svg class="icon-tabler-eye-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0"></path>
<path d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
</svg>
<input class="sidebar-toggle" id="__navigation" name="__navigation" type="checkbox"/>
<input class="sidebar-toggle" id="__toc" name="__toc" type="checkbox"/>
<label class="overlay sidebar-overlay" for="__navigation">
<div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
<div class="visually-hidden">Hide table of contents sidebar</div>
</label>
<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>
<div class="page">
<header class="mobile-header">
<div class="header-left">
<label class="nav-overlay-icon" for="__navigation">
<div class="visually-hidden">Toggle site navigation sidebar</div>
<i class="icon"><svg><use href="#svg-menu"></use></svg></i>
</label>
</div>
<div class="header-center">
<a href="../index.html"><div class="brand">Trio 0.27.0+dev 文档</div></a>
</div>
<div class="header-right">
<div class="theme-toggle-container theme-toggle-header">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-header-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
</header>
<aside class="sidebar-drawer">
<div class="sidebar-container">
<div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
<div class="sidebar-logo-container">
<img alt="Logo" class="sidebar-logo" src="../_static/wordmark-transparent.svg"/>
</div>
<span class="sidebar-brand-text">Trio 0.27.0+dev 文档</span>
</a><form action="../search.html" class="sidebar-search-container" method="get" role="search">
<input aria-label="搜索" class="sidebar-search" name="q" placeholder="搜索"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
<p class="caption" role="heading"><span class="caption-text">Trio 友好且全面的手册：</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../awesome-trio-libraries.html">超棒的 Trio 库</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Trio 的核心功能</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Trio 的核心功能</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="run.html">运行 Trio</a></li>
<li class="toctree-l2"><a class="reference internal" href="general_principles.html">一般原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="time_clock.html">时间和时钟</a></li>
<li class="toctree-l2"><a class="reference internal" href="cancel_timeout.html">取消和超时</a></li>
<li class="toctree-l2"><a class="reference internal" href="tasks.html">任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="task_local_storeage.html">任务存储</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">任务同步和通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="note_async_generator.html">异步生成器注意事项</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">线程（如果必须）</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">交互式调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="exc_warn.html">异常和警告</a></li>
</ul>
</input></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ref-io/index.html">Trio 中的 I/O</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Trio 中的 I/O</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ref-io/abs_api.html">抽象流 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-io/low_level.html">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code> 进行低级网络编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-io/async_file_io.html">异步文件系统 I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-io/subprocess.html">生成子进程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-io/signals.html">信号</a></li>
</ul>
</input></li>
<li class="toctree-l1"><a class="reference internal" href="../reference-testing.html">Trio 中的测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference-lowlevel.html">自省和扩展 Trio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design.html">设计和内部结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">发布历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">为 Trio 及相关项目做出贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releasing.html">准备发布</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-of-conduct.html">行为守则</a></li>
</ul>
</div>
</div>
</div>
</div>
</aside>
<div class="main">
<div class="content">
<div class="article-container">
<a class="back-to-top muted-link" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
</svg>
<span>Back to top</span>
</a>
<div class="content-icon-container">
<div class="view-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/blob/sync-docs/cn_docs/source/ref-core/task_sync.rst?plain=true" title="View this page">
<svg><use href="#svg-eye"></use></svg>
<span class="visually-hidden">View this page</span>
</a>
</div><div class="edit-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/edit/sync-docs/cn_docs/source/ref-core/task_sync.rst" title="Edit this page">
<svg><use href="#svg-pencil"></use></svg>
<span class="visually-hidden">Edit this page</span>
</a>
</div><div class="theme-toggle-container theme-toggle-content">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-content-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
<article id="furo-main-content" role="main">
<section id="synchronization">
<span id="module-trio"></span><span id="id1"></span><h1>任务同步和通信<a class="headerlink" href="#synchronization" title="Link to this heading">¶</a></h1>
<p><strong>Synchronizing and communicating between tasks</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 提供了一组标准的同步和任务间通信原语。这些对象的 API 通常是根据标准库中的类似类建模的，但也存在一些差异。</p>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p>Trio provides a standard set of synchronization and inter-task
communication primitives. These objects' APIs are generally modelled
off of the analogous classes in the standard library, but with some
differences.</p>
</div>
</div>
<section id="id2">
<h2>阻塞和非阻塞方法<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p><strong>Blocking and non-blocking methods</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<p>标准库的同步原语提供了多种机制来指定超时和阻塞行为，并且可以指示一个操作是因成功还是因超时返回的。</p>
<p>在 Trio 中，我们统一采用以下约定：</p>
<ul class="simple">
<li><p>我们不提供超时参数。如果你需要超时，可以使用取消作用域（cancel scope）。</p></li>
<li><p>对于具有非阻塞版本的操作，阻塞和非阻塞版本是不同的方法，分别命名为 <code class="docutils literal notranslate"><span class="pre">X</span></code> 和 <code class="docutils literal notranslate"><span class="pre">X_nowait</span></code>。（这类似于 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a>，但不同于大多数 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 中的类。）我们喜欢这种方法，因为它使我们能够将阻塞版本设为异步，而将非阻塞版本设为同步。</p></li>
<li><p>当非阻塞方法无法成功执行时（例如通道为空、锁已经被占用等），它会引发 <a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.WouldBlock</span></code></a> 异常。没有类似于 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Empty" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> 和 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Full" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> 的区别 —— 我们只使用一个异常，并始终如一地使用它。</p></li>
</ul>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<p>The standard library synchronization primitives have a variety of
mechanisms for specifying timeouts and blocking behavior, and of
signaling whether an operation returned due to success versus a
timeout.</p>
<p>In Trio, we standardize on the following conventions:</p>
<ul class="simple">
<li><dl class="simple">
<dt>We don't provide timeout arguments. If you want a timeout, then use</dt><dd><p>a cancel scope.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For operations that have a non-blocking variant, the blocking and</dt><dd><p>non-blocking variants are different methods with names like <code class="docutils literal notranslate"><span class="pre">X</span></code>
and <code class="docutils literal notranslate"><span class="pre">X_nowait</span></code>, respectively. (This is similar to
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a>, but unlike most of the classes in
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>.) We like this approach because it allows us to
make the blocking version async and the non-blocking version sync.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>When a non-blocking method cannot succeed (the channel is empty, the</dt><dd><p>lock is already held, etc.), then it raises <a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.WouldBlock</span></code></a>.
There's no equivalent to the <a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Empty" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> versus
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Full" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> distinction – we just have the one exception that
we use consistently.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>
</section>
<section id="id3">
<h2>公平性<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p><strong>Fairness</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<p>这些类都保证是“公平的”，这意味着在选择谁将下一个获得锁、从队列中取出项等操作时，任务总是按照等待时间最长的顺序来决定。虽然目前尚不完全清楚这是否是最好的选择（参见 <a class="reference external" href="https://github.com/python-trio/trio/issues/54">issues#54</a> ），但目前就是这样工作的。</p>
<p>作为这个含义的一个例子，下面是一个小程序，其中两个任务竞争一个锁。请注意，释放锁的任务总是在其他任务有机会运行之前立即尝试重新获取锁。（请记住，我们这里使用的是协作式多任务，所以实际上是 <em>确定性</em> 的，释放锁的任务会在其他任务醒来之前调用 <a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>；在 Trio 中，释放锁不是一个检查点。）如果使用不公平的锁，这将导致同一个任务永远持有锁，另一个任务被饿死。但如果你运行这个程序，你会看到两个任务轮流获得锁：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># fairness-demo.py</span>

<span class="kn">import</span> <a class="sphinx-codeautolink-a" href="../ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">loopy_child</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="k">async</span> <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="sa">f</span><span class="s2">"Child </span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2"> has the lock!"</span><span class="p">)</span>
            <span class="k">await</span> <a class="sphinx-codeautolink-a" href="../ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
   <span class="k">async</span> <span class="k">with</span> <a class="sphinx-codeautolink-a" href="../ref-core/tasks.html#trio.open_nursery" title="trio.open_nursery"><span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span></a><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
      <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">lock</span></a> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">trio</span><span class="o">.</span><span class="n">Lock</span></a><span class="p">()</span>
      <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">loopy_child</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">lock</span></a><span class="p">)</span>
      <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">loopy_child</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">lock</span></a><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="../ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<p>These classes are all guaranteed to be "fair", meaning that when it
comes time to choose who will be next to acquire a lock, get an item
from a queue, etc., then it always goes to the task which has been
waiting longest. It's <a class="reference external" href="https://github.com/python-trio/trio/issues/54">not entirely clear</a> whether this is the
best choice, but for now that's how it works.</p>
<p>As an example of what this means, here's a small program in which two
tasks compete for a lock. Notice that the task which releases the lock
always immediately attempts to re-acquire it, before the other task has
a chance to run. (And remember that we're doing cooperative
multi-tasking here, so it's actually <em>deterministic</em> that the task
releasing the lock will call <a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> before the other
task wakes up; in Trio releasing a lock is not a checkpoint.)  With
an unfair lock, this would result in the same task holding the lock
forever and the other task being starved out. But if you run this,
you'll see that the two tasks politely take turns:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># fairness-demo.py</span>

<span class="kn">import</span> <a class="sphinx-codeautolink-a" href="../ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">loopy_child</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="k">async</span> <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="sa">f</span><span class="s2">"Child </span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2"> has the lock!"</span><span class="p">)</span>
            <span class="k">await</span> <a class="sphinx-codeautolink-a" href="../ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
   <span class="k">async</span> <span class="k">with</span> <a class="sphinx-codeautolink-a" href="../ref-core/tasks.html#trio.open_nursery" title="trio.open_nursery"><span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span></a><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
      <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">lock</span></a> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">trio</span><span class="o">.</span><span class="n">Lock</span></a><span class="p">()</span>
      <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">loopy_child</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">lock</span></a><span class="p">)</span>
      <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">loopy_child</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="../ref-core/task_sync.html#trio.Lock" title="trio.Lock"><span class="n">lock</span></a><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="../ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="event">
<h2>使用 <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a> 广播事件<a class="headerlink" href="#event" title="Link to this heading">¶</a></h2>
<p><strong>Broadcasting an event with :class:`Event`</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.Event">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Event</span></span><a class="headerlink" href="#trio.Event" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A waitable boolean value useful for inter-task synchronization,
inspired by <a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Event" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Event</span></code></a>.</p>
<p>An event object has an internal boolean flag, representing whether
the event has happened yet. The flag is initially False, and the
<a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method waits until the flag is True. If the flag is
already True, then <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> returns immediately. (If the event has
already happened, there's nothing to wait for.) The <a class="reference internal" href="#trio.Event.set" title="trio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> method
sets the flag to True, and wakes up any waiters.</p>
<p>This behavior is useful because it helps avoid race conditions and
lost wakeups: it doesn't matter whether <a class="reference internal" href="#trio.Event.set" title="trio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> gets called just
before or after <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>. If you want a lower-level wakeup
primitive that doesn't have this protection, consider <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a>
or <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.ParkingLot</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Unlike <cite>threading.Event</cite>, <cite>trio.Event</cite> has no
<cite>~threading.Event.clear</cite> method. In Trio, once an <cite>Event</cite> has happened,
it cannot un-happen. If you need to represent a series of events,
consider creating a new <cite>Event</cite> object for each one (they're cheap!),
or other synchronization methods like <a class="reference internal" href="#channels"><span class="std std-ref">channels</span></a> or
<cite>trio.lowlevel.ParkingLot</cite>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Event.is_set">
<span class="sig-name descname"><span class="pre">is_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Event.is_set" title="Link to this definition">¶</a></dt>
<dd><p>Return the current value of the internal flag.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Event.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Event.set" title="Link to this definition">¶</a></dt>
<dd><p>Set the internal flag value to True, and wake any waiting tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Event.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Event.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.EventStatistics" title="trio.EventStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this event's
<a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Event.wait">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Event.wait" title="Link to this definition">¶</a></dt>
<dd><p>Block until the internal flag value becomes True.</p>
<p>If it's already True, then this method returns immediately.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.EventStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">EventStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.EventStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this event's
<a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Event.wait()</span></code></a> method.</p></li>
</ul>
</dd></dl>
</section>
<section id="channels">
<span id="id4"></span><h2>使用通道在任务之间传递值<a class="headerlink" href="#channels" title="Link to this heading">¶</a></h2>
<p><strong>Using channels to pass values between tasks</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p><em>Channels</em> 允许你在不同任务之间安全且便捷地传递对象。它们特别适用于实现生产者/消费者模式。</p>
<p>核心的通道 API 由抽象基类 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendChannel</span></code></a> 和 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a> 定义。你可以使用它们来实现自定义的通道，执行类似于在进程之间或通过网络传递对象的操作。但在许多情况下，你只想在单个进程内的不同任务之间传递对象，针对这种情况，你可以使用 <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_memory_channel()</span></code></a>：</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.open_memory_channel">
<span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_memory_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_buffer_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.open_memory_channel" title="Link to this definition">¶</a></dt>
<dd><p>Open a channel for passing objects between tasks within a process.</p>
<p>Memory channels are lightweight, cheap to allocate, and entirely
in-memory. They don't involve any operating-system resources, or any kind
of serialization. They just pass Python objects directly between tasks
(with a possible stop in an internal buffer along the way).</p>
<p>Channel objects can be closed by calling <cite>~trio.abc.AsyncResource.aclose</cite>
or using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. They are <em>not</em> automatically closed when garbage
collected. Closing memory channels isn't mandatory, but it is generally a
good idea, because it helps avoid situations where tasks get stuck waiting
on a channel when there's no-one on the other side. See
<a class="reference internal" href="#channel-shutdown"><span class="std std-ref">使用通道进行干净关闭</span></a> for details.</p>
<p>Memory channel operations are all atomic with respect to
cancellation, either <cite>~trio.abc.ReceiveChannel.receive</cite> will
successfully return an object, or it will raise <a class="reference internal" href="exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>
while leaving the channel unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>max_buffer_size</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/math.html/inf" title="（在 Python v3.12）"><em>math.inf</em></a>) -- The maximum number of items that can
be buffered in the channel before <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>
blocks. Choosing a sensible value here is important to ensure that
backpressure is communicated promptly and avoid unnecessary latency;
see <a class="reference internal" href="#channel-buffering"><span class="std std-ref">在通道中缓冲</span></a> for more details. If in doubt, use 0.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>[<a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">T</span></code>)], <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">T</span></code>)]]</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pair <code class="docutils literal notranslate"><span class="pre">(send_channel,</span> <span class="pre">receive_channel)</span></code>. If you have
trouble remembering which order these go in, remember: data
flows from left → right.</p>
</dd>
</dl>
<p>In addition to the standard channel methods, all memory channel objects
provide a <code class="docutils literal notranslate"><span class="pre">statistics()</span></code> method, which returns an object with the
following fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">current_buffer_used</span></code>: The number of items currently stored in the
channel buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_buffer_size</span></code>: The maximum number of items allowed in the buffer,
as passed to <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">open_send_channels</span></code>: The number of open
<a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> endpoints pointing to this channel.
Initially 1, but can be increased by
<a class="reference internal" href="#trio.MemorySendChannel.clone" title="trio.MemorySendChannel.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MemorySendChannel.clone()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">open_receive_channels</span></code>: Likewise, but for open
<a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> endpoints.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_send</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">send</span></code> on this
channel (summing over all clones).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_receive</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">receive</span></code> on
this channel (summing over all clones).</p></li>
</ul>
</dd></dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你曾经使用过 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 或 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 模块，你可能熟悉 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> 或 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio-queue.html#asyncio.Queue" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Queue</span></code></a>。在 Trio 中，<a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a> 是你在寻找队列时使用的功能。主要的区别在于，Trio 将经典的队列接口分成了两个对象。这种做法的优势是，它使得将两端放置在不同进程中成为可能，而无需重写代码，并且我们可以分别关闭这两端。</p>
</div>
<p><cite>MemorySendChannel</cite> 和 <cite>MemoryReceiveChannel</cite> 还提供了超出核心通道接口的其他一些功能：</p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.MemorySendChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">MemorySendChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">NOTHING</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendType</span></code></a>]</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemorySendChannel.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Close this send channel object asynchronously.</p>
<p>See <cite>MemorySendChannel.close</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemorySendChannel.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel.clone" title="Link to this definition">¶</a></dt>
<dd><p>Clone this send channel object.</p>
<p>This returns a new <cite>MemorySendChannel</cite> object, which acts as a
duplicate of the original: sending on the new object does exactly the
same thing as sending on the old object. (If you're familiar with
<cite>os.dup</cite>, then this is a similar idea.)</p>
<p>However, closing one of the objects does not close the other, and
receivers don't get <cite>EndOfChannel</cite> until <em>all</em> clones have been
closed.</p>
<p>This is useful for communication patterns that involve multiple
producers all sending objects to the same destination. If you give
each producer its own clone of the <cite>MemorySendChannel</cite>, and then make
sure to close each <cite>MemorySendChannel</cite> when it's finished, receivers
will automatically get notified when all producers are finished. See
<a class="reference internal" href="#channel-mpmc"><span class="std std-ref">管理多个生产者和/或多个消费者</span></a> for examples.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you already closed this
    <cite>MemorySendChannel</cite> object.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">SendType</span></code>, contravariant=True)]</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemorySendChannel.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel.close" title="Link to this definition">¶</a></dt>
<dd><p>Close this send channel object synchronously.</p>
<p>All channel objects have an asynchronous <cite>~.AsyncResource.aclose</cite> method.
Memory channels can also be closed synchronously. This has the same
effect on the channel and other tasks using it, but <cite>close</cite> is not a
trio checkpoint. This simplifies cleaning up in cancelled tasks.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">send_channel:</span></code> will close the channel object on leaving
the with block.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemorySendChannel.send">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel.send" title="Link to this definition">¶</a></dt>
<dd><p>See <cite>SendChannel.send &lt;trio.abc.SendChannel.send&gt;</cite>.</p>
<p>Memory channels allow multiple tasks to call <cite>send</cite> at the same time.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemorySendChannel.send_nowait">
<span class="sig-name descname"><span class="pre">send_nowait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel.send_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Like <cite>~trio.abc.SendChannel.send</cite>, but if the channel's buffer is
full, raises <cite>WouldBlock</cite> instead of blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemorySendChannel.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemorySendChannel.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Returns a <cite>MemoryChannelStatistics</cite> for the memory channel this is
associated with.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemoryChannelStatistics" title="trio.MemoryChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">MemoryReceiveChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">NOTHING</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveType</span></code></a>]</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Close this receive channel object asynchronously.</p>
<p>See <cite>MemoryReceiveChannel.close</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel.clone" title="Link to this definition">¶</a></dt>
<dd><p>Clone this receive channel object.</p>
<p>This returns a new <cite>MemoryReceiveChannel</cite> object, which acts as a
duplicate of the original: receiving on the new object does exactly
the same thing as receiving on the old object.</p>
<p>However, closing one of the objects does not close the other, and the
underlying channel is not closed until all clones are closed. (If
you're familiar with <cite>os.dup</cite>, then this is a similar idea.)</p>
<p>This is useful for communication patterns that involve multiple
consumers all receiving objects from the same underlying channel. See
<a class="reference internal" href="#channel-mpmc"><span class="std std-ref">管理多个生产者和/或多个消费者</span></a> for examples.
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ReceiveType</span></code>, covariant=True)]</span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>The clones all share the same underlying channel.
Whenever a clone <a class="reference internal" href="#trio.MemoryReceiveChannel.receive" title="trio.MemoryReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>s a value, it is removed from the
channel and the other clones do <em>not</em> receive that value. If you
want to send multiple copies of the same stream of values to
multiple destinations, like <a class="reference external" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.tee" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.tee()</span></code></a>, then you need to
find some other solution; this method does <em>not</em> do that.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you already closed this
    <cite>MemoryReceiveChannel</cite> object.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel.close" title="Link to this definition">¶</a></dt>
<dd><p>Close this receive channel object synchronously.</p>
<p>All channel objects have an asynchronous <cite>~.AsyncResource.aclose</cite> method.
Memory channels can also be closed synchronously. This has the same
effect on the channel and other tasks using it, but <cite>close</cite> is not a
trio checkpoint. This simplifies cleaning up in cancelled tasks.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">receive_channel:</span></code> will close the channel object on
leaving the with block.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel.receive">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel.receive" title="Link to this definition">¶</a></dt>
<dd><p>See <cite>ReceiveChannel.receive &lt;trio.abc.ReceiveChannel.receive&gt;</cite>.</p>
<p>Memory channels allow multiple tasks to call <cite>receive</cite> at the same
time. The first task will get the first item sent, the second task
will get the second item sent, and so on.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ReceiveType</span></code>, covariant=True)</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel.receive_nowait">
<span class="sig-name descname"><span class="pre">receive_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel.receive_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Like <cite>~trio.abc.ReceiveChannel.receive</cite>, but if there's nothing
ready to receive, raises <cite>WouldBlock</cite> instead of blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ReceiveType</span></code>, covariant=True)</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.MemoryReceiveChannel.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryReceiveChannel.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Returns a <cite>MemoryChannelStatistics</cite> for the memory channel this is
associated with.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemoryChannelStatistics" title="trio.MemoryChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.MemoryChannelStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">MemoryChannelStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_buffer_used</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_buffer_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open_send_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open_receive_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting_send</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting_receive</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.MemoryChannelStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p><em>Channels</em> allow you to safely and conveniently send objects between
different tasks. They're particularly useful for implementing
producer/consumer patterns.</p>
<p>The core channel API is defined by the abstract base classes
<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendChannel</span></code></a> and <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a>.
You can use these to implement your own custom channels, that do
things like pass objects between processes or over the network. But in
many cases, you just want to pass objects between different tasks
inside a single process, and for that you can use
<a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_memory_channel()</span></code></a>:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_memory_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_buffer_size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Open a channel for passing objects between tasks within a process.</p>
<p>Memory channels are lightweight, cheap to allocate, and entirely
in-memory. They don't involve any operating-system resources, or any kind
of serialization. They just pass Python objects directly between tasks
(with a possible stop in an internal buffer along the way).</p>
<p>Channel objects can be closed by calling <cite>~trio.abc.AsyncResource.aclose</cite>
or using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. They are <em>not</em> automatically closed when garbage
collected. Closing memory channels isn't mandatory, but it is generally a
good idea, because it helps avoid situations where tasks get stuck waiting
on a channel when there's no-one on the other side. See
<a class="reference internal" href="#channel-shutdown"><span class="std std-ref">使用通道进行干净关闭</span></a> for details.</p>
<p>Memory channel operations are all atomic with respect to
cancellation, either <cite>~trio.abc.ReceiveChannel.receive</cite> will
successfully return an object, or it will raise <a class="reference internal" href="exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>
while leaving the channel unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>max_buffer_size</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/math.html/inf" title="（在 Python v3.12）"><em>math.inf</em></a>) -- The maximum number of items that can
be buffered in the channel before <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>
blocks. Choosing a sensible value here is important to ensure that
backpressure is communicated promptly and avoid unnecessary latency;
see <a class="reference internal" href="#channel-buffering"><span class="std std-ref">在通道中缓冲</span></a> for more details. If in doubt, use 0.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>[<a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">T</span></code>)], <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">T</span></code>)]]</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pair <code class="docutils literal notranslate"><span class="pre">(send_channel,</span> <span class="pre">receive_channel)</span></code>. If you have
trouble remembering which order these go in, remember: data
flows from left → right.</p>
</dd>
</dl>
<p>In addition to the standard channel methods, all memory channel objects
provide a <code class="docutils literal notranslate"><span class="pre">statistics()</span></code> method, which returns an object with the
following fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">current_buffer_used</span></code>: The number of items currently stored in the
channel buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_buffer_size</span></code>: The maximum number of items allowed in the buffer,
as passed to <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">open_send_channels</span></code>: The number of open
<a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> endpoints pointing to this channel.
Initially 1, but can be increased by
<a class="reference internal" href="#trio.MemorySendChannel.clone" title="trio.MemorySendChannel.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MemorySendChannel.clone()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">open_receive_channels</span></code>: Likewise, but for open
<a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> endpoints.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_send</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">send</span></code> on this
channel (summing over all clones).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_receive</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">receive</span></code> on
this channel (summing over all clones).</p></li>
</ul>
</dd></dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>If you've used the <a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> or <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>
modules, you may be familiar with <a class="reference external" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> or
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio-queue.html#asyncio.Queue" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Queue</span></code></a>. In Trio, <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a> is
what you use when you're looking for a queue. The main difference
is that Trio splits the classic queue interface up into two
objects. The advantage of this is that it makes it possible to put
the two ends in different processes without rewriting your code,
and that we can close the two sides separately.</p>
</div>
<p><cite>MemorySendChannel</cite> and <cite>MemoryReceiveChannel</cite> also expose several
more features beyond the core channel interface:</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">MemorySendChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">NOTHING</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendType</span></code></a>]</p>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this send channel object asynchronously.</p>
<p>See <cite>MemorySendChannel.close</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Clone this send channel object.</p>
<p>This returns a new <cite>MemorySendChannel</cite> object, which acts as a
duplicate of the original: sending on the new object does exactly the
same thing as sending on the old object. (If you're familiar with
<cite>os.dup</cite>, then this is a similar idea.)</p>
<p>However, closing one of the objects does not close the other, and
receivers don't get <cite>EndOfChannel</cite> until <em>all</em> clones have been
closed.</p>
<p>This is useful for communication patterns that involve multiple
producers all sending objects to the same destination. If you give
each producer its own clone of the <cite>MemorySendChannel</cite>, and then make
sure to close each <cite>MemorySendChannel</cite> when it's finished, receivers
will automatically get notified when all producers are finished. See
<a class="reference internal" href="#channel-mpmc"><span class="std std-ref">管理多个生产者和/或多个消费者</span></a> for examples.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you already closed this
    <cite>MemorySendChannel</cite> object.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">SendType</span></code>, contravariant=True)]</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this send channel object synchronously.</p>
<p>All channel objects have an asynchronous <cite>~.AsyncResource.aclose</cite> method.
Memory channels can also be closed synchronously. This has the same
effect on the channel and other tasks using it, but <cite>close</cite> is not a
trio checkpoint. This simplifies cleaning up in cancelled tasks.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">send_channel:</span></code> will close the channel object on leaving
the with block.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>See <cite>SendChannel.send &lt;trio.abc.SendChannel.send&gt;</cite>.</p>
<p>Memory channels allow multiple tasks to call <cite>send</cite> at the same time.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_nowait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Like <cite>~trio.abc.SendChannel.send</cite>, but if the channel's buffer is
full, raises <cite>WouldBlock</cite> instead of blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a <cite>MemoryChannelStatistics</cite> for the memory channel this is
associated with.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemoryChannelStatistics" title="trio.MemoryChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">MemoryReceiveChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">NOTHING</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveType</span></code></a>]</p>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this receive channel object asynchronously.</p>
<p>See <cite>MemoryReceiveChannel.close</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Clone this receive channel object.</p>
<p>This returns a new <cite>MemoryReceiveChannel</cite> object, which acts as a
duplicate of the original: receiving on the new object does exactly
the same thing as receiving on the old object.</p>
<p>However, closing one of the objects does not close the other, and the
underlying channel is not closed until all clones are closed. (If
you're familiar with <cite>os.dup</cite>, then this is a similar idea.)</p>
<p>This is useful for communication patterns that involve multiple
consumers all receiving objects from the same underlying channel. See
<a class="reference internal" href="#channel-mpmc"><span class="std std-ref">管理多个生产者和/或多个消费者</span></a> for examples.
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ReceiveType</span></code>, covariant=True)]</span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>The clones all share the same underlying channel.
Whenever a clone <a class="reference internal" href="#trio.MemoryReceiveChannel.receive" title="trio.MemoryReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>s a value, it is removed from the
channel and the other clones do <em>not</em> receive that value. If you
want to send multiple copies of the same stream of values to
multiple destinations, like <a class="reference external" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.tee" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.tee()</span></code></a>, then you need to
find some other solution; this method does <em>not</em> do that.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you already closed this
    <cite>MemoryReceiveChannel</cite> object.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this receive channel object synchronously.</p>
<p>All channel objects have an asynchronous <cite>~.AsyncResource.aclose</cite> method.
Memory channels can also be closed synchronously. This has the same
effect on the channel and other tasks using it, but <cite>close</cite> is not a
trio checkpoint. This simplifies cleaning up in cancelled tasks.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">receive_channel:</span></code> will close the channel object on
leaving the with block.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>See <cite>ReceiveChannel.receive &lt;trio.abc.ReceiveChannel.receive&gt;</cite>.</p>
<p>Memory channels allow multiple tasks to call <cite>receive</cite> at the same
time. The first task will get the first item sent, the second task
will get the second item sent, and so on.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ReceiveType</span></code>, covariant=True)</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">receive_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Like <cite>~trio.abc.ReceiveChannel.receive</cite>, but if there's nothing
ready to receive, raises <cite>WouldBlock</cite> instead of blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ReceiveType</span></code>, covariant=True)</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a <cite>MemoryChannelStatistics</cite> for the memory channel this is
associated with.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.MemoryChannelStatistics" title="trio.MemoryChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">MemoryChannelStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_buffer_used</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_buffer_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open_send_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open_receive_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting_send</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting_receive</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
</dd></dl>
</div>
</div>
<section id="id5">
<h3>一个简单的通道示例<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<p><strong>A simple channel example</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p>这是一个如何使用内存通道的简单示例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">trio</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="c1"># Open a channel:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Start a producer and a consumer, passing one end of the channel to</span>
        <span class="c1"># each of them:</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">send_channel</span><span class="p">):</span>
    <span class="c1"># Producer sends 3 messages</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># The producer sends using 'await send_channel.send(...)'</span>
        <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"message </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">receive_channel</span><span class="p">):</span>
    <span class="c1"># The consumer uses an 'async for' loop to receive the values:</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你运行这个程序，它会打印：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>got value "message 0"
got value "message 1"
got value "message 2"
</pre></div>
</div>
<p>然后它会一直挂起。（使用控制-C退出。）</p>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>Here's a simple example of how to use memory channels:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">trio</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="c1"># Open a channel:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Start a producer and a consumer, passing one end of the channel to</span>
        <span class="c1"># each of them:</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">send_channel</span><span class="p">):</span>
    <span class="c1"># Producer sends 3 messages</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># The producer sends using 'await send_channel.send(...)'</span>
        <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"message </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">receive_channel</span><span class="p">):</span>
    <span class="c1"># The consumer uses an 'async for' loop to receive the values:</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>If you run this, it prints:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>got value "message 0"
got value "message 1"
got value "message 2"
</pre></div>
</div>
<p>And then it hangs forever. (Use control-C to quit.)</p>
</div>
</div>
</section>
<section id="channel-shutdown">
<span id="id6"></span><h3>使用通道进行干净关闭<a class="headerlink" href="#channel-shutdown" title="Link to this heading">¶</a></h3>
<p><strong>Clean shutdown with channels</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--5-input--1" name="tab-set--5" type="radio"/><label class="tab-label" for="tab-set--5-input--1">中文</label><div class="tab-content docutils container">
<p>当然，我们通常不希望程序挂起。发生了什么？问题在于生产者发送了 3 条消息后退出了，但消费者无法得知生产者已经消失：对它来说，可能随时会有另一条消息到来。所以它会一直挂起，等待第四条消息。</p>
<p>这是修复后的新版本：它产生与前一个版本相同的输出，然后干净地退出。唯一的变化是在生产者和消费者中增加了 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 块：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">trio</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">send_channel</span><span class="p">):</span>
<span class="hll">    <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">:</span>
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"message </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">receive_channel</span><span class="p">):</span>
<span class="hll">    <span class="k">async</span> <span class="k">with</span> <span class="n">receive_channel</span><span class="p">:</span>
</span>        <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>这里最重要的是生产者的 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>。当生产者退出时，这会关闭 <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>，这就告诉消费者没有更多的消息要来了，因此它可以干净地退出 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 循环。然后程序会退出，因为两个任务都已退出。</p>
<p>我们还在消费者中添加了一个 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>。这并不是那么重要，但它有助于我们捕捉错误或其他问题。例如，假设消费者由于某种原因提前退出了——可能是因为一个 bug。那么生产者就会把消息发送到空洞中，并可能无限期地卡住。但是，如果消费者关闭了 <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>，生产者就会收到一个 <a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>，提醒它应该停止发送消息，因为没有人在接收。</p>
<p>如果你想查看消费者提前退出的效果，可以尝试在 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 循环中添加一个 <code class="docutils literal notranslate"><span class="pre">break</span></code> 语句——你应该会看到生产者收到一个 <a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>。</p>
</div>
<input class="tab-input" id="tab-set--5-input--2" name="tab-set--5" type="radio"/><label class="tab-label" for="tab-set--5-input--2">英文</label><div class="tab-content docutils container">
<p>Of course we don't generally like it when programs hang. What
happened? The problem is that the producer sent 3 messages and then
exited, but the consumer has no way to tell that the producer is gone:
for all it knows, another message might be coming along any moment. So
it hangs forever waiting for the 4th message.</p>
<p>Here's a new version that fixes this: it produces the same output as
the previous version, and then exits cleanly. The only change is the
addition of <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> blocks inside the producer and consumer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">trio</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">send_channel</span><span class="p">):</span>
<span class="hll">    <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">:</span>
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"message </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">receive_channel</span><span class="p">):</span>
<span class="hll">    <span class="k">async</span> <span class="k">with</span> <span class="n">receive_channel</span><span class="p">:</span>
</span>        <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>The really important thing here is the producer's <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> .
When the producer exits, this closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>, and that
tells the consumer that no more messages are coming, so it can cleanly
exit its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop. Then the program shuts down because both
tasks have exited.</p>
<p>We also added an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> to the consumer. This isn't as
important, but it can help us catch mistakes or other problems. For
example, suppose that the consumer exited early for some reason –
maybe because of a bug. Then the producer would be sending messages
into the void, and might get stuck indefinitely. But, if the consumer
closes its <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>, then the producer will get a
<a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> to alert it that it should stop sending
messages because no-one is listening.</p>
<p>If you want to see the effect of the consumer exiting early, try
adding a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop – you should
see a <a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> from the producer.</p>
</div>
</div>
</section>
<section id="channel-mpmc">
<span id="id7"></span><h3>管理多个生产者和/或多个消费者<a class="headerlink" href="#channel-mpmc" title="Link to this heading">¶</a></h3>
<p><strong>Managing multiple producers and/or multiple consumers</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--6-input--1" name="tab-set--6" type="radio"/><label class="tab-label" for="tab-set--6-input--1">中文</label><div class="tab-content docutils container">
<p>你也可以有多个生产者和多个消费者，共享同一个通道。不过，这样做会使得关闭过程稍微复杂一些。</p>
<p>例如，考虑一下我们之前示例的简单扩展，现在有两个生产者和两个消费者：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This example usually crashes!</span>

<span class="kn">import</span> <span class="nn">trio</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Start two producers</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="c1"># And two consumers</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> from producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>这两个生产者 A 和 B 每个发送 3 条消息。然后这些消息会随机分配给两个消费者 X 和 Y。因此，我们希望看到类似这样的输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>consumer Y got value '0 from producer B'
consumer X got value '0 from producer A'
consumer Y got value '1 from producer A'
consumer Y got value '1 from producer B'
consumer X got value '2 from producer B'
consumer X got value '2 from producer A'
</pre></div>
</div>
<p>然而，在大多数情况下，结果并非如此——输出的前一部分是正常的，但当程序运行到结束时，会因为 <a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a> 崩溃。如果你运行几次这个程序，你会发现有时 tracebacks 显示是 <code class="docutils literal notranslate"><span class="pre">send</span></code> 崩溃，有时是 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 崩溃，甚至有时它根本不会崩溃。</p>
<p>发生了什么呢？假设生产者 A 最先完成。它退出了，并且它的 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 块关闭了 <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>。但是等等！生产者 B 仍在使用这个 <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>... 所以下次 B 调用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 时，它会遇到 <a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>。</p>
<p>然而，有时如果我们幸运的话，两个生产者可能同时完成（或者足够接近），这样它们都在关闭 <code class="docutils literal notranslate"><span class="pre">send_channel</span></code> 之前完成最后一次 <code class="docutils literal notranslate"><span class="pre">send</span></code>。</p>
<p>但是，即使那样，我们仍然没有完全解决问题！在生产者退出后，两个消费者会争先恐后地检查 <code class="docutils literal notranslate"><span class="pre">send_channel</span></code> 是否已关闭。假设 X 赢得了比赛。它退出了 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 循环，然后退出了 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 块... 并关闭了 <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>，而 Y 仍在使用它。再次，这会导致崩溃。</p>
<p>我们本可以通过一些复杂的账务处理来确保只有 <em>最后</em> 一个生产者和 <em>最后</em> 一个消费者关闭它们的通道端点... 但那样做会非常繁琐且不可靠。幸运的是，有更好的方法！这是我们上面程序的修复版本：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">trio</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">        <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">:</span>
</span>            <span class="c1"># Start two producers, giving each its own private clone</span>
<span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span><span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span>            <span class="c1"># And two consumers, giving each its own private clone</span>
<span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span><span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> from producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>这个示例演示了如何使用 <cite>MemorySendChannel.clone</cite> 和 <cite>MemoryReceiveChannel.clone</cite> 方法。它们的作用是创建通道端点的副本，这些副本就像原始端点一样工作——唯一的区别是它们可以独立地关闭。而且，只有在 <em>所有</em> 副本都关闭之后，底层的通道才会关闭。因此，这完全解决了我们的关闭问题，如果你运行这个程序，你会看到它打印六行输出后干净地退出。</p>
<p>请注意我们使用的一个小技巧：<code class="docutils literal notranslate"><span class="pre">main</span></code> 中的代码创建了克隆对象并将它们传递给所有子任务，然后使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 关闭原始对象。另一种选择是将副本传递给所有任务（除了最后一个），然后将原始对象传递给最后一个任务，如下所示：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 也有效，但更容易出错：</span>
<span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>但是这样更容易出错，尤其是在你使用循环来启动生产者/消费者时。</p>
<p>请确保不要写：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 错误，程序将挂起：</span>
<span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</pre></div>
</div>
<p>在这里，我们将副本传递给任务，但从未关闭原始对象。这意味着我们有 3 个发送通道对象（原始对象 + 两个副本），但我们只关闭了 2 个它们，因此消费者将永远等待最后一个通道被关闭。</p>
</div>
<input class="tab-input" id="tab-set--6-input--2" name="tab-set--6" type="radio"/><label class="tab-label" for="tab-set--6-input--2">英文</label><div class="tab-content docutils container">
<p>You can also have multiple producers, and multiple consumers, all
sharing the same channel. However, this makes shutdown a little more
complicated.</p>
<p>For example, consider this naive extension of our previous example,
now with two producers and two consumers:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This example usually crashes!</span>

<span class="kn">import</span> <span class="nn">trio</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Start two producers</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="c1"># And two consumers</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> from producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>The two producers, A and B, send 3 messages apiece. These are then
randomly distributed between the two consumers, X and Y. So we're
hoping to see some output like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>consumer Y got value '0 from producer B'
consumer X got value '0 from producer A'
consumer Y got value '1 from producer A'
consumer Y got value '1 from producer B'
consumer X got value '2 from producer B'
consumer X got value '2 from producer A'
</pre></div>
</div>
<p>However, on most runs, that's not what happens – the first part of the
output is OK, and then when we get to the end the program crashes with
<a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>. If you run the program a few times, you'll
see that sometimes the traceback shows <code class="docutils literal notranslate"><span class="pre">send</span></code> crashing, and other
times it shows <code class="docutils literal notranslate"><span class="pre">receive</span></code> crashing, and you might even find that on
some runs it doesn't crash at all.</p>
<p>Here's what's happening: suppose that producer A finishes first. It
exits, and its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>. But
wait! Producer B was still using that <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>... so the next
time B calls <code class="docutils literal notranslate"><span class="pre">send</span></code>, it gets a <a class="reference internal" href="exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p>
<p>Sometimes, though if we're lucky, the two producers might finish at
the same time (or close enough), so they both make their last <code class="docutils literal notranslate"><span class="pre">send</span></code>
before either of them closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>.</p>
<p>But, even if that happens, we're not out of the woods yet! After the
producers exit, the two consumers race to be the first to notice that
the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code> has closed. Suppose that X wins the race. It
exits its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop, then exits the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block...
and closes the <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>, while Y is still using it. Again,
this causes a crash.</p>
<p>We could avoid this by using some complicated bookkeeping to make sure
that only the <em>last</em> producer and the <em>last</em> consumer close their
channel endpoints... but that would be tiresome and fragile.
Fortunately, there's a better way! Here's a fixed version of our
program above:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">trio</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">        <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">:</span>
</span>            <span class="c1"># Start two producers, giving each its own private clone</span>
<span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span><span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span>            <span class="c1"># And two consumers, giving each its own private clone</span>
<span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span><span class="hll">            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">send_channel</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> from producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> got value </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
            <span class="c1"># Random sleeps help trigger the problem more reliably</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>This example demonstrates using the <cite>MemorySendChannel.clone</cite> and
<cite>MemoryReceiveChannel.clone</cite> methods. What these do is create copies
of our endpoints, that act just like the original – except that they
can be closed independently. And the underlying channel is only closed
after <em>all</em> the clones have been closed. So this completely solves our
problem with shutdown, and if you run this program, you'll see it
print its six lines of output and then exits cleanly.</p>
<p>Notice a small trick we use: the code in <code class="docutils literal notranslate"><span class="pre">main</span></code> creates clone
objects to pass into all the child tasks, and then closes the original
objects using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. Another option is to pass clones into
all-but-one of the child tasks, and then pass the original object into
the last task, like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Also works, but is more finicky:</span>
<span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>
</pre></div>
</div>
<p>But this is more error-prone, especially if you use a loop to spawn
the producers/consumers.</p>
<p>Just make sure that you don't write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Broken, will cause program to hang:</span>
<span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="s2">"B"</span><span class="p">,</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"X"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
<span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="s2">"Y"</span><span class="p">,</span> <span class="n">receive_channel</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
</pre></div>
</div>
<p>Here we pass clones into the tasks, but never close the original
objects. That means we have 3 send channel objects (the original + two
clones), but we only close 2 of them, so the consumers will hang
around forever waiting for that last one to be closed.</p>
</div>
</div>
</section>
<section id="channel-buffering">
<span id="id8"></span><h3>在通道中缓冲<a class="headerlink" href="#channel-buffering" title="Link to this heading">¶</a></h3>
<p><strong>Buffering in channels</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--7-input--1" name="tab-set--7" type="radio"/><label class="tab-label" for="tab-set--7-input--1">中文</label><div class="tab-content docutils container">
<p>当你调用 <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a> 时，必须指定通道中可以缓冲多少个值。如果缓冲区已满，那么任何调用 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 的任务都会停止，并等待另一个任务调用 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>。这是有用的，因为它会产生 <em>背压</em>：如果通道的生产者运行速度快于消费者，它会迫使生产者放慢速度。</p>
<p>你可以通过 <code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code> 完全禁用缓冲。在这种情况下，任何调用 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 的任务都会等待，直到另一个任务调用 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>，反之亦然。这类似于 <a class="reference external" href="https://en.wikipedia.org/wiki/Channel_(programming)">经典的通信顺序进程模型</a> 中通道的工作方式，并且如果你不确定应该使用多大的缓冲区，这是一个合理的默认值。（这就是我们在上面示例中使用它的原因。）</p>
<p>在另一个极端，你可以通过使用 <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code> 来使缓冲区无限大。在这种情况下，<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> <em>始终</em> 会立即返回。通常，这不是一个好主意。为了看清楚为什么，考虑一个生产者运行速度快于消费者的程序：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulate a producer that generates values 10x faster than the</span>
<span class="c1"># consumer can handle them.</span>

<span class="kn">import</span> <span class="nn">trio</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">send_channel</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Pretend that we have to do some work to create this message, and it</span>
        <span class="c1"># takes 0.1 seconds:</span>
        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Sent message:"</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">receive_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Received message:"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Pretend that we have to do some work to handle this message, and it</span>
        <span class="c1"># takes 1 second</span>
        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你运行这个程序，你会看到类似这样的输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Sent message: 4
Sent message: 5
Sent message: 6
Sent message: 7
Sent message: 8
Sent message: 9
Received message: 1
Sent message: 10
Sent message: 11
Sent message: 12
...
</pre></div>
</div>
<p>平均而言，生产者每秒发送十条消息，但消费者每秒只调用一次 <code class="docutils literal notranslate"><span class="pre">receive</span></code>。这意味着每秒，通道的内部缓冲区必须增长以容纳额外的九个项。经过一分钟，缓冲区将包含大约 540 条消息；经过一小时，它将增加到大约 32,400 条。最终，程序将耗尽内存。在我们耗尽内存之前，处理单个消息的延迟将变得极其糟糕。例如，在一分钟时，生产者正在发送大约第 600 条消息，但消费者仍在处理第 60 条消息。第 600 条消息将在通道中等待大约 9 分钟，直到消费者赶上并处理它。</p>
<p>现在，尝试将 <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>，然后再次运行它。我们会看到类似这样的输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sent message: 0
Received message: 0
Received message: 1
Sent message: 1
Received message: 2
Sent message: 2
Sent message: 3
Received message: 3
...
</pre></div>
</div>
<p>现在， <code class="docutils literal notranslate"><span class="pre">send</span></code> 调用会等待 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 调用完成，这迫使生产者放慢速度以匹配消费者的速度。（可能看起来有些奇怪的是，一些值在报告为 "Sent" 之前先报告为 "Received"；这是因为实际的发送/接收操作是同时发生的，因此哪一行先打印是随机的。）</p>
<p>现在，让我们尝试设置一个小但非零的缓冲区大小，如 <code class="docutils literal notranslate"><span class="pre">open_memory_channel(3)</span></code>。你认为会发生什么？</p>
<p>我得到的是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Received message: 1
Sent message: 4
Received message: 2
Sent message: 5
...
</pre></div>
</div>
<p>所以你可以看到，生产者提前发送了 3 条消息，然后停止等待：当消费者读取消息 1 时，它发送消息 4，然后当消费者读取消息 2 时，它发送消息 5，依此类推。一旦它达到稳定状态，这个版本的行为就像我们之前将缓冲区大小设置为 0 的版本一样，只是它使用了更多的内存，并且每条消息在被处理之前在缓冲区中停留的时间更长（即消息的延迟更高）。</p>
<p>当然，真实的生产者和消费者通常比这更复杂，在某些情况下，适量的缓冲可能会提高吞吐量。但过多的缓冲会浪费内存并增加延迟，因此如果你想调整应用程序的性能，应该进行实验，以找出最适合你的缓冲区大小。</p>
<p><strong>那么我们为什么还要支持无限缓冲呢？</strong> 好问题！尽管我们上面看到的所有问题，在某些情况下，你确实需要一个无限缓冲区。例如，考虑一个使用通道跟踪所有它仍然想抓取的 URL 的网页爬虫。每个爬虫运行一个循环，它从通道中获取一个 URL，抓取它，检查 HTML 中的外部链接，然后将新的 URL 添加到通道中。这创建了一个 <em>循环流</em>，其中每个消费者也是一个生产者。在这种情况下，如果你的通道缓冲区满了，那么爬虫在尝试将新 URL 添加到通道时会被阻塞，如果所有的爬虫都被阻塞，那么它们就无法从通道中取出任何 URL，因此它们永远会陷入死锁。使用无限通道可以避免这种情况，因为它意味着 <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 永远不会阻塞。</p>
</div>
<input class="tab-input" id="tab-set--7-input--2" name="tab-set--7" type="radio"/><label class="tab-label" for="tab-set--7-input--2">英文</label><div class="tab-content docutils container">
<p>When you call <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>, you have to specify how
many values can be buffered internally in the channel. If the buffer
is full, then any task that calls <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>
will stop and wait for another task to call
<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>. This is useful because it
produces <em>backpressure</em>: if the channel producers are running faster
than the consumers, then it forces the producers to slow down.</p>
<p>You can disable buffering entirely, by doing
<code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>. In that case any task that calls
<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> will wait until another task calls
<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>, and vice versa. This is similar to
how channels work in the <a class="reference external" href="https://en.wikipedia.org/wiki/Channel_(programming)">classic Communicating Sequential Processes
model</a>, and is
a reasonable default if you aren't sure what size buffer to use.
(That's why we used it in the examples above.)</p>
<p>At the other extreme, you can make the buffer unbounded by using
<code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code>. In this case,
<a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> <em>always</em> returns immediately.
Normally, this is a bad idea. To see why, consider a program where the
producer runs more quickly than the consumer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulate a producer that generates values 10x faster than the</span>
<span class="c1"># consumer can handle them.</span>

<span class="kn">import</span> <span class="nn">trio</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">send_channel</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Pretend that we have to do some work to create this message, and it</span>
        <span class="c1"># takes 0.1 seconds:</span>
        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">send_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Sent message:"</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">receive_channel</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Received message:"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Pretend that we have to do some work to handle this message, and it</span>
        <span class="c1"># takes 1 second</span>
        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">send_channel</span><span class="p">,</span> <span class="n">receive_channel</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_memory_channel</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">send_channel</span><span class="p">)</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="n">receive_channel</span><span class="p">)</span>


<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>If you run this program, you'll see output like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Sent message: 4
Sent message: 5
Sent message: 6
Sent message: 7
Sent message: 8
Sent message: 9
Received message: 1
Sent message: 10
Sent message: 11
Sent message: 12
...
</pre></div>
</div>
<p>On average, the producer sends ten messages per second, but the
consumer only calls <code class="docutils literal notranslate"><span class="pre">receive</span></code> once per second. That means that each
second, the channel's internal buffer has to grow to hold an extra
nine items. After a minute, the buffer will have ~540 items in it;
after an hour, that grows to ~32,400. Eventually, the program will run
out of memory. And well before we run out of memory, our latency on
handling individual messages will become abysmal. For example, at the
one minute mark, the producer is sending message ~600, but the
consumer is still processing message ~60. Message 600 will have to sit
in the channel for ~9 minutes before the consumer catches up and
processes it.</p>
<p>Now try replacing <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code> with
<code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>, and run it again. We get output like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sent message: 0
Received message: 0
Received message: 1
Sent message: 1
Received message: 2
Sent message: 2
Sent message: 3
Received message: 3
...
</pre></div>
</div>
<p>Now the <code class="docutils literal notranslate"><span class="pre">send</span></code> calls wait for the <code class="docutils literal notranslate"><span class="pre">receive</span></code> calls to finish, which
forces the producer to slow down to match the consumer's speed. (It
might look strange that some values are reported as "Received" before
they're reported as "Sent"; this happens because the actual
send/receive happen at the same time, so which line gets printed first
is random.)</p>
<p>Now, let's try setting a small but nonzero buffer size, like
<code class="docutils literal notranslate"><span class="pre">open_memory_channel(3)</span></code>. what do you think will happen?</p>
<p>I get:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Received message: 1
Sent message: 4
Received message: 2
Sent message: 5
...
</pre></div>
</div>
<p>So you can see that the producer runs ahead by 3 messages, and then
stops to wait: when the consumer reads message 1, it sends message 4,
then when the consumer reads message 2, it sends message 5, and so on.
Once it reaches the steady state, this version acts just like our
previous version where we set the buffer size to 0, except that it
uses a bit more memory and each message sits in the buffer for a bit
longer before being processed (i.e., the message latency is higher).</p>
<p>Of course real producers and consumers are usually more complicated
than this, and in some situations, a modest amount of buffering might
improve throughput. But too much buffering wastes memory and increases
latency, so if you want to tune your application you should experiment
to see what value works best for you.</p>
<p><strong>Why do we even support unbounded buffers then?</strong> Good question!
Despite everything we saw above, there are times when you actually do
need an unbounded buffer. For example, consider a web crawler that
uses a channel to keep track of all the URLs it still wants to crawl.
Each crawler runs a loop where it takes a URL from the channel,
fetches it, checks the HTML for outgoing links, and then adds the new
URLs to the channel. This creates a <em>circular flow</em>, where each
consumer is also a producer. In this case, if your channel buffer gets
full, then the crawlers will block when they try to add new URLs to
the channel, and if all the crawlers got blocked, then they aren't
taking any URLs out of the channel, so they're stuck forever in a
deadlock. Using an unbounded channel avoids this, because it means
that <a class="reference internal" href="../ref-io/abs_api.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> never blocks.</p>
</div>
</div>
</section>
</section>
<section id="id9">
<h2>较低级别的同步原语<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h2>
<p><strong>Lower-level synchronization primitives</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--8-input--1" name="tab-set--8" type="radio"/><label class="tab-label" for="tab-set--8-input--1">中文</label><div class="tab-content docutils container">
<p>就我个人而言，我发现事件和通道通常足够实现我关心的大多数功能，而且它们比本节中讨论的低级原语更易于阅读代码。但如果你需要它们，它们在这里。（如果你发现自己在使用这些原语来实现新的更高级别的同步原语，那么你可能还想查看 <a class="reference internal" href="../reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> 中的设施，以便更直接地接触 Trio 的底层同步逻辑。本节中讨论的所有类都是基于 <a class="reference internal" href="../reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> 中的公共 API 实现的；它们没有对 Trio 内部的特殊访问权限。）</p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.CapacityLimiter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">CapacityLimiter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">total_tokens</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter" title="Link to this definition">¶</a></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncContextManagerMixin</span></code></p>
<p>An object for controlling access to a resource with limited capacity.</p>
<p>Sometimes you need to put a limit on how many tasks can do something at
the same time. For example, you might want to use some threads to run
multiple blocking I/O operations in parallel... but if you use too many
threads at once, then your system can become overloaded and it'll actually
make things slower. One popular solution is to impose a policy like "run
up to 40 threads at the same time, but no more". But how do you implement
a policy like this?</p>
<p>That's what <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is for. You can think of a
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> object as a sack that starts out holding some fixed
number of tokens:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">limit</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">CapacityLimiter</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>Then tasks can come along and borrow a token out of the sack:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Borrow a token:</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">limit</span><span class="p">:</span>
    <span class="c1"># We are holding a token!</span>
    <span class="k">await</span> <span class="n">perform_expensive_operation</span><span class="p">()</span>
<span class="c1"># Exiting the 'async with' block puts the token back into the sack</span>
</pre></div>
</div>
<p>And crucially, if you try to borrow a token but the sack is empty, then
you have to wait for another task to finish what it's doing and put its
token back first before you can take it and continue.</p>
<p>Another way to think of it: a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is like a sofa with a
fixed number of seats, and if they're all taken then you have to wait for
someone to get up before you can sit down.</p>
<p>By default, <a class="reference internal" href="threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> uses a
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> to limit the number of threads running at once;
see <cite>trio.to_thread.current_default_thread_limiter</cite> for details.</p>
<p>If you're familiar with semaphores, then you can think of this as a
restricted semaphore that's specialized for one common use case, with
additional error checking. For a more traditional semaphore, see
<a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Don't confuse this with the <a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket">"leaky bucket"</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket">"token bucket"</a> algorithms used to
limit bandwidth usage on networks. The basic idea of using tokens to
track a resource limit is similar, but this is a very simple sack where
tokens aren't automatically created or destroyed over time; they're
just borrowed and then put back.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.acquire">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.acquire" title="Link to this definition">¶</a></dt>
<dd><p>Borrow a token from the sack, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the current task already holds one of this sack's
    tokens.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.acquire_nowait">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.acquire_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Borrow a token from the sack, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if no tokens are available.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the current task already holds one of this sack's
    tokens.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.acquire_on_behalf_of">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire_on_behalf_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrower</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="Link to this definition">¶</a></dt>
<dd><p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, blocking if
necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>borrower</strong> (<span class="sphinx_autodoc_typehints-type">Task | object</span>) -- A <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> or arbitrary opaque object
used to record who is borrowing this token; see
<a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of_nowait" title="trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of_nowait()</span></code></a> for details.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> task already holds one of this sack's
    tokens.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.acquire_on_behalf_of_nowait">
<span class="sig-name descname"><span class="pre">acquire_on_behalf_of_nowait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrower</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.acquire_on_behalf_of_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, without
blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>borrower</strong> (<span class="sphinx_autodoc_typehints-type">Task | object</span>) -- A <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> or arbitrary opaque object
used to record who is borrowing this token. This is used by
<a class="reference internal" href="threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> to allow threads to "hold
tokens", with the intention in the future of using it to <a class="reference external" href="https://github.com/python-trio/trio/issues/182">allow
deadlock detection and other useful things</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if no tokens are available.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> already holds one of this sack's
    tokens.</p></li>
</ul>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="trio.CapacityLimiter.available_tokens">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">available_tokens</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><span class="pre">float</span></a></em><a class="headerlink" href="#trio.CapacityLimiter.available_tokens" title="Link to this definition">¶</a></dt>
<dd><p>The amount of capacity that's available to use.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="trio.CapacityLimiter.borrowed_tokens">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">borrowed_tokens</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a></em><a class="headerlink" href="#trio.CapacityLimiter.borrowed_tokens" title="Link to this definition">¶</a></dt>
<dd><p>The amount of capacity that's currently in use.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.release" title="Link to this definition">¶</a></dt>
<dd><p>Put a token back into the sack.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the current task has not acquired one of this
    sack's tokens.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.release_on_behalf_of">
<span class="sig-name descname"><span class="pre">release_on_behalf_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrower</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.release_on_behalf_of" title="Link to this definition">¶</a></dt>
<dd><p>Put a token back into the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the given borrower has not acquired one of this
    sack's tokens.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.CapacityLimiter.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiter.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.CapacityLimiterStatistics" title="trio.CapacityLimiterStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiterStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>: The number of tokens currently borrowed from
the sack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">total_tokens</span></code>: The total number of tokens in the sack. Usually
this will be larger than <code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>, but it's possibly for
it to be smaller if <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> was recently decreased.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowers</span></code>: A list of all tasks or other entities that currently
hold a token.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>'s <a class="reference internal" href="#trio.CapacityLimiter.acquire" title="trio.CapacityLimiter.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> or
<a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of()</span></code></a> methods.</p></li>
</ul>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="trio.CapacityLimiter.total_tokens">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_tokens</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><span class="pre">float</span></a></em><a class="headerlink" href="#trio.CapacityLimiter.total_tokens" title="Link to this definition">¶</a></dt>
<dd><p>The total capacity available.</p>
<p>You can change <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> by assigning to this attribute. If
you make it larger, then the appropriate number of waiting tasks will
be woken immediately to take the new tokens. If you decrease
total_tokens below the number of tasks that are currently using the
resource, then all current tasks will be allowed to finish as normal,
but no new tasks will be allowed in until the total number of tasks
drops below the new total_tokens.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.Semaphore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Semaphore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.Semaphore" title="Link to this definition">¶</a></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncContextManagerMixin</span></code></p>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">semaphore</a>.</p>
<p>A semaphore holds an integer value, which can be incremented by
calling <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> and decremented by calling <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> – but
the value is never allowed to drop below zero. If the value is zero, then
<a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> will block until someone calls <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a>.</p>
<p>If you're looking for a <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> to limit the number of tasks
that can access some resource simultaneously, then consider using a
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> instead.</p>
<p>This object's interface is similar to, but different from, that of
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Semaphore" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Semaphore</span></code></a>.</p>
<p>A <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> object can be used as an async context manager; it
blocks on entry but not on exit.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- A non-negative integer giving semaphore's initial
value.</p></li>
<li><p><strong>max_value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- If given, makes this a "bounded" semaphore that
raises an error if the value is about to exceed the given
<code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Semaphore.acquire">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Semaphore.acquire" title="Link to this definition">¶</a></dt>
<dd><p>Decrement the semaphore value, blocking if necessary to avoid
letting it drop below zero.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Semaphore.acquire_nowait">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Semaphore.acquire_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to decrement the semaphore value, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if the value is zero.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="trio.Semaphore.max_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_value</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><span class="pre">None</span></a></em><a class="headerlink" href="#trio.Semaphore.max_value" title="Link to this definition">¶</a></dt>
<dd><p>The maximum allowed value. May be None to indicate no limit.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Semaphore.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Semaphore.release" title="Link to this definition">¶</a></dt>
<dd><p>Increment the semaphore value, possibly waking a task blocked in
<a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="（在 Python v3.13）"><strong>ValueError</strong></a> -- if incrementing the value would cause it to exceed
    <a class="reference internal" href="#trio.Semaphore.max_value" title="trio.Semaphore.max_value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_value</span></code></a>.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Semaphore.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Semaphore.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.ParkingLotStatistics" title="trio.lowlevel.ParkingLotStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLotStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this semaphore's
<a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="trio.Semaphore.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a></em><a class="headerlink" href="#trio.Semaphore.value" title="Link to this definition">¶</a></dt>
<dd><p>The current value of the semaphore.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.Lock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Lock</span></span><a class="headerlink" href="#trio.Lock" title="Link to this definition">¶</a></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">_LockImpl</span></code></p>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a>.</p>
<p>This is a non-reentrant, single-owner lock. Unlike
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Lock" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>, only the owner of the lock is allowed to release
it.</p>
<p>A <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> object can be used as an async context manager; it
blocks on entry but not on exit.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Lock.acquire">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Lock.acquire" title="Link to this definition">¶</a></dt>
<dd><p>Acquire the lock, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if the owner of the lock exits without releasing.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Lock.acquire_nowait">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Lock.acquire_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to acquire the lock, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if the lock is held.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Lock.locked">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Lock.locked" title="Link to this definition">¶</a></dt>
<dd><p>Check whether the lock is currently held.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the lock is held, False otherwise.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）">bool</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Lock.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Lock.release" title="Link to this definition">¶</a></dt>
<dd><p>Release the lock.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Lock.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Lock.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.LockStatistics" title="trio.LockStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">LockStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">locked</span></code>: boolean indicating whether the lock is held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: the <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> currently holding the lock,
or None if the lock is not held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lock's
<a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li>
</ul>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.StrictFIFOLock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">StrictFIFOLock</span></span><a class="headerlink" href="#trio.StrictFIFOLock" title="Link to this definition">¶</a></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">_LockImpl</span></code></p>
<p>A variant of <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> where tasks are guaranteed to acquire the
lock in strict first-come-first-served order.</p>
<p>An example of when this is useful is if you're implementing something like
<a class="reference internal" href="../ref-io/abs_api.html#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> or an HTTP/2 server using <a class="reference external" href="https://hyper-h2.readthedocs.io/">h2</a>, where you have multiple concurrent
tasks that are interacting with a shared state machine, and at
unpredictable moments the state machine requests that a chunk of data be
sent over the network. (For example, when using h2 simply reading incoming
data can occasionally <a class="reference external" href="https://http2.github.io/http2-spec/#PING">create outgoing data to send</a>.) The challenge is to make
sure that these chunks are sent in the correct order, without being
garbled.</p>
<p>One option would be to use a regular <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, and wrap it around
every interaction with the state machine:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This approach is sometimes workable but often sub-optimal; see below</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="n">state_machine</span><span class="o">.</span><span class="n">do_something</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">state_machine</span><span class="o">.</span><span class="n">has_data_to_send</span><span class="p">():</span>
        <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">state_machine</span><span class="o">.</span><span class="n">get_data_to_send</span><span class="p">())</span>
</pre></div>
</div>
<p>But this can be problematic. If you're using h2 then <em>usually</em> reading
incoming data doesn't create the need to send any data, so we don't want
to force every task that tries to read from the network to sit and wait
a potentially long time for <code class="docutils literal notranslate"><span class="pre">sendall</span></code> to finish. And in some situations
this could even potentially cause a deadlock, if the remote peer is
waiting for you to read some data before it accepts the data you're
sending.</p>
<p><a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> provides an alternative. We can rewrite our
example like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: no awaits between when we start using the state machine and</span>
<span class="c1"># when we block to take the lock!</span>
<span class="n">state_machine</span><span class="o">.</span><span class="n">do_something</span><span class="p">()</span>
<span class="k">if</span> <span class="n">state_machine</span><span class="o">.</span><span class="n">has_data_to_send</span><span class="p">():</span>
    <span class="c1"># Notice that we fetch the data to send out of the state machine</span>
    <span class="c1"># *before* sleeping, so that other tasks won't see it.</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">state_machine</span><span class="o">.</span><span class="n">get_data_to_send</span><span class="p">()</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">strict_fifo_lock</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>First we do all our interaction with the state machine in a single
scheduling quantum (notice there are no <code class="docutils literal notranslate"><span class="pre">await</span></code>s in there), so it's
automatically atomic with respect to other tasks. And then if and only if
we have data to send, we get in line to send it – and
<a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> guarantees that each task will send its data in
the same order that the state machine generated it.</p>
<p>Currently, <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> is identical to <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>,
but (a) this may not always be true in the future, especially if Trio ever
implements <a class="reference external" href="https://github.com/python-trio/trio/issues/32">more sophisticated scheduling policies</a>, and (b) the above code
is relying on a pretty subtle property of its lock. Using a
<a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> acts as an executable reminder that you're relying
on this property.</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.Condition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition" title="Link to this definition">¶</a></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncContextManagerMixin</span></code></p>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">condition variable</a>, similar to
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Condition" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Condition</span></code></a>.</p>
<p>A <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a> object can be used as an async context manager to
acquire the underlying lock; it blocks on entry but not on exit.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lock</strong> (<a class="reference internal" href="#trio.Lock" title="trio.Lock"><em>Lock</em></a>) -- the lock object to use. If given, must be a
<a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a>. If None, a new <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> will be allocated
and used.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.acquire">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.acquire" title="Link to this definition">¶</a></dt>
<dd><p>Acquire the underlying lock, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if the owner of the underlying lock exits without releasing.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.acquire_nowait">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.acquire_nowait" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to acquire the underlying lock, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if the lock is currently held.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.locked">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.locked" title="Link to this definition">¶</a></dt>
<dd><p>Check whether the underlying lock is currently held.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the lock is held, False otherwise.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）">bool</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.notify">
<span class="sig-name descname"><span class="pre">notify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.notify" title="Link to this definition">¶</a></dt>
<dd><p>Wake one or more tasks that are blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The number of tasks to wake.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.notify_all">
<span class="sig-name descname"><span class="pre">notify_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.notify_all" title="Link to this definition">¶</a></dt>
<dd><p>Wake all tasks that are currently blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.release" title="Link to this definition">¶</a></dt>
<dd><p>Release the underlying lock.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.ConditionStatistics" title="trio.ConditionStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConditionStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this condition's
<a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lock_statistics</span></code>: The result of calling the underlying
<a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>s  <a class="reference internal" href="#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">statistics()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.Condition.wait">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.Condition.wait" title="Link to this definition">¶</a></dt>
<dd><p>Wait for another task to call <a class="reference internal" href="#trio.Condition.notify" title="trio.Condition.notify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify()</span></code></a> or
<a class="reference internal" href="#trio.Condition.notify_all" title="trio.Condition.notify_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify_all()</span></code></a>.</p>
<p>When calling this method, you must hold the lock. It releases the lock
while waiting, and then re-acquires it before waking up.</p>
<p>There is a subtlety with how this method interacts with cancellation:
when cancelled it will block to re-acquire the lock before raising
<a class="reference internal" href="exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This may cause cancellation to be less prompt than
expected. The advantage is that it makes code like this work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">condition</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">condition</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>If we didn't re-acquire the lock before waking up, and <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>
were cancelled here, then we'd crash in <code class="docutils literal notranslate"><span class="pre">condition.__aexit__</span></code> when
we tried to release the lock we no longer held.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p></li>
<li><p><a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if the owner of the lock exits without releasing, when attempting to re-acquire.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>这些原语返回可以被检查的统计对象。</p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.CapacityLimiterStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">CapacityLimiterStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrowed_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">borrowers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.CapacityLimiterStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>: The number of tokens currently borrowed from
the sack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">total_tokens</span></code>: The total number of tokens in the sack. Usually
this will be larger than <code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>, but it's possibly for
it to be smaller if <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">trio.CapacityLimiter.total_tokens</span></code></a> was recently decreased.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowers</span></code>: A list of all tasks or other entities that currently
hold a token.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>'s <a class="reference internal" href="#trio.CapacityLimiter.acquire" title="trio.CapacityLimiter.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.CapacityLimiter.acquire()</span></code></a> or
<a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.CapacityLimiter.acquire_on_behalf_of()</span></code></a> methods.</p></li>
</ul>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.LockStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">LockStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locked</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.LockStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information for a Lock.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">locked</span></code> (boolean): indicating whether the lock is held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: the <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> currently holding the lock,
or None if the lock is not held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code> (int): The number of tasks blocked on this lock's
<a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Lock.acquire()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.ConditionStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">ConditionStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lock_statistics</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.ConditionStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information for a Condition.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code> (int): The number of tasks blocked on this condition's
<a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Condition.wait()</span></code></a> method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lock_statistics</span></code>: The result of calling the underlying
<a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>s  <a class="reference internal" href="#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">statistics()</span></code></a> method.</p></li>
</ul>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--8-input--2" name="tab-set--8" type="radio"/><label class="tab-label" for="tab-set--8-input--2">英文</label><div class="tab-content docutils container">
<p>Personally, I find that events and channels are usually enough to
implement most things I care about, and lead to easier to read code
than the lower-level primitives discussed in this section. But if you
need them, they're here. (If you find yourself reaching for these
because you're trying to implement a new higher-level synchronization
primitive, then you might also want to check out the facilities in
<a class="reference internal" href="../reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> for a more direct exposure of Trio's underlying
synchronization logic. All of classes discussed in this section are
implemented on top of the public APIs in <a class="reference internal" href="../reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>; they
don't have any special access to Trio's internals.)</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">CapacityLimiter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">total_tokens</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncContextManagerMixin</span></code></p>
<p>An object for controlling access to a resource with limited capacity.</p>
<p>Sometimes you need to put a limit on how many tasks can do something at
the same time. For example, you might want to use some threads to run
multiple blocking I/O operations in parallel... but if you use too many
threads at once, then your system can become overloaded and it'll actually
make things slower. One popular solution is to impose a policy like "run
up to 40 threads at the same time, but no more". But how do you implement
a policy like this?</p>
<p>That's what <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is for. You can think of a
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> object as a sack that starts out holding some fixed
number of tokens:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">limit</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">CapacityLimiter</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>Then tasks can come along and borrow a token out of the sack:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Borrow a token:</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">limit</span><span class="p">:</span>
    <span class="c1"># We are holding a token!</span>
    <span class="k">await</span> <span class="n">perform_expensive_operation</span><span class="p">()</span>
<span class="c1"># Exiting the 'async with' block puts the token back into the sack</span>
</pre></div>
</div>
<p>And crucially, if you try to borrow a token but the sack is empty, then
you have to wait for another task to finish what it's doing and put its
token back first before you can take it and continue.</p>
<p>Another way to think of it: a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is like a sofa with a
fixed number of seats, and if they're all taken then you have to wait for
someone to get up before you can sit down.</p>
<p>By default, <a class="reference internal" href="threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> uses a
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> to limit the number of threads running at once;
see <cite>trio.to_thread.current_default_thread_limiter</cite> for details.</p>
<p>If you're familiar with semaphores, then you can think of this as a
restricted semaphore that's specialized for one common use case, with
additional error checking. For a more traditional semaphore, see
<a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Don't confuse this with the <a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket">"leaky bucket"</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket">"token bucket"</a> algorithms used to
limit bandwidth usage on networks. The basic idea of using tokens to
track a resource limit is similar, but this is a very simple sack where
tokens aren't automatically created or destroyed over time; they're
just borrowed and then put back.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Borrow a token from the sack, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the current task already holds one of this sack's
    tokens.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Borrow a token from the sack, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if no tokens are available.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the current task already holds one of this sack's
    tokens.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire_on_behalf_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrower</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, blocking if
necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>borrower</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span>) -- A <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> or arbitrary opaque object
used to record who is borrowing this token; see
<a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of_nowait" title="trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of_nowait()</span></code></a> for details.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> task already holds one of this sack's
    tokens.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">acquire_on_behalf_of_nowait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrower</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, without
blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>borrower</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span>) -- A <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> or arbitrary opaque object
used to record who is borrowing this token. This is used by
<a class="reference internal" href="threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> to allow threads to "hold
tokens", with the intention in the future of using it to <a class="reference external" href="https://github.com/python-trio/trio/issues/182">allow
deadlock detection and other useful things</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if no tokens are available.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> already holds one of this sack's
    tokens.</p></li>
</ul>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">available_tokens</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><span class="pre">float</span></a></em></dt>
<dd><p>The amount of capacity that's available to use.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">borrowed_tokens</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a></em></dt>
<dd><p>The amount of capacity that's currently in use.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Put a token back into the sack.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the current task has not acquired one of this
    sack's tokens.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">release_on_behalf_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrower</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Put a token back into the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the given borrower has not acquired one of this
    sack's tokens.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.CapacityLimiterStatistics" title="trio.CapacityLimiterStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiterStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>: The number of tokens currently borrowed from
the sack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">total_tokens</span></code>: The total number of tokens in the sack. Usually
this will be larger than <code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>, but it's possibly for
it to be smaller if <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> was recently decreased.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowers</span></code>: A list of all tasks or other entities that currently
hold a token.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>'s <a class="reference internal" href="#trio.CapacityLimiter.acquire" title="trio.CapacityLimiter.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> or
<a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of()</span></code></a> methods.</p></li>
</ul>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_tokens</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><span class="pre">float</span></a></em></dt>
<dd><p>The total capacity available.</p>
<p>You can change <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> by assigning to this attribute. If
you make it larger, then the appropriate number of waiting tasks will
be woken immediately to take the new tokens. If you decrease
total_tokens below the number of tasks that are currently using the
resource, then all current tasks will be allowed to finish as normal,
but no new tasks will be allowed in until the total number of tasks
drops below the new total_tokens.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Semaphore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncContextManagerMixin</span></code></p>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">semaphore</a>.</p>
<p>A semaphore holds an integer value, which can be incremented by
calling <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> and decremented by calling <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> – but
the value is never allowed to drop below zero. If the value is zero, then
<a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> will block until someone calls <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a>.</p>
<p>If you're looking for a <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> to limit the number of tasks
that can access some resource simultaneously, then consider using a
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> instead.</p>
<p>This object's interface is similar to, but different from, that of
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Semaphore" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Semaphore</span></code></a>.</p>
<p>A <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> object can be used as an async context manager; it
blocks on entry but not on exit.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- A non-negative integer giving semaphore's initial
value.</p></li>
<li><p><strong>max_value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- If given, makes this a "bounded" semaphore that
raises an error if the value is about to exceed the given
<code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Decrement the semaphore value, blocking if necessary to avoid
letting it drop below zero.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Attempt to decrement the semaphore value, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if the value is zero.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_value</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><span class="pre">None</span></a></em></dt>
<dd><p>The maximum allowed value. May be None to indicate no limit.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Increment the semaphore value, possibly waking a task blocked in
<a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" title="（在 Python v3.13）"><strong>ValueError</strong></a> -- if incrementing the value would cause it to exceed
    <a class="reference internal" href="#trio.Semaphore.max_value" title="trio.Semaphore.max_value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_value</span></code></a>.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.ParkingLotStatistics" title="trio.lowlevel.ParkingLotStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLotStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this semaphore's
<a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><span class="pre">int</span></a></em></dt>
<dd><p>The current value of the semaphore.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Lock</span></span></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">_LockImpl</span></code></p>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a>.</p>
<p>This is a non-reentrant, single-owner lock. Unlike
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Lock" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>, only the owner of the lock is allowed to release
it.</p>
<p>A <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> object can be used as an async context manager; it
blocks on entry but not on exit.</p>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Acquire the lock, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if the owner of the lock exits without releasing.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Attempt to acquire the lock, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if the lock is held.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check whether the lock is currently held.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the lock is held, False otherwise.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）">bool</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Release the lock.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.LockStatistics" title="trio.LockStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">LockStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">locked</span></code>: boolean indicating whether the lock is held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: the <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> currently holding the lock,
or None if the lock is not held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lock's
<a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li>
</ul>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">StrictFIFOLock</span></span></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">_LockImpl</span></code></p>
<p>A variant of <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> where tasks are guaranteed to acquire the
lock in strict first-come-first-served order.</p>
<p>An example of when this is useful is if you're implementing something like
<a class="reference internal" href="../ref-io/abs_api.html#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> or an HTTP/2 server using <a class="reference external" href="https://hyper-h2.readthedocs.io/">h2</a>, where you have multiple concurrent
tasks that are interacting with a shared state machine, and at
unpredictable moments the state machine requests that a chunk of data be
sent over the network. (For example, when using h2 simply reading incoming
data can occasionally <a class="reference external" href="https://http2.github.io/http2-spec/#PING">create outgoing data to send</a>.) The challenge is to make
sure that these chunks are sent in the correct order, without being
garbled.</p>
<p>One option would be to use a regular <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, and wrap it around
every interaction with the state machine:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This approach is sometimes workable but often sub-optimal; see below</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="n">state_machine</span><span class="o">.</span><span class="n">do_something</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">state_machine</span><span class="o">.</span><span class="n">has_data_to_send</span><span class="p">():</span>
        <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">state_machine</span><span class="o">.</span><span class="n">get_data_to_send</span><span class="p">())</span>
</pre></div>
</div>
<p>But this can be problematic. If you're using h2 then <em>usually</em> reading
incoming data doesn't create the need to send any data, so we don't want
to force every task that tries to read from the network to sit and wait
a potentially long time for <code class="docutils literal notranslate"><span class="pre">sendall</span></code> to finish. And in some situations
this could even potentially cause a deadlock, if the remote peer is
waiting for you to read some data before it accepts the data you're
sending.</p>
<p><a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> provides an alternative. We can rewrite our
example like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: no awaits between when we start using the state machine and</span>
<span class="c1"># when we block to take the lock!</span>
<span class="n">state_machine</span><span class="o">.</span><span class="n">do_something</span><span class="p">()</span>
<span class="k">if</span> <span class="n">state_machine</span><span class="o">.</span><span class="n">has_data_to_send</span><span class="p">():</span>
    <span class="c1"># Notice that we fetch the data to send out of the state machine</span>
    <span class="c1"># *before* sleeping, so that other tasks won't see it.</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">state_machine</span><span class="o">.</span><span class="n">get_data_to_send</span><span class="p">()</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">strict_fifo_lock</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>First we do all our interaction with the state machine in a single
scheduling quantum (notice there are no <code class="docutils literal notranslate"><span class="pre">await</span></code>s in there), so it's
automatically atomic with respect to other tasks. And then if and only if
we have data to send, we get in line to send it – and
<a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> guarantees that each task will send its data in
the same order that the state machine generated it.</p>
<p>Currently, <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> is identical to <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>,
but (a) this may not always be true in the future, especially if Trio ever
implements <a class="reference external" href="https://github.com/python-trio/trio/issues/32">more sophisticated scheduling policies</a>, and (b) the above code
is relying on a pretty subtle property of its lock. Using a
<a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> acts as an executable reminder that you're relying
on this property.</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">Condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncContextManagerMixin</span></code></p>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">condition variable</a>, similar to
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Condition" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Condition</span></code></a>.</p>
<p>A <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a> object can be used as an async context manager to
acquire the underlying lock; it blocks on entry but not on exit.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lock</strong> (<a class="reference internal" href="#trio.Lock" title="trio.Lock"><em>Lock</em></a>) -- the lock object to use. If given, must be a
<a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a>. If None, a new <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> will be allocated
and used.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Acquire the underlying lock, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if the owner of the underlying lock exits without releasing.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">acquire_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Attempt to acquire the underlying lock, without blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="exc_warn.html#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> -- if the lock is currently held.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check whether the underlying lock is currently held.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the lock is held, False otherwise.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）">bool</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">notify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wake one or more tasks that are blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The number of tasks to wake.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">notify_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Wake all tasks that are currently blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Release the underlying lock.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.ConditionStatistics" title="trio.ConditionStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConditionStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this condition's
<a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lock_statistics</span></code>: The result of calling the underlying
<a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>s  <a class="reference internal" href="#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">statistics()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Wait for another task to call <a class="reference internal" href="#trio.Condition.notify" title="trio.Condition.notify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify()</span></code></a> or
<a class="reference internal" href="#trio.Condition.notify_all" title="trio.Condition.notify_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify_all()</span></code></a>.</p>
<p>When calling this method, you must hold the lock. It releases the lock
while waiting, and then re-acquires it before waking up.</p>
<p>There is a subtlety with how this method interacts with cancellation:
when cancelled it will block to re-acquire the lock before raising
<a class="reference internal" href="exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This may cause cancellation to be less prompt than
expected. The advantage is that it makes code like this work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">condition</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">condition</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>If we didn't re-acquire the lock before waking up, and <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>
were cancelled here, then we'd crash in <code class="docutils literal notranslate"><span class="pre">condition.__aexit__</span></code> when
we tried to release the lock we no longer held.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- if the calling task does not hold the lock.</p></li>
<li><p><a class="reference internal" href="exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if the owner of the lock exits without releasing, when attempting to re-acquire.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>These primitives return statistics objects that can be inspected.</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">CapacityLimiterStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">borrowed_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">borrowers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>: The number of tokens currently borrowed from
the sack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">total_tokens</span></code>: The total number of tokens in the sack. Usually
this will be larger than <code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>, but it's possibly for
it to be smaller if <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">trio.CapacityLimiter.total_tokens</span></code></a> was recently decreased.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowers</span></code>: A list of all tasks or other entities that currently
hold a token.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this
<a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>'s <a class="reference internal" href="#trio.CapacityLimiter.acquire" title="trio.CapacityLimiter.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.CapacityLimiter.acquire()</span></code></a> or
<a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.CapacityLimiter.acquire_on_behalf_of()</span></code></a> methods.</p></li>
</ul>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">LockStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locked</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information for a Lock.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">locked</span></code> (boolean): indicating whether the lock is held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: the <a class="reference internal" href="../reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> currently holding the lock,
or None if the lock is not held.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code> (int): The number of tasks blocked on this lock's
<a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Lock.acquire()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">ConditionStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lock_statistics</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information for a Condition.</p>
<p>Currently the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code> (int): The number of tasks blocked on this condition's
<a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Condition.wait()</span></code></a> method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lock_statistics</span></code>: The result of calling the underlying
<a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>s  <a class="reference internal" href="#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">statistics()</span></code></a> method.</p></li>
</ul>
</dd></dl>
</div>
</div>
</section>
</section>
</article>
</div>
<footer>
<div class="related-pages">
<a class="next-page" href="note_async_generator.html">
<div class="page-info">
<div class="context">
<span>Next</span>
</div>
<div class="title">异步生成器注意事项</div>
</div>
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
</a>
<a class="prev-page" href="task_local_storeage.html">
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
<div class="page-info">
<div class="context">
<span>Previous</span>
</div>
<div class="title">任务存储</div>
</div>
</a>
</div>
<div class="bottom-of-page">
<div class="left-details">
<div class="copyright">
                Copyright © 2017, Nathaniel J. Smith
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
</div>
<div class="right-details">
<div class="icons">
<a aria-label="GitHub" class="muted-link" href="https://github.com/hellowac/trio-zh-cn">
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 16 16">
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill-rule="evenodd"></path>
</svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<aside class="toc-drawer">
<div class="toc-sticky toc-scroll">
<div class="toc-title-container">
<span class="toc-title">
            On this page
          </span>
</div>
<div class="toc-tree-container">
<div class="toc-tree">
<ul>
<li><a class="reference internal" href="#">任务同步和通信</a><ul>
<li><a class="reference internal" href="#id2">阻塞和非阻塞方法</a></li>
<li><a class="reference internal" href="#id3">公平性</a></li>
<li><a class="reference internal" href="#event">使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code> 广播事件</a><ul>
<li><a class="reference internal" href="#trio.Event"><code class="docutils literal notranslate"><span class="pre">Event</span></code></a><ul>
<li><a class="reference internal" href="#trio.Event.is_set"><code class="docutils literal notranslate"><span class="pre">Event.is_set()</span></code></a></li>
<li><a class="reference internal" href="#trio.Event.set"><code class="docutils literal notranslate"><span class="pre">Event.set()</span></code></a></li>
<li><a class="reference internal" href="#trio.Event.statistics"><code class="docutils literal notranslate"><span class="pre">Event.statistics()</span></code></a></li>
<li><a class="reference internal" href="#trio.Event.wait"><code class="docutils literal notranslate"><span class="pre">Event.wait()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.EventStatistics"><code class="docutils literal notranslate"><span class="pre">EventStatistics</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#channels">使用通道在任务之间传递值</a><ul>
<li><a class="reference internal" href="#trio.open_memory_channel"><code class="docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemorySendChannel"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a><ul>
<li><a class="reference internal" href="#trio.MemorySendChannel.aclose"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel.aclose()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemorySendChannel.clone"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel.clone()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemorySendChannel.close"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel.close()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemorySendChannel.send"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel.send()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemorySendChannel.send_nowait"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel.send_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemorySendChannel.statistics"><code class="docutils literal notranslate"><span class="pre">MemorySendChannel.statistics()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a><ul>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel.aclose"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel.aclose()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel.clone"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel.clone()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel.close"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel.close()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel.receive"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel.receive()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel.receive_nowait"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel.receive_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.MemoryReceiveChannel.statistics"><code class="docutils literal notranslate"><span class="pre">MemoryReceiveChannel.statistics()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.MemoryChannelStatistics"><code class="docutils literal notranslate"><span class="pre">MemoryChannelStatistics</span></code></a></li>
<li><a class="reference internal" href="#id5">一个简单的通道示例</a></li>
<li><a class="reference internal" href="#channel-shutdown">使用通道进行干净关闭</a></li>
<li><a class="reference internal" href="#channel-mpmc">管理多个生产者和/或多个消费者</a></li>
<li><a class="reference internal" href="#channel-buffering">在通道中缓冲</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">较低级别的同步原语</a><ul>
<li><a class="reference internal" href="#trio.CapacityLimiter"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a><ul>
<li><a class="reference internal" href="#trio.CapacityLimiter.acquire"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.acquire()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.acquire_nowait"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.acquire_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.acquire_on_behalf_of()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.acquire_on_behalf_of_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.available_tokens"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.available_tokens</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.borrowed_tokens"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.borrowed_tokens</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.release"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.release()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.release_on_behalf_of"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.release_on_behalf_of()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.statistics"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.statistics()</span></code></a></li>
<li><a class="reference internal" href="#trio.CapacityLimiter.total_tokens"><code class="docutils literal notranslate"><span class="pre">CapacityLimiter.total_tokens</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.Semaphore"><code class="docutils literal notranslate"><span class="pre">Semaphore</span></code></a><ul>
<li><a class="reference internal" href="#trio.Semaphore.acquire"><code class="docutils literal notranslate"><span class="pre">Semaphore.acquire()</span></code></a></li>
<li><a class="reference internal" href="#trio.Semaphore.acquire_nowait"><code class="docutils literal notranslate"><span class="pre">Semaphore.acquire_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.Semaphore.max_value"><code class="docutils literal notranslate"><span class="pre">Semaphore.max_value</span></code></a></li>
<li><a class="reference internal" href="#trio.Semaphore.release"><code class="docutils literal notranslate"><span class="pre">Semaphore.release()</span></code></a></li>
<li><a class="reference internal" href="#trio.Semaphore.statistics"><code class="docutils literal notranslate"><span class="pre">Semaphore.statistics()</span></code></a></li>
<li><a class="reference internal" href="#trio.Semaphore.value"><code class="docutils literal notranslate"><span class="pre">Semaphore.value</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.Lock"><code class="docutils literal notranslate"><span class="pre">Lock</span></code></a><ul>
<li><a class="reference internal" href="#trio.Lock.acquire"><code class="docutils literal notranslate"><span class="pre">Lock.acquire()</span></code></a></li>
<li><a class="reference internal" href="#trio.Lock.acquire_nowait"><code class="docutils literal notranslate"><span class="pre">Lock.acquire_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.Lock.locked"><code class="docutils literal notranslate"><span class="pre">Lock.locked()</span></code></a></li>
<li><a class="reference internal" href="#trio.Lock.release"><code class="docutils literal notranslate"><span class="pre">Lock.release()</span></code></a></li>
<li><a class="reference internal" href="#trio.Lock.statistics"><code class="docutils literal notranslate"><span class="pre">Lock.statistics()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.StrictFIFOLock"><code class="docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition"><code class="docutils literal notranslate"><span class="pre">Condition</span></code></a><ul>
<li><a class="reference internal" href="#trio.Condition.acquire"><code class="docutils literal notranslate"><span class="pre">Condition.acquire()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.acquire_nowait"><code class="docutils literal notranslate"><span class="pre">Condition.acquire_nowait()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.locked"><code class="docutils literal notranslate"><span class="pre">Condition.locked()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.notify"><code class="docutils literal notranslate"><span class="pre">Condition.notify()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.notify_all"><code class="docutils literal notranslate"><span class="pre">Condition.notify_all()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.release"><code class="docutils literal notranslate"><span class="pre">Condition.release()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.statistics"><code class="docutils literal notranslate"><span class="pre">Condition.statistics()</span></code></a></li>
<li><a class="reference internal" href="#trio.Condition.wait"><code class="docutils literal notranslate"><span class="pre">Condition.wait()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.CapacityLimiterStatistics"><code class="docutils literal notranslate"><span class="pre">CapacityLimiterStatistics</span></code></a></li>
<li><a class="reference internal" href="#trio.LockStatistics"><code class="docutils literal notranslate"><span class="pre">LockStatistics</span></code></a></li>
<li><a class="reference internal" href="#trio.ConditionStatistics"><code class="docutils literal notranslate"><span class="pre">ConditionStatistics</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</aside>
</div>
</div><script src="../_static/documentation_options.js?v=d2451d57"></script>
<script src="../_static/doctools.js?v=9bcbadda"></script>
<script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
<script src="../_static/scripts/furo.js?v=5fa4622c"></script>
<script src="../_static/tabs.js?v=3ee01567"></script>
<script src="../_static/clipboard.min.js?v=a7894cd8"></script>
<script src="../_static/copybutton.js?v=f281be69"></script>
<script src="../_static/translations.js?v=beaddf03"></script>
</body>
</html>