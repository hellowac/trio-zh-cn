<!DOCTYPE html>

<html class="no-js" data-content_root="../" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="light dark" name="color-scheme"/><meta content="width=device-width, initial-scale=1" name="viewport">
<link href="../genindex.html" rel="index" title="索引"/><link href="../search.html" rel="search" title="搜索"/><link href="low_level.html" rel="next" title="使用 trio.socket 进行低级网络编程"/><link href="index.html" rel="prev" title="Trio 中的 I/O"/>
<link href="../_static/favicon-32.png" rel="shortcut icon"/><!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
<title>抽象流 API - Trio 0.27.0+dev 文档</title>
<link href="../_static/pygments.css?v=fa44fd50" rel="stylesheet" type="text/css"/>
<link href="../_static/styles/furo.css?v=354aac6f" rel="stylesheet" type="text/css"/>
<link href="../_static/sphinx-codeautolink.css?v=125d5c1c" rel="stylesheet" type="text/css"/>
<link href="../_static/tabs.css?v=4c969af8" rel="stylesheet" type="text/css"/>
<link href="../_static/copybutton.css?v=76b2166b" rel="stylesheet" type="text/css"/>
<link href="../_static/hackrtd.css?v=2d9fc201" rel="stylesheet" type="text/css"/>
<link href="../_static/styles/furo-extensions.css?v=302659d7" rel="stylesheet" type="text/css"/>
<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></meta></head>
<body>
<script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<symbol id="svg-toc" viewbox="0 0 24 24">
<title>Contents</title>
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 1024 1024">
<path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"></path>
</svg>
</symbol>
<symbol id="svg-menu" viewbox="0 0 24 24">
<title>Menu</title>
<svg class="feather-menu" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<line x1="3" x2="21" y1="12" y2="12"></line>
<line x1="3" x2="21" y1="6" y2="6"></line>
<line x1="3" x2="21" y1="18" y2="18"></line>
</svg>
</symbol>
<symbol id="svg-arrow-right" viewbox="0 0 24 24">
<title>Expand</title>
<svg class="feather-chevron-right" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<polyline points="9 18 15 12 9 6"></polyline>
</svg>
</symbol>
<symbol id="svg-sun" viewbox="0 0 24 24">
<title>Light mode</title>
<svg class="feather-sun" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="5"></circle>
<line x1="12" x2="12" y1="1" y2="3"></line>
<line x1="12" x2="12" y1="21" y2="23"></line>
<line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line>
<line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line>
<line x1="1" x2="3" y1="12" y2="12"></line>
<line x1="21" x2="23" y1="12" y2="12"></line>
<line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line>
<line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>
</svg>
</symbol>
<symbol id="svg-moon" viewbox="0 0 24 24">
<title>Dark mode</title>
<svg class="icon-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
</svg>
</symbol>
<symbol id="svg-sun-with-moon" viewbox="0 0 24 24">
<title>Auto light/dark, in light mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z" style="opacity: 50%"></path>
<line x1="14.5" x2="14.5" y1="3.25" y2="1.25"></line>
<line x1="14.5" x2="14.5" y1="15.85" y2="17.85"></line>
<line x1="10.044" x2="8.63" y1="5.094" y2="3.68"></line>
<line x1="19" x2="20.414" y1="14.05" y2="15.464"></line>
<line x1="8.2" x2="6.2" y1="9.55" y2="9.55"></line>
<line x1="20.8" x2="22.8" y1="9.55" y2="9.55"></line>
<line x1="10.044" x2="8.63" y1="14.006" y2="15.42"></line>
<line x1="19" x2="20.414" y1="5.05" y2="3.636"></line>
<circle cx="14.5" cy="9.55" r="3.6"></circle>
</svg>
</symbol>
<symbol id="svg-moon-with-sun" viewbox="0 0 24 24">
<title>Auto light/dark, in dark mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"></path>
<line style="opacity: 50%" x1="18" x2="18" y1="3.705" y2="2.5"></line>
<line style="opacity: 50%" x1="18" x2="18" y1="11.295" y2="12.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="4.816" y2="3.964"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="10.212" y2="11.063"></line>
<line style="opacity: 50%" x1="14.205" x2="13.001" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="21.795" x2="23" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="10.184" y2="11.036"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="4.789" y2="3.937"></line>
<circle cx="18" cy="7.5" r="2.169" style="opacity: 50%"></circle>
</svg>
</symbol>
<symbol id="svg-pencil" viewbox="0 0 24 24">
<svg class="icon-tabler-pencil-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4"></path>
<path d="M13.5 6.5l4 4"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
<symbol id="svg-eye" viewbox="0 0 24 24">
<svg class="icon-tabler-eye-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0"></path>
<path d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
</svg>
<input class="sidebar-toggle" id="__navigation" name="__navigation" type="checkbox"/>
<input class="sidebar-toggle" id="__toc" name="__toc" type="checkbox"/>
<label class="overlay sidebar-overlay" for="__navigation">
<div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
<div class="visually-hidden">Hide table of contents sidebar</div>
</label>
<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>
<div class="page">
<header class="mobile-header">
<div class="header-left">
<label class="nav-overlay-icon" for="__navigation">
<div class="visually-hidden">Toggle site navigation sidebar</div>
<i class="icon"><svg><use href="#svg-menu"></use></svg></i>
</label>
</div>
<div class="header-center">
<a href="../index.html"><div class="brand">Trio 0.27.0+dev 文档</div></a>
</div>
<div class="header-right">
<div class="theme-toggle-container theme-toggle-header">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-header-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
</header>
<aside class="sidebar-drawer">
<div class="sidebar-container">
<div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
<div class="sidebar-logo-container">
<img alt="Logo" class="sidebar-logo" src="../_static/wordmark-transparent.svg"/>
</div>
<span class="sidebar-brand-text">Trio 0.27.0+dev 文档</span>
</a><form action="../search.html" class="sidebar-search-container" method="get" role="search">
<input aria-label="搜索" class="sidebar-search" name="q" placeholder="搜索"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
<p class="caption" role="heading"><span class="caption-text">Trio 友好且全面的手册：</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../awesome-trio-libraries.html">超棒的 Trio 库</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ref-core/index.html">Trio 的核心功能</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Trio 的核心功能</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/run.html">运行 Trio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/general_principles.html">一般原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/time_clock.html">时间和时钟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/cancel_timeout.html">取消和超时</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/tasks.html">任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/task_local_storeage.html">任务存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/task_sync.html">任务同步和通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/note_async_generator.html">异步生成器注意事项</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/threads.html">线程（如果必须）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/debugging.html">交互式调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ref-core/exc_warn.html">异常和警告</a></li>
</ul>
</input></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Trio 中的 I/O</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Trio 中的 I/O</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">抽象流 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="low_level.html">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code> 进行低级网络编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="async_file_io.html">异步文件系统 I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="subprocess.html">生成子进程</a></li>
<li class="toctree-l2"><a class="reference internal" href="signals.html">信号</a></li>
</ul>
</input></li>
<li class="toctree-l1"><a class="reference internal" href="../reference-testing.html">Trio 中的测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference-lowlevel.html">自省和扩展 Trio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design.html">设计和内部结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">发布历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">为 Trio 及相关项目做出贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releasing.html">准备发布</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-of-conduct.html">行为守则</a></li>
</ul>
</div>
</div>
</div>
</div>
</aside>
<div class="main">
<div class="content">
<div class="article-container">
<a class="back-to-top muted-link" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
</svg>
<span>Back to top</span>
</a>
<div class="content-icon-container">
<div class="view-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/blob/sync-docs/cn_docs/source/ref-io/abs_api.rst?plain=true" title="View this page">
<svg><use href="#svg-eye"></use></svg>
<span class="visually-hidden">View this page</span>
</a>
</div><div class="edit-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/edit/sync-docs/cn_docs/source/ref-io/abs_api.rst" title="Edit this page">
<svg><use href="#svg-pencil"></use></svg>
<span class="visually-hidden">Edit this page</span>
</a>
</div><div class="theme-toggle-container theme-toggle-content">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-content-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
<article id="furo-main-content" role="main">
<section id="api">
<span id="abstract-stream-api"></span><h1>抽象流 API<a class="headerlink" href="#api" title="Link to this heading">¶</a></h1>
<p><strong>The abstract Stream API</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 提供了一组抽象基类, 用于定义单向和双向字节流的标准接口。</p>
<p>为什么这很有用？因为它允许你编写通用的协议实现, 这些实现可以在任意传输层上工作, 并且能够轻松创建复杂的传输配置。以下是一些示例：</p>
<ul>
<li><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SocketStream</span></code></a> 封装一个原始套接字 (比如通过网络的 TCP 连接 ) , 并将其转换为标准的流接口。</p></li>
<li><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> 是一个“流适配器”, 可以将任何实现了 <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a> 接口的对象转换为加密流。在 Trio 中, 通过在 <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> 周围包装一个 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>, 是实现网络 SSL 通信的标准方式。</p></li>
<li><p>如果你启动一个 <a class="reference internal" href="subprocess.html#subprocess"><span class="std std-ref">子进程</span></a>, 你可以获得一个 <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, 它允许你写入子进程的 stdin, 以及一个 <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>, 它允许你从子进程的 stdout 中读取。如果你出于某种原因想要通过 SSL 与子进程通信, 可以使用 <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> 将子进程的 stdin/stdout 合并成一个双向的 <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, 然后将其包装在一个 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> 中：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ssl_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
<span class="n">ssl_context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">SSLStream</span><span class="p">(</span><span class="n">StapledStream</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">process</span><span class="o">.</span><span class="n">stdout</span><span class="p">),</span> <span class="n">ssl_context</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>有时你需要连接到一个 HTTPS 服务器, 但必须通过一个 Web 代理, 而代理本身也使用 HTTPS。这时, 你就需要进行 <a class="reference external" href="https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/">SSL-on-top-of-SSL</a>。在 Trio 中, 这非常简单——只需将第一个 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> 再次包装在第二个 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> 中：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 获取到代理的原始 SocketStream 连接：</span>
<span class="n">s0</span> <span class="o">=</span> <span class="k">await</span> <span class="n">open_tcp_stream</span><span class="p">(</span><span class="s2">"proxy"</span><span class="p">,</span> <span class="mi">443</span><span class="p">)</span>

<span class="c1"># 设置与代理的 SSL 连接：</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">SSLStream</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">proxy_ssl_context</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s2">"proxy"</span><span class="p">)</span>
<span class="c1"># 请求连接到网站</span>
<span class="k">await</span> <span class="n">s1</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"CONNECT website:443 / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
<span class="k">await</span> <span class="n">check_CONNECT_response</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

<span class="c1"># 设置与真实网站的 SSL 连接。注意, s1 已经是一个 SSLStream 对象,</span>
<span class="c1"># 这里我们将第二个 SSLStream 对象包装在它周围。</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">SSLStream</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">website_ssl_context</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s2">"website"</span><span class="p">)</span>
<span class="c1"># 发出请求</span>
<span class="k">await</span> <span class="n">s2</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"GET /index.html HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="../reference-testing.html#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> 模块提供了一组 <a class="reference internal" href="../reference-testing.html#testing-streams"><span class="std std-ref">灵活的内存流对象实现</span></a>, 因此如果你有一个协议实现需要测试, 你可以启动两个任务, 设置一个虚拟的“套接字”连接它们, 然后进行诸如在连接中注入随机但可重复的延迟之类的操作。</p></li>
</ul>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p>Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams.</p>
<p>Why is this useful? Because it lets you write generic protocol implementations that can work over arbitrary transports, and easily create complex transport configurations. Here's some examples:</p>
<ul>
<li><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SocketStream</span></code></a> wraps a raw socket (like a TCP connection over the network), and converts it to the standard stream interface.</p></li>
<li><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> is a "stream adapter" that can take any object that implements the <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a> interface, and convert it into an encrypted stream. In Trio the standard way to speak SSL over the network is to wrap an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> around a <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>.</p></li>
<li><p>If you spawn a <a class="reference internal" href="subprocess.html#subprocess"><span class="std std-ref">subprocess</span></a>, you can get a <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> that lets you write to its stdin, and a <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> to combine its stdin/stdout into a single bidirectional <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and then wrap that in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ssl_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
<span class="n">ssl_context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">SSLStream</span><span class="p">(</span><span class="n">StapledStream</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">process</span><span class="o">.</span><span class="n">stdout</span><span class="p">),</span> <span class="n">ssl_context</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>It sometimes happens that you want to connect to an HTTPS server, but you have to go through a web proxy... and the proxy also uses HTTPS. So you end up having to do <a class="reference external" href="https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/">SSL-on-top-of-SSL</a>. In Trio this is trivial – just wrap your first <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in a second <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get a raw SocketStream connection to the proxy:</span>
<span class="n">s0</span> <span class="o">=</span> <span class="k">await</span> <span class="n">open_tcp_stream</span><span class="p">(</span><span class="s2">"proxy"</span><span class="p">,</span> <span class="mi">443</span><span class="p">)</span>

<span class="c1"># Set up SSL connection to proxy:</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">SSLStream</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">proxy_ssl_context</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s2">"proxy"</span><span class="p">)</span>
<span class="c1"># Request a connection to the website</span>
<span class="k">await</span> <span class="n">s1</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"CONNECT website:443 / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
<span class="k">await</span> <span class="n">check_CONNECT_response</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

<span class="c1"># Set up SSL connection to the real website. Notice that s1 is</span>
<span class="c1"># already an SSLStream object, and here we're wrapping a second</span>
<span class="c1"># SSLStream object around it.</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">SSLStream</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">website_ssl_context</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s2">"website"</span><span class="p">)</span>
<span class="c1"># Make our request</span>
<span class="k">await</span> <span class="n">s2</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"GET /index.html HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>The <a class="reference internal" href="../reference-testing.html#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> module provides a set of <a class="reference internal" href="../reference-testing.html#testing-streams"><span class="std std-ref">flexible in-memory stream object implementations</span></a>, so if you have a protocol implementation to test then you can start two tasks, set up a virtual "socket" connecting them, and then do things like inject random-but-repeatable delays into the connection.</p></li>
</ul>
</div>
</div>
<section id="id1">
<h2>抽象基类<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p><strong>Abstract base classes</strong></p>
<div class="table-wrapper colwidths-auto docutils container" id="id22">
<table class="docutils align-default" id="id22">
<caption><span class="caption-text">Overview: abstract base classes for I/O</span><a class="headerlink" href="#id22" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Abstract base class</p></th>
<th class="head"><p>Inherits from...</p></th>
<th class="head"><p>Adds these abstract methods...</p></th>
<th class="head"><p>And these concrete methods.</p></th>
<th class="head"><p>Example implementations</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td>
<td></td>
<td><p><a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__aenter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code></p></td>
<td><p><a class="reference internal" href="async_file_io.html#async-file-objects"><span class="std std-ref">异步文件对象</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>,
<a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a></p></td>
<td></td>
<td><p><a class="reference internal" href="../reference-testing.html#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td>
<td><p><a class="reference internal" href="../reference-testing.html#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p></td>
<td></td>
<td></td>
<td><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a></p></td>
<td></td>
<td><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>, <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></td>
<td></td>
<td><p><a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a>, <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a></p></td>
<td></td>
<td><p><a class="reference internal" href="../ref-core/task_sync.html#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td>
<td><p><a class="reference internal" href="../ref-core/task_sync.html#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Channel</span></code></a></p></td>
<td><p><a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a></p></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.AsyncResource">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">AsyncResource</span></span><a class="headerlink" href="#trio.abc.AsyncResource" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/abc.html#abc.ABC" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></a></p>
<p>A standard interface for resources that needs to be cleaned up, and
where that cleanup may require blocking operations.</p>
<p>This class distinguishes between "graceful" closes, which may perform I/O
and thus block, and a "forceful" close, which cannot. For example, cleanly
shutting down a TLS-encrypted connection requires sending a "goodbye"
message; but if a peer has become non-responsive, then sending this
message might block forever, so we may want to just drop the connection
instead. Therefore the <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method is unusual in that it
should always close the connection (or at least make its best attempt)
<em>even if it fails</em>; failure indicates a failure to achieve grace, not a
failure to close the connection.</p>
<p>Objects that implement this interface can be used as async context
managers, i.e., you can write:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">create_resource</span><span class="p">()</span> <span class="k">as</span> <span class="n">some_async_resource</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Entering the context manager is synchronous (not a checkpoint); exiting it
calls <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. The default implementations of
<code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> and <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> should be adequate for all subclasses.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.AsyncResource.aclose">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.AsyncResource.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Close this resource, possibly blocking.</p>
<p>IMPORTANT: This method may block in order to perform a "graceful"
shutdown. But, if this fails, then it still <em>must</em> close any
underlying resources before returning. An error from this method
indicates a failure to achieve grace, <em>not</em> a failure to close the
connection.</p>
<p>For example, suppose we call <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> on a TLS-encrypted
connection. This requires sending a "goodbye" message; but if the peer
has become non-responsive, then our attempt to send this message might
block forever, and eventually time out and be cancelled. In this case
the <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method on <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will
immediately close the underlying transport stream using
<a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a> before raising <a class="reference internal" href="../ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p>
<p>If the resource is already closed, then this method should silently
succeed.</p>
<p>Once this method completes, any other pending or future operations on
this resource should generally raise <a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>,
unless there's a good reason to do otherwise.</p>
<p>See also: <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.aclose_forcefully">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">aclose_forcefully</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resource</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.aclose_forcefully" title="Link to this definition">¶</a></dt>
<dd><p>Close an async resource or async generator immediately, without
blocking to do any graceful cleanup.</p>
<p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> objects guarantee that if their
<a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method is cancelled, then they will
still close the resource (albeit in a potentially ungraceful
fashion). <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">aclose_forcefully()</span></code></a> is a convenience function that
exploits this behavior to let you force a resource to be closed without
blocking: it works by calling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">resource.aclose()</span></code> and then
cancelling it immediately.</p>
<p>Most users won't need this, but it may be useful on cleanup paths where
you can't afford to block, or if you want to close a resource and don't
care about handling it gracefully. For example, if
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> encounters an error and cannot perform its
own graceful close, then there's no point in waiting to gracefully shut
down the underlying transport either, so it calls <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">aclose_forcefully(self.transport_stream)</span></code>.</p>
<p>Note that this function is async, and that it acts as a checkpoint, but
unlike most async functions it cannot block indefinitely (at least,
assuming the underlying resource object is correctly implemented).</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.SendStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">SendStream</span></span><a class="headerlink" href="#trio.abc.SendStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p>
<p>A standard interface for sending data on a byte stream.</p>
<p>The underlying stream may be unidirectional, or bidirectional. If it's
bidirectional, then you probably want to also implement
<a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>, which makes your object a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>.</p>
<p><a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>
interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>
or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p>
<p>If you want to send Python objects rather than raw bytes, see
<a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.SendStream.send_all">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.SendStream.send_all" title="Link to this definition">¶</a></dt>
<dd><p>Sends the given data through the stream, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="（在 Python v3.13）"><em>bytearray</em></a><em>, or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" title="（在 Python v3.13）"><em>memoryview</em></a>) -- The data to send.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- if another task is already executing a
    <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or
    <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a> on this stream.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if something has gone wrong, and the stream
    is broken.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this stream
    object, or if another task closes this stream object while
    <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> is running.</p></li>
</ul>
</dd>
</dl>
<p>Most low-level operations in Trio provide a guarantee: if they raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>, this means that they had no effect, so the
system remains in a known state. This is <strong>not true</strong> for
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>
<a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>. If this operation raises <a class="reference internal" href="../ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a> (or
any other exception for that matter), then it may have sent some, all,
or none of the requested data, and there is no way to know which.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.SendStream.wait_send_all_might_not_block">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="Link to this definition">¶</a></dt>
<dd><p>Block until it's possible that <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> might not block.</p>
<p>This method may return early: it's possible that after it returns,
<a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> will still block. (In the worst case, if no better
implementation is available, then it might always return immediately
without blocking. It's nice to do better than that when possible,
though.)</p>
<p>This method <strong>must not</strong> return <em>late</em>: if it's possible for
<a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> to complete without blocking, then it must
return. When implementing it, err on the side of returning early.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- if another task is already executing a
    <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or
    <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a> on this stream.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if something has gone wrong, and the stream
    is broken.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this stream
    object, or if another task closes this stream object while
    <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> is running.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>This method is intended to aid in implementing protocols that want
to delay choosing which data to send until the last moment. E.g.,</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<p>suppose you're working on an implementation of a remote display server
like <a class="reference external" href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a>, and
the network connection is currently backed up so that if you call
<a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> now then it will sit for 0.5 seconds before actually
sending anything. In this case it doesn't make sense to take a
screenshot, then wait 0.5 seconds, and then send it, because the
screen will keep changing while you wait; it's better to wait 0.5
seconds, then take the screenshot, and then send it, because this
way the data you deliver will be more
up-to-date. Using <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> makes it
possible to implement the better strategy.</p>
<p>If you use this method, you might also want to read up on
<code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code>.</p>
<p>Further reading:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://insouciant.org/tech/prioritization-only-works-when-theres-pending-data-to-prioritize/">Prioritization Only Works When There's Pending Data to Prioritize</a></p></li>
<li><p>WWDC 2015: Your App and Next Generation Networks: <a class="reference external" href="http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1">slides</a>,
<a class="reference external" href="https://developer.apple.com/videos/play/wwdc2015/719/">video and transcript</a></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.ReceiveStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">ReceiveStream</span></span><a class="headerlink" href="#trio.abc.ReceiveStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p>
<p>A standard interface for receiving data on a byte stream.</p>
<p>The underlying stream may be unidirectional, or bidirectional. If it's
bidirectional, then you probably want to also implement
<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, which makes your object a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>.</p>
<p><a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>
interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>
or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p>
<p>If you want to receive Python objects rather than raw bytes, see
<a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>.</p>
<p><cite>ReceiveStream</cite> objects can be used in <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loops. Each iteration
will produce an arbitrary sized chunk of bytes, like calling
<cite>receive_some</cite> with no arguments. Every chunk will contain at least one
byte, and the loop automatically exits when reaching end-of-file.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.ReceiveStream.receive_some">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.ReceiveStream.receive_some" title="Link to this definition">¶</a></dt>
<dd><p>Wait until there is data available on this stream, and then return
some of it.</p>
<p>A return value of <code class="docutils literal notranslate"><span class="pre">b""</span></code> (an empty bytestring) indicates that the
stream has reached end-of-file. Implementations should be careful that
they return <code class="docutils literal notranslate"><span class="pre">b""</span></code> if, and only if, the stream has reached
end-of-file!</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>max_bytes</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The maximum number of bytes to return. Must be
greater than zero. Optional; if omitted, then the stream object
is free to pick a reasonable default.</p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>The data received.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）">bytes</a> or <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="（在 Python v3.13）">bytearray</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- if two tasks attempt to call
    <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> on the same stream at the same time.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if something has gone wrong, and the stream
    is broken.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this stream
    object, or if another task closes this stream object while
    <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> is running.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.Stream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">Stream</span></span><a class="headerlink" href="#trio.abc.Stream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p>
<p>A standard interface for interacting with bidirectional byte streams.</p>
<p>A <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> is an object that implements both the
<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> and <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> interfaces.</p>
<p>If implementing this interface, you should consider whether you can go one
step further and implement <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>.</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.HalfCloseableStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">HalfCloseableStream</span></span><a class="headerlink" href="#trio.abc.HalfCloseableStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p>
<p>This interface extends <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> to also allow closing the send
part of the stream without closing the receive part.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.HalfCloseableStream.send_eof">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_eof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.HalfCloseableStream.send_eof" title="Link to this definition">¶</a></dt>
<dd><p>Send an end-of-file indication on this stream, if possible.</p>
<p>The difference between <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> and
<a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> is that <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> is a
<em>unidirectional</em> end-of-file indication. After you call this method,
you shouldn't try sending any more data on this stream, and your
remote peer should receive an end-of-file indication (eventually,
after receiving all the data you sent before that). But, they may
continue to send data to you, and you can continue to receive it by
calling <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>. You can think of it as
calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> on just the
<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> "half" of the stream object (and in fact that's
literally how <a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a> implements it).</p>
<p>Examples:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<ul class="simple">
<li><p>On a socket, this corresponds to <code class="docutils literal notranslate"><span class="pre">shutdown(...,</span> <span class="pre">SHUT_WR)</span></code> (<a class="reference external" href="https://linux.die.net/man/2/shutdown">man
page</a>).</p></li>
<li><p>The SSH protocol provides the ability to multiplex bidirectional
"channels" on top of a single encrypted connection. A Trio
implementation of SSH could expose these channels as
<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> objects, and calling <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a>
would send an <code class="docutils literal notranslate"><span class="pre">SSH_MSG_CHANNEL_EOF</span></code> request (see <a class="reference external" href="https://tools.ietf.org/html/rfc4254#section-5.3">RFC 4254 §5.3</a>).</p></li>
<li><p>On an SSL/TLS-encrypted connection, the protocol doesn't provide any
way to do a unidirectional shutdown without closing the connection
entirely, so <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> implements
<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, not <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>.</p></li>
</ul>
<p>If an EOF has already been sent, then this method should silently
succeed.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- if another task is already executing a
    <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>,
    <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or
    <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> on this stream.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if something has gone wrong, and the stream
    is broken.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this stream
    object, or if another task closes this stream object while
    <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> is running.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.Listener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">Listener</span></span><a class="headerlink" href="#trio.abc.Listener" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_resource</span></code></a>]</p>
<p>A standard interface for listening for incoming connections.</p>
<p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects also implement the <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>
interface, so they can be closed by calling <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>
or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Listener.accept">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Listener.accept" title="Link to this definition">¶</a></dt>
<dd><p>Wait until an incoming connection arrives, and then return it.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>An object representing the incoming connection. In
practice this is generally some kind of <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>,
but in principle you could also define a <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that
returned, say, channel objects.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource">AsyncResource</a></p>
</dd>
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- if two tasks attempt to call
    <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> on the same listener at the same time.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this listener
    object, or if another task closes this listener object while
    <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> is running.</p></li>
</ul>
</dd>
</dl>
<p>Listeners don't generally raise <a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>,
because for listeners there is no general condition of "the
network/remote peer broke the connection" that can be handled in a
generic way, like there is for streams. Other errors <em>can</em> occur and
be raised from <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> – for example, if you run out of file
descriptors then you might get an <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> with its errno set
to <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.SendChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">SendChannel</span></span><a class="headerlink" href="#trio.abc.SendChannel" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendType</span></code></a>]</p>
<p>A standard interface for sending Python objects to some receiver.</p>
<p><cite>SendChannel</cite> objects also implement the <cite>AsyncResource</cite> interface, so
they can be closed by calling <cite>~AsyncResource.aclose</cite> or using an <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block.</p>
<p>If you want to send raw bytes rather than Python objects, see
<cite>SendStream</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.SendChannel.send">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.SendChannel.send" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to send an object through the channel, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><em>object</em></a>) -- The object to send.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if something has gone wrong, and the
    channel is broken. For example, you may get this if the receiver
    has already been closed.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this
    <a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a> object, or if another task closes it while
    <a class="reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> is running.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- some channels allow multiple tasks to call
    <cite>send</cite> at the same time, but others don't. If you try to call
    <cite>send</cite> simultaneously from multiple tasks on a channel that
    doesn't support it, then you can get <cite>~trio.BusyResourceError</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.ReceiveChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">ReceiveChannel</span></span><a class="headerlink" href="#trio.abc.ReceiveChannel" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveType</span></code></a>]</p>
<p>A standard interface for receiving Python objects from some sender.</p>
<p>You can iterate over a <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>
loop:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">receive_channel</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This is equivalent to calling <a class="reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a> repeatedly. The loop exits
without error when <cite>receive</cite> raises <cite>~trio.EndOfChannel</cite>.</p>
<p><cite>ReceiveChannel</cite> objects also implement the <cite>AsyncResource</cite> interface, so
they can be closed by calling <cite>~AsyncResource.aclose</cite> or using an <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block.</p>
<p>If you want to receive raw bytes rather than Python objects, see
<cite>ReceiveStream</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.ReceiveChannel.receive">
<em class="property"><span class="pre">abstractmethod</span> <span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.ReceiveChannel.receive" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to receive an incoming object, blocking if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whatever object was received.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）">object</a></p>
</dd>
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.EndOfChannel" title="trio.EndOfChannel"><strong>trio.EndOfChannel</strong></a> -- if the sender has been closed cleanly, and no
    more objects are coming. This is not an error condition.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- if you previously closed this
    <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> object.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if something has gone wrong, and the
    channel is broken.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- some channels allow multiple tasks to call
    <cite>receive</cite> at the same time, but others don't. If you try to call
    <cite>receive</cite> simultaneously from multiple tasks on a channel that
    doesn't support it, then you can get <cite>~trio.BusyResourceError</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.Channel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">Channel</span></span><a class="headerlink" href="#trio.abc.Channel" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a>], <a class="reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a>]</p>
<p>A standard interface for interacting with bidirectional channels.</p>
<p>A <cite>Channel</cite> is an object that implements both the <cite>SendChannel</cite> and
<cite>ReceiveChannel</cite> interfaces, so you can both send and receive objects.</p>
</dd></dl>
</section>
<section id="id2">
<h2>通用流工具<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p><strong>Generic stream tools</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 目前提供了一个通用的助手, 用于编写监听连接的服务器, 使用一个或多个 <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>s, 并且提供了一个通用的工具类, 用于处理流。如果你想测试针对流接口编写的代码, 应该查看 <a class="reference internal" href="../reference-testing.html#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> 中的 <a class="reference internal" href="../reference-testing.html#testing-streams"><span class="std std-ref">流</span></a>。</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.serve_listeners">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">serve_listeners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listeners</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler_nursery</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.serve_listeners" title="Link to this definition">¶</a></dt>
<dd><p>Listen for incoming connections on <code class="docutils literal notranslate"><span class="pre">listeners</span></code>, and for each one
start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn't do
anything special to catch it – so by default the exception will
propagate out and crash your server. If you don't want this, then catch
exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object
that responds to exceptions in some other way.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handler</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">StreamT</span></code>, bound= <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>)], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Awaitable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Awaitable</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>]]</span>) -- An async callable, that will be invoked like
<code class="docutils literal notranslate"><span class="pre">handler_nursery.start_soon(handler,</span> <span class="pre">stream)</span></code> for each incoming
connection.</p></li>
<li><p><strong>listeners</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ListenerT</span></code>, bound= <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>])]</span>) -- A list of <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects.
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> takes responsibility for closing them.</p></li>
<li><p><strong>handler_nursery</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../ref-core/tasks.html#trio.Nursery" title="trio.Nursery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nursery</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>) -- The nursery used to start handlers, or any object with
a <code class="docutils literal notranslate"><span class="pre">start_soon</span></code> method. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), then
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> will create a new nursery internally and use
that.</p></li>
<li><p><strong>task_status</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../ref-core/tasks.html#trio.TaskStatus" title="trio.TaskStatus"><code class="xref py py-class docutils literal notranslate"><span class="pre">TaskStatus</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ListenerT</span></code>, bound= <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>])]]</span>) -- This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>, which
will return <code class="docutils literal notranslate"><span class="pre">listeners</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.NoReturn" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a></span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>This function never returns unless cancelled.</p>
</dd>
</dl>
<p>Resource handling:</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> neglects to close the <code class="docutils literal notranslate"><span class="pre">stream</span></code>, then it will be closed
using <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p>
</div></blockquote>
<p>Error handling:</p>
<blockquote>
<div><p>Most errors coming from <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> are allowed to
propagate out (crashing the server in the process). However, some errors –
those which indicate that the server is temporarily overloaded – are
handled specially. These are <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>s with one of the following
errnos:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>: process is out of file descriptors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>: system is out of file descriptors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>: the kernel hit some sort of memory limitation
when trying to create a socket object</p></li>
</ul>
<p>When <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> gets one of these errors, then it:</p>
<ul class="simple">
<li><p>Logs the error to the standard library logger <code class="docutils literal notranslate"><span class="pre">trio.serve_listeners</span></code>
(level = ERROR, with exception information included). By default this
causes it to be printed to stderr.</p></li>
<li><p>Waits 100 ms before calling <code class="docutils literal notranslate"><span class="pre">accept</span></code> again, in hopes that the
system will recover.</p></li>
</ul>
</div></blockquote>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.StapledStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">StapledStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">send_stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receive_stream</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.StapledStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStreamT</span></code></a>, <a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStreamT</span></code></a>]</p>
<p>This class <a class="reference external" href="https://en.wikipedia.org/wiki/Staple_(fastener)">staples</a>
together two unidirectional streams to make single bidirectional stream.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>send_stream</strong> (<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><em>SendStream</em></a>) -- The stream to use for sending.</p></li>
<li><p><strong>receive_stream</strong> (<a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><em>ReceiveStream</em></a>) -- The stream to use for
receiving.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">示例</p>
<p>A silly way to make a stream that echoes back whatever you write to
it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">memory_stream_pair</span><span class="p">()</span>
<span class="n">echo_stream</span> <span class="o">=</span> <span class="n">StapledStream</span><span class="p">(</span><span class="n">SocketStream</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">SocketStream</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
<span class="k">await</span> <span class="n">echo_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"x"</span><span class="p">)</span>
<span class="k">assert</span> <span class="k">await</span> <span class="n">echo_stream</span><span class="o">.</span><span class="n">receive_some</span><span class="p">()</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">"x"</span>
</pre></div>
</div>
<p><a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> objects implement the methods in the
<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> interface. They also have two
additional public attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.StapledStream.send_stream">
<span class="sig-name descname"><span class="pre">send_stream</span></span><a class="headerlink" href="#trio.StapledStream.send_stream" title="Link to this definition">¶</a></dt>
<dd><p>The underlying <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>. <a class="reference internal" href="#trio.StapledStream.send_all" title="trio.StapledStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> and
<a class="reference internal" href="#trio.StapledStream.wait_send_all_might_not_block" title="trio.StapledStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> are delegated to this object.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.StapledStream.receive_stream">
<span class="sig-name descname"><span class="pre">receive_stream</span></span><a class="headerlink" href="#trio.StapledStream.receive_stream" title="Link to this definition">¶</a></dt>
<dd><p>The underlying <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>. <a class="reference internal" href="#trio.StapledStream.receive_some" title="trio.StapledStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>
is delegated to this object.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.StapledStream.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.StapledStream.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">aclose</span></code> on both underlying streams.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.StapledStream.receive_some">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.StapledStream.receive_some" title="Link to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">self.receive_stream.receive_some</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.StapledStream.send_all">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.StapledStream.send_all" title="Link to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.send_all</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.StapledStream.send_eof">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_eof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.StapledStream.send_eof" title="Link to this definition">¶</a></dt>
<dd><p>Shuts down the send side of the stream.</p>
<p>If <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.send_stream.send_eof()</span></code></a> exists,
then this calls it. Otherwise, this calls
<a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.send_stream.aclose()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.StapledStream.wait_send_all_might_not_block">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.StapledStream.wait_send_all_might_not_block" title="Link to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.wait_send_all_might_not_block</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<p>Trio currently provides a generic helper for writing servers that
listen for connections using one or more
<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>s, and a generic utility class for working
with streams. And if you want to test code that's written against the
streams interface, you should also check out <a class="reference internal" href="../reference-testing.html#testing-streams"><span class="std std-ref">流</span></a> in
<a class="reference internal" href="../reference-testing.html#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a>.</p>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">serve_listeners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listeners</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler_nursery</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Listen for incoming connections on <code class="docutils literal notranslate"><span class="pre">listeners</span></code>, and for each one
start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn't do
anything special to catch it – so by default the exception will
propagate out and crash your server. If you don't want this, then catch
exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object
that responds to exceptions in some other way.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handler</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">StreamT</span></code>, bound= <a class="reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>)], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Awaitable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Awaitable</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>]]</span>) -- An async callable, that will be invoked like
<code class="docutils literal notranslate"><span class="pre">handler_nursery.start_soon(handler,</span> <span class="pre">stream)</span></code> for each incoming
connection.</p></li>
<li><p><strong>listeners</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ListenerT</span></code>, bound= <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>])]</span>) -- A list of <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects.
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> takes responsibility for closing them.</p></li>
<li><p><strong>handler_nursery</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../ref-core/tasks.html#trio.Nursery" title="trio.Nursery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nursery</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>) -- The nursery used to start handlers, or any object with
a <code class="docutils literal notranslate"><span class="pre">start_soon</span></code> method. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), then
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> will create a new nursery internally and use
that.</p></li>
<li><p><strong>task_status</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="../ref-core/tasks.html#trio.TaskStatus" title="trio.TaskStatus"><code class="xref py py-class docutils literal notranslate"><span class="pre">TaskStatus</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">ListenerT</span></code>, bound= <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>])]]</span>) -- This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>, which
will return <code class="docutils literal notranslate"><span class="pre">listeners</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.NoReturn" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a></span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>This function never returns unless cancelled.</p>
</dd>
</dl>
<p>Resource handling:</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> neglects to close the <code class="docutils literal notranslate"><span class="pre">stream</span></code>, then it will be closed
using <a class="reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p>
</div></blockquote>
<p>Error handling:</p>
<blockquote>
<div><p>Most errors coming from <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> are allowed to
propagate out (crashing the server in the process). However, some errors –
those which indicate that the server is temporarily overloaded – are
handled specially. These are <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>s with one of the following
errnos:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>: process is out of file descriptors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>: system is out of file descriptors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>: the kernel hit some sort of memory limitation
when trying to create a socket object</p></li>
</ul>
<p>When <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> gets one of these errors, then it:</p>
<ul class="simple">
<li><p>Logs the error to the standard library logger <code class="docutils literal notranslate"><span class="pre">trio.serve_listeners</span></code>
(level = ERROR, with exception information included). By default this
causes it to be printed to stderr.</p></li>
<li><p>Waits 100 ms before calling <code class="docutils literal notranslate"><span class="pre">accept</span></code> again, in hopes that the
system will recover.</p></li>
</ul>
</div></blockquote>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">StapledStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">send_stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receive_stream</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStreamT</span></code></a>, <a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStreamT</span></code></a>]</p>
<p>This class <a class="reference external" href="https://en.wikipedia.org/wiki/Staple_(fastener)">staples</a>
together two unidirectional streams to make single bidirectional stream.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>send_stream</strong> (<a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><em>SendStream</em></a>) -- The stream to use for sending.</p></li>
<li><p><strong>receive_stream</strong> (<a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><em>ReceiveStream</em></a>) -- The stream to use for
receiving.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">示例</p>
<p>A silly way to make a stream that echoes back whatever you write to
it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">memory_stream_pair</span><span class="p">()</span>
<span class="n">echo_stream</span> <span class="o">=</span> <span class="n">StapledStream</span><span class="p">(</span><span class="n">SocketStream</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">SocketStream</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
<span class="k">await</span> <span class="n">echo_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"x"</span><span class="p">)</span>
<span class="k">assert</span> <span class="k">await</span> <span class="n">echo_stream</span><span class="o">.</span><span class="n">receive_some</span><span class="p">()</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">"x"</span>
</pre></div>
</div>
<p><a class="reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> objects implement the methods in the
<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> interface. They also have two
additional public attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">send_stream</span></span><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dd><p>The underlying <a class="reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>. <a class="reference internal" href="#trio.StapledStream.send_all" title="trio.StapledStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> and
<a class="reference internal" href="#trio.StapledStream.wait_send_all_might_not_block" title="trio.StapledStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> are delegated to this object.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id3">
<span class="sig-name descname"><span class="pre">receive_stream</span></span><a class="headerlink" href="#id3" title="Link to this definition">¶</a></dt>
<dd><p>The underlying <a class="reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>. <a class="reference internal" href="#trio.StapledStream.receive_some" title="trio.StapledStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>
is delegated to this object.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">aclose</span></code> on both underlying streams.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">self.receive_stream.receive_some</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.send_all</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_eof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Shuts down the send side of the stream.</p>
<p>If <a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.send_stream.send_eof()</span></code></a> exists,
then this calls it. Otherwise, this calls
<a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.send_stream.aclose()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.wait_send_all_might_not_block</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</div>
</div>
</section>
<section id="high-level-networking">
<span id="id4"></span><h2>套接字和网络<a class="headerlink" href="#high-level-networking" title="Link to this heading">¶</a></h2>
<p><strong>Sockets and networking</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<p>高级网络接口是建立在我们的流抽象之上的。</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.open_tcp_stream">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_tcp_stream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.open_tcp_stream" title="Link to this definition">¶</a></dt>
<dd><p>Connect to the given host and port over TCP.</p>
<p>If the given <code class="docutils literal notranslate"><span class="pre">host</span></code> has multiple IP addresses associated with it, then
we have a problem: which one do we use?</p>
<p>One approach would be to attempt to connect to the first one, and then if
that fails, attempt to connect to the second one ... until we've tried all
of them. But the problem with this is that if the first IP address is
unreachable (for example, because it's an IPv6 address and our network
discards IPv6 packets), then we might end up waiting tens of seconds for
the first connection attempt to timeout before we try the second address.</p>
<p>Another approach would be to attempt to connect to all of the addresses at
the same time, in parallel, and then use whichever connection succeeds
first, abandoning the others. This would be fast, but create a lot of
unnecessary load on the network and the remote server.</p>
<p>This function strikes a balance between these two extremes: it works its
way through the available addresses one at a time, like the first
approach; but, if <code class="docutils literal notranslate"><span class="pre">happy_eyeballs_delay</span></code> seconds have passed and it's
still waiting for an attempt to succeed or fail, then it gets impatient
and starts the next connection attempt in parallel. As soon as any one
connection attempt succeeds, all the other attempts are cancelled. This
avoids unnecessary load because most connections will succeed after just
one or two attempts, but if one of the addresses is unreachable then it
doesn't slow us down too much.</p>
<p>This is known as a "happy eyeballs" algorithm, and our particular variant
is modelled after how Chrome connects to webservers; see <a class="reference external" href="https://tools.ietf.org/html/rfc6555">RFC 6555</a> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a>) -- The host to connect to. Can be an IPv4 address,
IPv6 address, or a hostname.</p></li>
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to connect to.</p></li>
<li><p><strong>happy_eyeballs_delay</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a><em> or </em><em>None</em>) -- How many seconds to wait for each
connection attempt to succeed or fail before getting impatient and
starting another one in parallel. Set to <cite>None</cite> if you want
to limit to only one connection attempt at a time (like
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/socket.html#socket.create_connection" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.create_connection()</span></code></a>). Default: 0.25 (250 ms).</p></li>
<li><p><strong>local_address</strong> (<em>None</em><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a>) -- <p>The local IP address or hostname to use as
the source for outgoing connections. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, we let the OS pick
the source IP.</p>
<p>This is useful in some exotic networking configurations where your
host has multiple IP addresses, and you want to force the use of a
specific one.</p>
<p>Note that if you pass an IPv4 <code class="docutils literal notranslate"><span class="pre">local_address</span></code>, then you won't be
able to connect to IPv6 hosts, and vice-versa. If you want to take
advantage of this to force the use of IPv4 or IPv6 without
specifying an exact source address, you can use the IPv4 wildcard
address <code class="docutils literal notranslate"><span class="pre">local_address="0.0.0.0"</span></code>, or the IPv6 wildcard address
<code class="docutils literal notranslate"><span class="pre">local_address="::"</span></code>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given server.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- if the connection fails.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>open_ssl_over_tcp_stream</p>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.serve_tcp">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">serve_tcp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler_nursery</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.serve_tcp" title="Link to this definition">¶</a></dt>
<dd><p>Listen for incoming TCP connections, and for each one start a task
running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p>
<p>This is a thin convenience wrapper around <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> and
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them for full details.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn't do
anything special to catch it – so by default the exception will
propagate out and crash your server. If you don't want this, then catch
exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object
that responds to exceptions in some other way.</p>
</div>
<p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners.
So, for example, if you want to start a server in your test suite and then
connect to it to check that it's working properly, you can use something
like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">trio</span> <span class="kn">import</span> <span class="n">SocketListener</span><span class="p">,</span> <span class="n">SocketStream</span>
<span class="kn">from</span> <span class="nn">trio.testing</span> <span class="kn">import</span> <span class="n">open_stream_to_socket_listener</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
    <span class="n">listeners</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">SocketListener</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="n">nursery</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">serve_tcp</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">client_stream</span><span class="p">:</span> <span class="n">SocketStream</span> <span class="o">=</span> <span class="k">await</span> <span class="n">open_stream_to_socket_listener</span><span class="p">(</span><span class="n">listeners</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Then send and receive data on 'client_stream', for example:</span>
    <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"GET / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
<p>This avoids several common pitfalls:</p>
<ol class="arabic simple">
<li><p>It lets the kernel pick a random open port, so your test suite doesn't
depend on any particular port being open.</p></li>
<li><p>It waits for the server to be accepting connections on that port before
<code class="docutils literal notranslate"><span class="pre">start</span></code> returns, so there's no race condition where the incoming
connection arrives before the server is ready.</p></li>
<li><p>It uses the Listener object to find out which port was picked, so it
can connect to the right place.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handler</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[trio.SocketStream], Awaitable[object]]</span>) -- The handler to start for each incoming connection. Passed to
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>port</strong> (<span class="sphinx_autodoc_typehints-type">int</span>) -- The port to listen on. Use 0 to let the kernel pick an open port.
Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The host interface to listen on; use
<code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. Passed to
<a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>backlog</strong> (<span class="sphinx_autodoc_typehints-type">int | None</span>) -- The listen backlog, or None to have a good default picked.
Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>handler_nursery</strong> (<span class="sphinx_autodoc_typehints-type">trio.Nursery | None</span>) -- The nursery to start handlers in, or None to use an
internal nursery. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>task_status</strong> (<span class="sphinx_autodoc_typehints-type">TaskStatus[list[trio.SocketListener]]</span>) -- This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>This function only returns when cancelled.</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.open_ssl_over_tcp_stream">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_ssl_over_tcp_stream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.open_ssl_over_tcp_stream" title="Link to this definition">¶</a></dt>
<dd><p>Make a TLS-encrypted Connection to the given host and port over TCP.</p>
<p>This is a convenience wrapper that calls <a class="reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a> and
wraps the result in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p>
<p>This function does not perform the TLS handshake; you can do it
manually by calling <a class="reference internal" href="#trio.SSLStream.do_handshake" title="trio.SSLStream.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a>, or else
it will be performed automatically the first time you send or receive
data.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a>) -- The host to connect to. We require the server
to have a TLS certificate valid for this hostname.</p></li>
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to connect to.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Set this to True if you're connecting to a web
server. See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details. Default:
False.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> or None) -- The SSL context to
use. If None (the default), <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>
will be called to create a context.</p></li>
<li><p><strong>happy_eyeballs_delay</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- See <a class="reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>the encrypted connection to the server.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream">trio.SSLStream</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.serve_ssl_over_tcp">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">serve_ssl_over_tcp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler_nursery</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.serve_ssl_over_tcp" title="Link to this definition">¶</a></dt>
<dd><p>Listen for incoming TCP connections, and for each one start a task
running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p>
<p>This is a thin convenience wrapper around
<a class="reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a> and <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them
for full details.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn't do
anything special to catch it – so by default the exception will
propagate out and crash your server. If you don't want this, then catch
exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object
that responds to exceptions in some other way.</p>
</div>
<p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners.
See the documentation for <a class="reference internal" href="#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> for an example where this is
useful.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handler</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[trio.SSLStream[SocketStream]], Awaitable[object]]</span>) -- The handler to start for each incoming connection. Passed to
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to listen on. Use 0 to let the kernel pick
an open port. Ultimately passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The SSL context to use for all incoming
connections. Passed to <a class="reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind
to the wildcard address. Ultimately passed to
<a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Set this to True if you want to use
"HTTPS-style" TLS. See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li>
<li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li>
<li><p><strong>handler_nursery</strong> (<span class="sphinx_autodoc_typehints-type">trio.Nursery | None</span>) -- The nursery to start handlers in, or None to use an
internal nursery. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>task_status</strong> (<span class="sphinx_autodoc_typehints-type">trio.TaskStatus[list[trio.SSLListener[SocketStream]]]</span>) -- This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">NoReturn</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>This function only returns when cancelled.</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.open_unix_socket">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_unix_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.open_unix_socket" title="Link to this definition">¶</a></dt>
<dd><p>Opens a connection to the specified
<a class="reference external" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a>.</p>
<p>You must have read/write permission on the specified file to connect.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a>) -- The filename to open the connection to.</p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given file.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- If the socket file could not be connected to.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- If AF_UNIX sockets are not supported.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.SocketStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SocketStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a></p>
<p>An implementation of the <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a>
interface based on a raw network socket.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>socket</strong> (<span class="sphinx_autodoc_typehints-type">SocketType</span>) -- The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>,
and be connected.</p>
</dd>
</dl>
<p>By default for TCP sockets, <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> enables <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>,
and (on platforms where it's supported) enables <code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code> with
a reasonable buffer size (currently 16 KiB) – see <a class="reference external" href="https://github.com/python-trio/trio/issues/72">issue #72</a> for discussion. You can
of course override these defaults by calling <a class="reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a>.</p>
<p>Once a <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> object is constructed, it implements the full
<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a> interface. In addition, it provides
a few extra features:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.SocketStream.socket">
<span class="sig-name descname"><span class="pre">socket</span></span><a class="headerlink" href="#trio.SocketStream.socket" title="Link to this definition">¶</a></dt>
<dd><p>The Trio socket object that this stream wraps.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.aclose" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.getsockopt">
<span class="sig-name descname"><span class="pre">getsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">option</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.getsockopt" title="Link to this definition">¶</a></dt>
<dd><p>Check the current value of an option on the underlying socket.</p>
<p>See <a class="reference external" href="https://docs.python.org/zh-cn/3/library/socket.html#socket.socket.getsockopt" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockopt()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.receive_some">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.receive_some" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.send_all">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.send_all" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.send_eof">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_eof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.send_eof" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.setsockopt">
<span class="sig-name descname"><span class="pre">setsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">option</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.setsockopt" title="Link to this definition">¶</a></dt>
<dd><p>Set an option on the underlying socket.</p>
<p>See <a class="reference external" href="https://docs.python.org/zh-cn/3/library/socket.html#socket.socket.setsockopt" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.setsockopt()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketStream.wait_send_all_might_not_block">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketStream.wait_send_all_might_not_block" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.SocketListener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SocketListener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketListener" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>]</p>
<p>A <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that uses a listening socket to accept
incoming connections as <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>socket</strong> (<span class="sphinx_autodoc_typehints-type">SocketType</span>) -- The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>,
and be listening.</p>
</dd>
</dl>
<p>Note that the <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> "takes ownership" of the given
socket; closing the <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> will also close the socket.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.SocketListener.socket">
<span class="sig-name descname"><span class="pre">socket</span></span><a class="headerlink" href="#trio.SocketListener.socket" title="Link to this definition">¶</a></dt>
<dd><p>The Trio socket object that this stream wraps.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketListener.accept">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketListener.accept" title="Link to this definition">¶</a></dt>
<dd><p>Accept an incoming connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a></span></p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a></p>
</dd>
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- if the underlying call to <code class="docutils literal notranslate"><span class="pre">accept</span></code> raises an unexpected
    error.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>ClosedResourceError</strong></a> -- if you already closed the socket.</p></li>
</ul>
</dd>
</dl>
<p>This method handles routine errors like <code class="docutils literal notranslate"><span class="pre">ECONNABORTED</span></code>, but passes
other errors on to its caller. In particular, it does <em>not</em> make any
special effort to handle resource exhaustion errors like <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>,
<code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SocketListener.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SocketListener.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Close this listener and its underlying socket.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.open_tcp_listeners">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_tcp_listeners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.open_tcp_listeners" title="Link to this definition">¶</a></dt>
<dd><p>Create <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> objects to listen for TCP connections.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- <p>The port to listen on.</p>
<p>If you use 0 as your port, then the kernel will automatically pick
an arbitrary open port. But be careful: if you use this feature when
binding to multiple IP addresses, then each IP address will get its
own random port, and the returned listeners will probably be
listening on different ports. In particular, this will happen if you
use <code class="docutils literal notranslate"><span class="pre">host=None</span></code> – which is the default – because in this case
<a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> will bind to both the IPv4 wildcard
address (<code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code>) and also the IPv6 wildcard address (<code class="docutils literal notranslate"><span class="pre">::</span></code>).</p>
</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- <p>The local interface to bind to. This is
passed to <a class="reference internal" href="low_level.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">AI_PASSIVE</span></code> flag
set.</p>
<p>If you want to bind to the wildcard address on both IPv4 and IPv6,
in order to accept connections on all available interfaces, then
pass <code class="docutils literal notranslate"><span class="pre">None</span></code>. This is the default.</p>
<p>If you have a specific interface you want to bind to, pass its IP
address or hostname here. If a hostname resolves to multiple IP
addresses, this function will open one listener on each of them.</p>
<p>If you want to use only IPv4, or only IPv6, but want to accept on
all interfaces, pass the family-specific wildcard address:
<code class="docutils literal notranslate"><span class="pre">"0.0.0.0"</span></code> for IPv4-only and <code class="docutils literal notranslate"><span class="pre">"::"</span></code> for IPv6-only.</p>
</p></li>
<li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- The listen backlog to use. If you leave this as
<code class="docutils literal notranslate"><span class="pre">None</span></code> then Trio will pick a good default. (Currently: whatever
your system has configured as the maximum backlog.)</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>[<a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a>]</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="（在 Python v3.13）"><strong>TypeError</strong></a> -- </p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.open_ssl_over_tcp_listeners">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_ssl_over_tcp_listeners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.open_ssl_over_tcp_listeners" title="Link to this definition">¶</a></dt>
<dd><p>Start listening for SSL/TLS-encrypted TCP connections to the given port.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to listen on. See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The SSL context to use for all incoming
connections.</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind
to the wildcard address. See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li>
<li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> for details.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">list[trio.SSLListener[SocketStream]]</span></p>
</dd>
</dl>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<p>The high-level network interface is built on top of our stream
abstraction.</p>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_tcp_stream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Connect to the given host and port over TCP.</p>
<p>If the given <code class="docutils literal notranslate"><span class="pre">host</span></code> has multiple IP addresses associated with it, then
we have a problem: which one do we use?</p>
<p>One approach would be to attempt to connect to the first one, and then if
that fails, attempt to connect to the second one ... until we've tried all
of them. But the problem with this is that if the first IP address is
unreachable (for example, because it's an IPv6 address and our network
discards IPv6 packets), then we might end up waiting tens of seconds for
the first connection attempt to timeout before we try the second address.</p>
<p>Another approach would be to attempt to connect to all of the addresses at
the same time, in parallel, and then use whichever connection succeeds
first, abandoning the others. This would be fast, but create a lot of
unnecessary load on the network and the remote server.</p>
<p>This function strikes a balance between these two extremes: it works its
way through the available addresses one at a time, like the first
approach; but, if <code class="docutils literal notranslate"><span class="pre">happy_eyeballs_delay</span></code> seconds have passed and it's
still waiting for an attempt to succeed or fail, then it gets impatient
and starts the next connection attempt in parallel. As soon as any one
connection attempt succeeds, all the other attempts are cancelled. This
avoids unnecessary load because most connections will succeed after just
one or two attempts, but if one of the addresses is unreachable then it
doesn't slow us down too much.</p>
<p>This is known as a "happy eyeballs" algorithm, and our particular variant
is modelled after how Chrome connects to webservers; see <a class="reference external" href="https://tools.ietf.org/html/rfc6555">RFC 6555</a> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a>) -- The host to connect to. Can be an IPv4 address,
IPv6 address, or a hostname.</p></li>
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to connect to.</p></li>
<li><p><strong>happy_eyeballs_delay</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a><em> or </em><em>None</em>) -- How many seconds to wait for each
connection attempt to succeed or fail before getting impatient and
starting another one in parallel. Set to <cite>None</cite> if you want
to limit to only one connection attempt at a time (like
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/socket.html#socket.create_connection" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.create_connection()</span></code></a>). Default: 0.25 (250 ms).</p></li>
<li><p><strong>local_address</strong> (<em>None</em><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a>) -- <p>The local IP address or hostname to use as
the source for outgoing connections. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, we let the OS pick
the source IP.</p>
<p>This is useful in some exotic networking configurations where your
host has multiple IP addresses, and you want to force the use of a
specific one.</p>
<p>Note that if you pass an IPv4 <code class="docutils literal notranslate"><span class="pre">local_address</span></code>, then you won't be
able to connect to IPv6 hosts, and vice-versa. If you want to take
advantage of this to force the use of IPv4 or IPv6 without
specifying an exact source address, you can use the IPv4 wildcard
address <code class="docutils literal notranslate"><span class="pre">local_address="0.0.0.0"</span></code>, or the IPv6 wildcard address
<code class="docutils literal notranslate"><span class="pre">local_address="::"</span></code>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given server.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- if the connection fails.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>open_ssl_over_tcp_stream</p>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">serve_tcp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler_nursery</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Listen for incoming TCP connections, and for each one start a task
running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p>
<p>This is a thin convenience wrapper around <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> and
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them for full details.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn't do
anything special to catch it – so by default the exception will
propagate out and crash your server. If you don't want this, then catch
exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object
that responds to exceptions in some other way.</p>
</div>
<p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners.
So, for example, if you want to start a server in your test suite and then
connect to it to check that it's working properly, you can use something
like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">trio</span> <span class="kn">import</span> <span class="n">SocketListener</span><span class="p">,</span> <span class="n">SocketStream</span>
<span class="kn">from</span> <span class="nn">trio.testing</span> <span class="kn">import</span> <span class="n">open_stream_to_socket_listener</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
    <span class="n">listeners</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">SocketListener</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="n">nursery</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">serve_tcp</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">client_stream</span><span class="p">:</span> <span class="n">SocketStream</span> <span class="o">=</span> <span class="k">await</span> <span class="n">open_stream_to_socket_listener</span><span class="p">(</span><span class="n">listeners</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Then send and receive data on 'client_stream', for example:</span>
    <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="sa">b</span><span class="s2">"GET / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
<p>This avoids several common pitfalls:</p>
<ol class="arabic simple">
<li><p>It lets the kernel pick a random open port, so your test suite doesn't
depend on any particular port being open.</p></li>
<li><p>It waits for the server to be accepting connections on that port before
<code class="docutils literal notranslate"><span class="pre">start</span></code> returns, so there's no race condition where the incoming
connection arrives before the server is ready.</p></li>
<li><p>It uses the Listener object to find out which port was picked, so it
can connect to the right place.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handler</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[trio.SocketStream], Awaitable[object]]</span>) -- The handler to start for each incoming connection. Passed to
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>port</strong> (<span class="sphinx_autodoc_typehints-type">int</span>) -- The port to listen on. Use 0 to let the kernel pick an open port.
Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The host interface to listen on; use
<code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. Passed to
<a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>backlog</strong> (<span class="sphinx_autodoc_typehints-type">int | None</span>) -- The listen backlog, or None to have a good default picked.
Passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>handler_nursery</strong> (<span class="sphinx_autodoc_typehints-type">trio.Nursery | None</span>) -- The nursery to start handlers in, or None to use an
internal nursery. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>task_status</strong> (<span class="sphinx_autodoc_typehints-type">TaskStatus[list[trio.SocketListener]]</span>) -- This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>This function only returns when cancelled.</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_ssl_over_tcp_stream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Make a TLS-encrypted Connection to the given host and port over TCP.</p>
<p>This is a convenience wrapper that calls <a class="reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a> and
wraps the result in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p>
<p>This function does not perform the TLS handshake; you can do it
manually by calling <a class="reference internal" href="#trio.SSLStream.do_handshake" title="trio.SSLStream.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a>, or else
it will be performed automatically the first time you send or receive
data.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a>) -- The host to connect to. We require the server
to have a TLS certificate valid for this hostname.</p></li>
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to connect to.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Set this to True if you're connecting to a web
server. See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details. Default:
False.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> or None) -- The SSL context to
use. If None (the default), <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>
will be called to create a context.</p></li>
<li><p><strong>happy_eyeballs_delay</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- See <a class="reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>the encrypted connection to the server.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream">trio.SSLStream</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">serve_ssl_over_tcp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler_nursery</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Listen for incoming TCP connections, and for each one start a task
running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p>
<p>This is a thin convenience wrapper around
<a class="reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a> and <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them
for full details.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn't do
anything special to catch it – so by default the exception will
propagate out and crash your server. If you don't want this, then catch
exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object
that responds to exceptions in some other way.</p>
</div>
<p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners.
See the documentation for <a class="reference internal" href="#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> for an example where this is
useful.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>handler</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[trio.SSLStream[SocketStream]], Awaitable[object]]</span>) -- The handler to start for each incoming connection. Passed to
<a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to listen on. Use 0 to let the kernel pick
an open port. Ultimately passed to <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The SSL context to use for all incoming
connections. Passed to <a class="reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind
to the wildcard address. Ultimately passed to
<a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Set this to True if you want to use
"HTTPS-style" TLS. See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li>
<li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li>
<li><p><strong>handler_nursery</strong> (<span class="sphinx_autodoc_typehints-type">trio.Nursery | None</span>) -- The nursery to start handlers in, or None to use an
internal nursery. Passed to <a class="reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li>
<li><p><strong>task_status</strong> (<span class="sphinx_autodoc_typehints-type">trio.TaskStatus[list[trio.SSLListener[SocketStream]]]</span>) -- This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">NoReturn</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>This function only returns when cancelled.</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_unix_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Opens a connection to the specified
<a class="reference external" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a>.</p>
<p>You must have read/write permission on the specified file to connect.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a>) -- The filename to open the connection to.</p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>a <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given file.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- If the socket file could not be connected to.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" title="（在 Python v3.13）"><strong>RuntimeError</strong></a> -- If AF_UNIX sockets are not supported.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SocketStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a></p>
<p>An implementation of the <a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a>
interface based on a raw network socket.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>socket</strong> (<span class="sphinx_autodoc_typehints-type">SocketType</span>) -- The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>,
and be connected.</p>
</dd>
</dl>
<p>By default for TCP sockets, <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> enables <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>,
and (on platforms where it's supported) enables <code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code> with
a reasonable buffer size (currently 16 KiB) – see <a class="reference external" href="https://github.com/python-trio/trio/issues/72">issue #72</a> for discussion. You can
of course override these defaults by calling <a class="reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a>.</p>
<p>Once a <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> object is constructed, it implements the full
<a class="reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a> interface. In addition, it provides
a few extra features:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="id5">
<span class="sig-name descname"><span class="pre">socket</span></span><a class="headerlink" href="#id5" title="Link to this definition">¶</a></dt>
<dd><p>The Trio socket object that this stream wraps.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">getsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">option</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check the current value of an option on the underlying socket.</p>
<p>See <a class="reference external" href="https://docs.python.org/zh-cn/3/library/socket.html#socket.socket.getsockopt" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockopt()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_eof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">setsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">option</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set an option on the underlying socket.</p>
<p>See <a class="reference external" href="https://docs.python.org/zh-cn/3/library/socket.html#socket.socket.setsockopt" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.setsockopt()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SocketListener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>]</p>
<p>A <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that uses a listening socket to accept
incoming connections as <a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>socket</strong> (<span class="sphinx_autodoc_typehints-type">SocketType</span>) -- The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>,
and be listening.</p>
</dd>
</dl>
<p>Note that the <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> "takes ownership" of the given
socket; closing the <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> will also close the socket.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="id6">
<span class="sig-name descname"><span class="pre">socket</span></span><a class="headerlink" href="#id6" title="Link to this definition">¶</a></dt>
<dd><p>The Trio socket object that this stream wraps.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Accept an incoming connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a></span></p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a></p>
</dd>
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- if the underlying call to <code class="docutils literal notranslate"><span class="pre">accept</span></code> raises an unexpected
    error.</p></li>
<li><p><a class="reference internal" href="../ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>ClosedResourceError</strong></a> -- if you already closed the socket.</p></li>
</ul>
</dd>
</dl>
<p>This method handles routine errors like <code class="docutils literal notranslate"><span class="pre">ECONNABORTED</span></code>, but passes
other errors on to its caller. In particular, it does <em>not</em> make any
special effort to handle resource exhaustion errors like <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>,
<code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this listener and its underlying socket.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_tcp_listeners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> objects to listen for TCP connections.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- <p>The port to listen on.</p>
<p>If you use 0 as your port, then the kernel will automatically pick
an arbitrary open port. But be careful: if you use this feature when
binding to multiple IP addresses, then each IP address will get its
own random port, and the returned listeners will probably be
listening on different ports. In particular, this will happen if you
use <code class="docutils literal notranslate"><span class="pre">host=None</span></code> – which is the default – because in this case
<a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> will bind to both the IPv4 wildcard
address (<code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code>) and also the IPv6 wildcard address (<code class="docutils literal notranslate"><span class="pre">::</span></code>).</p>
</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- <p>The local interface to bind to. This is
passed to <a class="reference internal" href="low_level.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">AI_PASSIVE</span></code> flag
set.</p>
<p>If you want to bind to the wildcard address on both IPv4 and IPv6,
in order to accept connections on all available interfaces, then
pass <code class="docutils literal notranslate"><span class="pre">None</span></code>. This is the default.</p>
<p>If you have a specific interface you want to bind to, pass its IP
address or hostname here. If a hostname resolves to multiple IP
addresses, this function will open one listener on each of them.</p>
<p>If you want to use only IPv4, or only IPv6, but want to accept on
all interfaces, pass the family-specific wildcard address:
<code class="docutils literal notranslate"><span class="pre">"0.0.0.0"</span></code> for IPv4-only and <code class="docutils literal notranslate"><span class="pre">"::"</span></code> for IPv6-only.</p>
</p></li>
<li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- The listen backlog to use. If you leave this as
<code class="docutils literal notranslate"><span class="pre">None</span></code> then Trio will pick a good default. (Currently: whatever
your system has configured as the maximum backlog.)</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>[<a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a>]</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a></p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="（在 Python v3.13）"><strong>TypeError</strong></a> -- </p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">open_ssl_over_tcp_listeners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start listening for SSL/TLS-encrypted TCP connections to the given port.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The port to listen on. See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The SSL context to use for all incoming
connections.</p></li>
<li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind
to the wildcard address. See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- See <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li>
<li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> or </em><em>None</em>) -- See <a class="reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> for details.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">list[trio.SSLListener[SocketStream]]</span></p>
</dd>
</dl>
</dd></dl>
</div>
</div>
</section>
<section id="ssl-tls">
<h2>SSL / TLS 支持<a class="headerlink" href="#ssl-tls" title="Link to this heading">¶</a></h2>
<p><strong>SSL / TLS support</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 提供了基于标准库 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 模块的 SSL/TLS 支持。Trio 的 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> 和 <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> 从 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 获取其配置, 您可以使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 创建该上下文, 并使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 模块中的其他常量和函数进行自定义。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>避免直接实例化 <cite>ssl.SSLContext</cite>。
新创建的 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 的默认配置不如通过 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 返回的上下文安全。</p>
</div>
<p>您可以通过创建 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> 来代替使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext.wrap_socket" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.wrap_socket()</span></code></a>：</p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.SSLStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SSLStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport_stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_Stream</span></code></a>]</p>
<p>Encrypted communication using SSL/TLS.</p>
<p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> wraps an arbitrary <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and
allows you to perform encrypted communication over it using the usual
<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> interface. You pass regular data to
<a class="reference internal" href="#trio.SSLStream.send_all" title="trio.SSLStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, then it encrypts it and sends the encrypted data on the
underlying <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>; <a class="reference internal" href="#trio.SSLStream.receive_some" title="trio.SSLStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> takes encrypted
data out of the underlying <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> and decrypts it
before returning it.</p>
<p>You should read the standard library's <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> documentation carefully
before attempting to use this class, and probably other general
documentation on SSL/TLS as well. SSL/TLS is subtle and quick to
anger. Really. I'm not kidding.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transport_stream</strong> (<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><em>Stream</em></a>) -- The stream used to transport
encrypted data. Required.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> used for
this connection. Required. Usually created by calling
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p></li>
<li><p><strong>server_hostname</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The name of the server being
connected to. Used for <a class="reference external" href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> and for
validating the server's certificate (if hostname checking is
enabled). This is effectively mandatory for clients, and actually
mandatory if <code class="docutils literal notranslate"><span class="pre">ssl_context.check_hostname</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>server_side</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Whether this stream is acting as a client or
server. Defaults to False, i.e. client mode.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- <p>There are two versions of SSL/TLS commonly
encountered in the wild: the standard version, and the version used
for HTTPS (HTTP-over-SSL/TLS).</p>
<p>Standard-compliant SSL/TLS implementations always send a
cryptographically signed <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> message before closing the
connection. This is important because if the underlying transport
were simply closed, then there wouldn't be any way for the other
side to know whether the connection was intentionally closed by the
peer that they negotiated a cryptographic connection to, or by some
<a class="reference external" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle</a> attacker
who can't manipulate the cryptographic stream, but can manipulate
the transport layer (a so-called "truncation attack").</p>
<p>However, this part of the standard is widely ignored by real-world
HTTPS implementations, which means that if you want to interoperate
with them, then you NEED to ignore it too.</p>
<p>Fortunately this isn't as bad as it sounds, because the HTTP
protocol already includes its own equivalent of <code class="docutils literal notranslate"><span class="pre">close_notify</span></code>, so
doing this again at the SSL/TLS level is redundant. But not all
protocols do! Therefore, by default Trio implements the safer
standard-compliant version (<code class="docutils literal notranslate"><span class="pre">https_compatible=False</span></code>). But if
you're speaking HTTPS or some other protocol where
<code class="docutils literal notranslate"><span class="pre">close_notify</span></code>s are commonly skipped, then you should set
<code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code>; with this setting, Trio will neither
expect nor send <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> messages.</p>
<p>If you have code that was written to use <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> and
now you're porting it to Trio, then it may be useful to know that a
difference between <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> is
that <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> implements the
<code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code> behavior by default.</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.SSLStream.transport_stream">
<span class="sig-name descname"><span class="pre">transport_stream</span></span><a class="headerlink" href="#trio.SSLStream.transport_stream" title="Link to this definition">¶</a></dt>
<dd><p>The underlying transport stream
that was passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>. An example of when this would be
useful is if you're using <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> over a
<a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> and want to call the
<a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>'s <a class="reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a>
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream">trio.abc.Stream</a></p>
</dd>
</dl>
</dd></dl>
<p>Internally, this class is implemented using an instance of
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>, and all of <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>'s methods and
attributes are re-exported as methods and attributes on this class.
However, there is one difference: <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> has several
methods that return information about the encrypted connection, like
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket.cipher" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a> or
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_alpn_protocol()</span></code></a>. If you call them before the
handshake, when they can't possibly return useful data, then
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> returns None, but <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a>
raises <a class="reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a>.</p>
<p>This also means that if you register a SNI callback using
<cite>~ssl.SSLContext.sni_callback</cite>, then the first argument your callback
receives will be a <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLStream.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Gracefully shut down this connection, and close the underlying
transport.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is False (the default), then this attempts to
first send a <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> and then close the underlying stream by
calling its <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is set to True, then this simply closes the
underlying stream and marks this stream as closed.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLStream.do_handshake">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream.do_handshake" title="Link to this definition">¶</a></dt>
<dd><p>Ensure that the initial handshake has completed.</p>
<p>The SSL protocol requires an initial handshake to exchange
certificates, select cryptographic keys, and so forth, before any
actual data can be sent or received. You don't have to call this
method; if you don't, then <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will automatically
perform the handshake as needed, the first time you try to send or
receive data. But if you want to trigger it manually – for example,
because you want to look at the peer's certificate before you start
talking to them – then you can call this method.</p>
<p>If the initial handshake is already in progress in another task, this
waits for it to complete and then returns.</p>
<p>If the initial handshake has already completed, this returns
immediately without doing anything (except executing a checkpoint).
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If this method is cancelled, then it may leave the
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any
future attempt to use the object will raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLStream.receive_some">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream.receive_some" title="Link to this definition">¶</a></dt>
<dd><p>Read some data from the underlying transport, decrypt it, and
return it.</p>
<p>See <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.ReceiveStream.receive_some()</span></code></a> for details.
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a></span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If this method is cancelled while the initial handshake
or a renegotiation are in progress, then it may leave the
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any
future attempt to use the object will raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLStream.send_all">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream.send_all" title="Link to this definition">¶</a></dt>
<dd><p>Encrypt some data and then send it on the underlying transport.</p>
<p>See <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.send_all()</span></code></a> for details.
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If this method is cancelled, then it may leave the
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any
attempt to use the object will raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLStream.unwrap">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream.unwrap" title="Link to this definition">¶</a></dt>
<dd><p>Cleanly close down the SSL/TLS encryption layer, allowing the
underlying stream to be used for unencrypted communication.</p>
<p>You almost certainly don't need this.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>[<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>]</span></p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair <code class="docutils literal notranslate"><span class="pre">(transport_stream,</span> <span class="pre">trailing_bytes)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">transport_stream</span></code> is the underlying transport stream, and
<code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> is a byte string. Since <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>
doesn't necessarily know where the end of the encrypted data will
be, it can happen that it accidentally reads too much from the
underlying stream. <code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> contains this extra data; you
should process it as if it was returned from a call to
<code class="docutils literal notranslate"><span class="pre">transport_stream.receive_some(...)</span></code>.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLStream.wait_send_all_might_not_block">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLStream.wait_send_all_might_not_block" title="Link to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.wait_send_all_might_not_block()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>如果您正在实现一个服务器, 您可以使用 <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a>：</p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.SSLListener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SSLListener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport_listener</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLListener" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_Stream</span></code></a>]]</p>
<p>A <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> for SSL/TLS-encrypted servers.</p>
<p><a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> wraps around another Listener, and converts
all incoming connections to encrypted connections by wrapping them
in a <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transport_listener</strong> (<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><em>Listener</em></a>) -- The listener whose incoming
connections will be wrapped in <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> that will be
used for incoming connections.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Passed on to <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.SSLListener.transport_listener">
<span class="sig-name descname"><span class="pre">transport_listener</span></span><a class="headerlink" href="#trio.SSLListener.transport_listener" title="Link to this definition">¶</a></dt>
<dd><p>The underlying listener that was
passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener">trio.abc.Listener</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLListener.accept">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLListener.accept" title="Link to this definition">¶</a></dt>
<dd><p>Accept the next connection and wrap it in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p>
<p>See <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.Listener.accept()</span></code></a> for details.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.SSLListener.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.SSLListener.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Close the transport listener.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>在 <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> 上的某些方法如果在握手完成之前调用, 将会引发 <a class="reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a>：</p>
<dl class="py exception">
<dt class="sig sig-object py" id="trio.NeedHandshakeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">NeedHandshakeError</span></span><a class="headerlink" href="#trio.NeedHandshakeError" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<p>Some <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> methods can't return any meaningful data until
after the handshake. If you call them before the handshake, they raise
this error.</p>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p>Trio provides SSL/TLS support based on the standard library <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a>
module. Trio's <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> take their
configuration from a <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, which you can create
using <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> and customize using the
other constants and functions in the <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Avoid instantiating <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> directly.
A newly constructed <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> has less secure
defaults than one returned by <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p>
</div>
<p>Instead of using <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext.wrap_socket" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.wrap_socket()</span></code></a>, you
create a <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SSLStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport_stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_Stream</span></code></a>]</p>
<p>Encrypted communication using SSL/TLS.</p>
<p><a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> wraps an arbitrary <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and
allows you to perform encrypted communication over it using the usual
<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> interface. You pass regular data to
<a class="reference internal" href="#trio.SSLStream.send_all" title="trio.SSLStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, then it encrypts it and sends the encrypted data on the
underlying <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>; <a class="reference internal" href="#trio.SSLStream.receive_some" title="trio.SSLStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> takes encrypted
data out of the underlying <a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> and decrypts it
before returning it.</p>
<p>You should read the standard library's <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> documentation carefully
before attempting to use this class, and probably other general
documentation on SSL/TLS as well. SSL/TLS is subtle and quick to
anger. Really. I'm not kidding.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transport_stream</strong> (<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><em>Stream</em></a>) -- The stream used to transport
encrypted data. Required.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> used for
this connection. Required. Usually created by calling
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.create_default_context" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p></li>
<li><p><strong>server_hostname</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><em>bytes</em></a><em>, or </em><em>None</em>) -- The name of the server being
connected to. Used for <a class="reference external" href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> and for
validating the server's certificate (if hostname checking is
enabled). This is effectively mandatory for clients, and actually
mandatory if <code class="docutils literal notranslate"><span class="pre">ssl_context.check_hostname</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>server_side</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Whether this stream is acting as a client or
server. Defaults to False, i.e. client mode.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- <p>There are two versions of SSL/TLS commonly
encountered in the wild: the standard version, and the version used
for HTTPS (HTTP-over-SSL/TLS).</p>
<p>Standard-compliant SSL/TLS implementations always send a
cryptographically signed <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> message before closing the
connection. This is important because if the underlying transport
were simply closed, then there wouldn't be any way for the other
side to know whether the connection was intentionally closed by the
peer that they negotiated a cryptographic connection to, or by some
<a class="reference external" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle</a> attacker
who can't manipulate the cryptographic stream, but can manipulate
the transport layer (a so-called "truncation attack").</p>
<p>However, this part of the standard is widely ignored by real-world
HTTPS implementations, which means that if you want to interoperate
with them, then you NEED to ignore it too.</p>
<p>Fortunately this isn't as bad as it sounds, because the HTTP
protocol already includes its own equivalent of <code class="docutils literal notranslate"><span class="pre">close_notify</span></code>, so
doing this again at the SSL/TLS level is redundant. But not all
protocols do! Therefore, by default Trio implements the safer
standard-compliant version (<code class="docutils literal notranslate"><span class="pre">https_compatible=False</span></code>). But if
you're speaking HTTPS or some other protocol where
<code class="docutils literal notranslate"><span class="pre">close_notify</span></code>s are commonly skipped, then you should set
<code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code>; with this setting, Trio will neither
expect nor send <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> messages.</p>
<p>If you have code that was written to use <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> and
now you're porting it to Trio, then it may be useful to know that a
difference between <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> is
that <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> implements the
<code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code> behavior by default.</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">transport_stream</span></span></dt>
<dd><p>The underlying transport stream
that was passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>. An example of when this would be
useful is if you're using <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> over a
<a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> and want to call the
<a class="reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>'s <a class="reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a>
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream">trio.abc.Stream</a></p>
</dd>
</dl>
</dd></dl>
<p>Internally, this class is implemented using an instance of
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>, and all of <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>'s methods and
attributes are re-exported as methods and attributes on this class.
However, there is one difference: <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> has several
methods that return information about the encrypted connection, like
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket.cipher" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a> or
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="（在 Python v3.13）"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_alpn_protocol()</span></code></a>. If you call them before the
handshake, when they can't possibly return useful data, then
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> returns None, but <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a>
raises <a class="reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a>.</p>
<p>This also means that if you register a SNI callback using
<cite>~ssl.SSLContext.sni_callback</cite>, then the first argument your callback
receives will be a <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLObject" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Gracefully shut down this connection, and close the underlying
transport.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is False (the default), then this attempts to
first send a <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> and then close the underlying stream by
calling its <a class="reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is set to True, then this simply closes the
underlying stream and marks this stream as closed.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Ensure that the initial handshake has completed.</p>
<p>The SSL protocol requires an initial handshake to exchange
certificates, select cryptographic keys, and so forth, before any
actual data can be sent or received. You don't have to call this
method; if you don't, then <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will automatically
perform the handshake as needed, the first time you try to send or
receive data. But if you want to trigger it manually – for example,
because you want to look at the peer's certificate before you start
talking to them – then you can call this method.</p>
<p>If the initial handshake is already in progress in another task, this
waits for it to complete and then returns.</p>
<p>If the initial handshake has already completed, this returns
immediately without doing anything (except executing a checkpoint).
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If this method is cancelled, then it may leave the
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any
future attempt to use the object will raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive_some</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_bytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Read some data from the underlying transport, decrypt it, and
return it.</p>
<p>See <a class="reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.ReceiveStream.receive_some()</span></code></a> for details.
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a></span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If this method is cancelled while the initial handshake
or a renegotiation are in progress, then it may leave the
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any
future attempt to use the object will raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Encrypt some data and then send it on the underlying transport.</p>
<p>See <a class="reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.send_all()</span></code></a> for details.
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If this method is cancelled, then it may leave the
<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any
attempt to use the object will raise
<a class="reference internal" href="../ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Cleanly close down the SSL/TLS encryption layer, allowing the
underlying stream to be used for unencrypted communication.</p>
<p>You almost certainly don't need this.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>[<a class="reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>]</span></p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair <code class="docutils literal notranslate"><span class="pre">(transport_stream,</span> <span class="pre">trailing_bytes)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">transport_stream</span></code> is the underlying transport stream, and
<code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> is a byte string. Since <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>
doesn't necessarily know where the end of the encrypted data will
be, it can happen that it accidentally reads too much from the
underlying stream. <code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> contains this extra data; you
should process it as if it was returned from a call to
<code class="docutils literal notranslate"><span class="pre">transport_stream.receive_some(...)</span></code>.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">wait_send_all_might_not_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>See <a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.wait_send_all_might_not_block()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>And if you're implementing a server, you can use <a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">SSLListener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport_listener</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">https_compatible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_Stream</span></code></a>]]</p>
<p>A <a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> for SSL/TLS-encrypted servers.</p>
<p><a class="reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> wraps around another Listener, and converts
all incoming connections to encrypted connections by wrapping them
in a <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transport_listener</strong> (<a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><em>Listener</em></a>) -- The listener whose incoming
connections will be wrapped in <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><em>SSLContext</em></a>) -- The <a class="reference external" href="https://docs.python.org/zh-cn/3/library/ssl.html#ssl.SSLContext" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> that will be
used for incoming connections.</p></li>
<li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Passed on to <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">transport_listener</span></span></dt>
<dd><p>The underlying listener that was
passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.abc.Listener" title="trio.abc.Listener">trio.abc.Listener</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Accept the next connection and wrap it in an <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p>
<p>See <a class="reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.Listener.accept()</span></code></a> for details.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close the transport listener.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>Some methods on <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> raise <a class="reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a> if
you call them before the handshake completes:</p>
<dl class="py exception">
<dt class="sig sig-object py">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">NeedHandshakeError</span></span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<p>Some <a class="reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> methods can't return any meaningful data until
after the handshake. If you call them before the handshake, they raise
this error.</p>
</dd></dl>
</div>
</div>
</section>
<section id="tls">
<h2>数据报 TLS 支持<a class="headerlink" href="#tls" title="Link to this heading">¶</a></h2>
<p><strong>Datagram TLS support</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 还支持数据报 TLS (DTLS ) , 它类似于 TLS, 但用于不可靠的 UDP 连接。对于那些 TCP 的可靠顺序交付存在问题的应用程序, 如视频会议, 延迟敏感的游戏和 VPN, 这非常有用。</p>
<p>目前, 使用 DTLS 与 Trio 需要 PyOpenSSL。我们希望最终能够使用标准库的 <cite>ssl</cite> 模块, 但不幸的是, 目前尚不可能。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>请注意, PyOpenSSL 在许多方面比 <cite>ssl</cite> 模块更底层——尤其是, 它当前 <strong>没有内置的机制来验证证书</strong>。我们 <em>强烈</em> 推荐您使用 <a class="reference external" href="https://pypi.org/project/service-identity/">service-identity</a> 库来验证主机名和证书。</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="trio.DTLSEndpoint">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">DTLSEndpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incoming_packets_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSEndpoint" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A DTLS endpoint.</p>
<p>A single UDP socket can handle arbitrarily many DTLS connections simultaneously,
acting as a client or server as needed. A <cite>DTLSEndpoint</cite> object holds a UDP socket
and manages these connections, which are represented as <cite>DTLSChannel</cite> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>socket</strong> (<span class="sphinx_autodoc_typehints-type">SocketType</span>) -- (trio.socket.SocketType): A <code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> socket. If you want to accept
incoming connections in server mode, then you should probably bind the socket to
some known port.</p></li>
<li><p><strong>incoming_packets_buffer</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- Each <cite>DTLSChannel</cite> using this socket has its own
buffer that holds incoming packets until you call <cite>~DTLSChannel.receive</cite> to read
them. This lets you adjust the size of this buffer. <cite>~DTLSChannel.statistics</cite>
lets you check if the buffer has overflowed.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.DTLSEndpoint.socket">
<span class="sig-name descname"><span class="pre">socket</span></span><a class="headerlink" href="#trio.DTLSEndpoint.socket" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="trio.DTLSEndpoint.incoming_packets_buffer">
<span class="sig-name descname"><span class="pre">incoming_packets_buffer</span></span><a class="headerlink" href="#trio.DTLSEndpoint.incoming_packets_buffer" title="Link to this definition">¶</a></dt>
<dd><p>Both constructor arguments are also exposed as attributes, in case you need to
access them later.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSEndpoint.connect">
<span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSEndpoint.connect" title="Link to this definition">¶</a></dt>
<dd><p>Initiate an outgoing DTLS connection.</p>
<p>Notice that this is a synchronous method. That's because it doesn't actually
initiate any I/O – it just sets up a <cite>DTLSChannel</cite> object. The actual handshake
doesn't occur until you start using the <cite>DTLSChannel</cite>. This gives you a chance
to do further configuration first, like setting MTU etc.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<span class="sphinx_autodoc_typehints-type">tuple[str, int]</span>) -- The address to connect to. Usually a (host, port) tuple, like
<code class="docutils literal notranslate"><span class="pre">("127.0.0.1",</span> <span class="pre">12345)</span></code>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
this connection.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">DTLSChannel</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>DTLSChannel</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSEndpoint.serve">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">serve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">async_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSEndpoint.serve" title="Link to this definition">¶</a></dt>
<dd><p>Listen for incoming connections, and spawn a handler for each using an
internal nursery.</p>
<p>Similar to <cite>~trio.serve_tcp</cite>, this function never returns until cancelled, or
the <cite>DTLSEndpoint</cite> is closed and all handlers have exited.</p>
<p>Usage commonly looks like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">dtls_channel</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">nursery</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">dtls_endpoint</span><span class="o">.</span><span class="n">serve</span><span class="p">,</span> <span class="n">ssl_context</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
    <span class="c1"># ... do other things here ...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dtls_channel</span></code> passed into the handler function has already performed the
"cookie exchange" part of the DTLS handshake, so the peer address is
trustworthy. But the actual cryptographic handshake doesn't happen until you
start using it, giving you a chance for any last minute configuration, and the
option to catch and handle handshake errors.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
incoming connections.</p></li>
<li><p><strong>async_fn</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[DTLSChannel, Unpack[PosArgsT]], Awaitable[object]]</span>) -- The handler function that will be invoked for each incoming
connection.</p></li>
<li><p><strong>*args</strong> (<span class="sphinx_autodoc_typehints-type">Unpack[PosArgsT]</span>) -- Additional arguments to pass to the handler function.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSEndpoint.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSEndpoint.close" title="Link to this definition">¶</a></dt>
<dd><p>Close this socket, and all associated DTLS connections.</p>
<p>This object can also be used as a context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id7">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id7" title="Link to this definition">¶</a></dt>
<dd><p>Close this socket, and all associated DTLS connections.</p>
<p>This object can also be used as a context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id8">
<span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id8" title="Link to this definition">¶</a></dt>
<dd><p>Initiate an outgoing DTLS connection.</p>
<p>Notice that this is a synchronous method. That's because it doesn't actually
initiate any I/O – it just sets up a <cite>DTLSChannel</cite> object. The actual handshake
doesn't occur until you start using the <cite>DTLSChannel</cite>. This gives you a chance
to do further configuration first, like setting MTU etc.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<span class="sphinx_autodoc_typehints-type">tuple[str, int]</span>) -- The address to connect to. Usually a (host, port) tuple, like
<code class="docutils literal notranslate"><span class="pre">("127.0.0.1",</span> <span class="pre">12345)</span></code>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
this connection.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">DTLSChannel</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>DTLSChannel</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id9">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">serve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">async_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id9" title="Link to this definition">¶</a></dt>
<dd><p>Listen for incoming connections, and spawn a handler for each using an
internal nursery.</p>
<p>Similar to <cite>~trio.serve_tcp</cite>, this function never returns until cancelled, or
the <cite>DTLSEndpoint</cite> is closed and all handlers have exited.</p>
<p>Usage commonly looks like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">dtls_channel</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">nursery</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">dtls_endpoint</span><span class="o">.</span><span class="n">serve</span><span class="p">,</span> <span class="n">ssl_context</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
    <span class="c1"># ... do other things here ...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dtls_channel</span></code> passed into the handler function has already performed the
"cookie exchange" part of the DTLS handshake, so the peer address is
trustworthy. But the actual cryptographic handshake doesn't happen until you
start using it, giving you a chance for any last minute configuration, and the
option to catch and handle handshake errors.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
incoming connections.</p></li>
<li><p><strong>async_fn</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[DTLSChannel, Unpack[PosArgsT]], Awaitable[object]]</span>) -- The handler function that will be invoked for each incoming
connection.</p></li>
<li><p><strong>*args</strong> (<span class="sphinx_autodoc_typehints-type">Unpack[PosArgsT]</span>) -- Additional arguments to pass to the handler function.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.DTLSChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">DTLSChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">endpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peer_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Channel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>]</p>
<p>A DTLS connection.</p>
<p>This class has no public constructor – you get instances by calling
<cite>DTLSEndpoint.serve</cite> or <cite>~DTLSEndpoint.connect</cite>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.DTLSChannel.endpoint">
<span class="sig-name descname"><span class="pre">endpoint</span></span><a class="headerlink" href="#trio.DTLSChannel.endpoint" title="Link to this definition">¶</a></dt>
<dd><p>The <cite>DTLSEndpoint</cite> that this connection is using.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.DTLSChannel.peer_address">
<span class="sig-name descname"><span class="pre">peer_address</span></span><a class="headerlink" href="#trio.DTLSChannel.peer_address" title="Link to this definition">¶</a></dt>
<dd><p>The IP/port of the remote peer that this connection is associated with.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.do_handshake">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_retransmit_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.do_handshake" title="Link to this definition">¶</a></dt>
<dd><p>Perform the handshake.</p>
<p>Calling this is optional – if you don't, then it will be automatically called
the first time you call <cite>send</cite> or <cite>receive</cite>. But calling it explicitly can be
useful in case you want to control the retransmit timeout, use a cancel scope to
place an overall timeout on the handshake, or catch errors from the handshake
specifically.</p>
<p>It's safe to call this multiple times, or call it simultaneously from multiple
tasks – the first call will perform the handshake, and the rest will be no-ops.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>initial_retransmit_timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- <p>Since UDP is an unreliable protocol, it's
possible that some of the packets we send during the handshake will get
lost. To handle this, DTLS uses a timer to automatically retransmit
handshake packets that don't receive a response. This lets you set the
timeout we use to detect packet loss. Ideally, it should be set to ~1.5
times the round-trip time to your peer, but 1 second is a reasonable
default. There's <a class="reference external" href="https://tlswg.org/dtls13-spec/draft-ietf-tls-dtls13.html#name-timer-values">some useful guidance here</a>.</p>
<p>This is the <em>initial</em> timeout, because if packets keep being lost then Trio
will automatically back off to longer values, to avoid overloading the
network.</p>
</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.send">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.send" title="Link to this definition">¶</a></dt>
<dd><p>Send a packet of data, securely.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.receive">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.receive" title="Link to this definition">¶</a></dt>
<dd><p>Fetch the next packet of data from this connection's peer, waiting if
necessary.</p>
<p>This is safe to call from multiple tasks simultaneously, in case you have some
reason to do that. And more importantly, it's cancellation-safe, meaning that
cancelling a call to <cite>receive</cite> will never cause a packet to be lost or corrupt
the underlying connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.close" title="Link to this definition">¶</a></dt>
<dd><p>Close this connection.</p>
<p><cite>DTLSChannel</cite>s don't actually own any OS-level resources – the
socket is owned by the <cite>DTLSEndpoint</cite>, not the individual connections. So
you don't really <em>have</em> to call this. But it will interrupt any other tasks
calling <cite>receive</cite> with a <cite>ClosedResourceError</cite>, and cause future attempts to use
this connection to fail.</p>
<p>You can also use this object as a synchronous or asynchronous context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.aclose">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Close this connection, but asynchronously.</p>
<p>This is included to satisfy the <cite>trio.abc.Channel</cite> contract. It's
identical to <cite>close</cite>, but async.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.set_ciphertext_mtu">
<span class="sig-name descname"><span class="pre">set_ciphertext_mtu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_mtu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.set_ciphertext_mtu" title="Link to this definition">¶</a></dt>
<dd><p>Tells Trio the <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">largest amount of data that can be sent in a single packet to
this peer</a>.</p>
<p>Trio doesn't actually enforce this limit – if you pass a huge packet to <cite>send</cite>,
then we'll dutifully encrypt it and attempt to send it. But calling this method
does have two useful effects:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<ul class="simple">
<li><p>If called before the handshake is performed, then Trio will automatically
fragment handshake messages to fit within the given MTU. It also might
fragment them even smaller, if it detects signs of packet loss, so setting
this should never be necessary to make a successful connection. But, the
packet loss detection only happens after multiple timeouts have expired, so if
you have reason to believe that a smaller MTU is required, then you can set
this to skip those timeouts and establish the connection more quickly.</p></li>
<li><p>It changes the value returned from <cite>get_cleartext_mtu</cite>. So if you have some
kind of estimate of the network-level MTU, then you can use this to figure out
how much overhead DTLS will need for hashes/padding/etc., and how much space
you have left for your application data.</p></li>
</ul>
<p>The MTU here is measuring the largest UDP <em>payload</em> you think can be sent, the
amount of encrypted data that can be handed to the operating system in a single
call to <cite>send</cite>. It should <em>not</em> include IP/UDP headers. Note that OS estimates
of the MTU often are link-layer MTUs, so you have to subtract off 28 bytes on
IPv4 and 48 bytes on IPv6 to get the ciphertext MTU.</p>
<p>By default, Trio assumes an MTU of 1472 bytes on IPv4, and 1452 bytes on IPv6,
which correspond to the common Ethernet MTU of 1500 bytes after accounting for
IP/UDP overhead.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.get_cleartext_mtu">
<span class="sig-name descname"><span class="pre">get_cleartext_mtu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.get_cleartext_mtu" title="Link to this definition">¶</a></dt>
<dd><p>Returns the largest number of bytes that you can pass in a single call to
<cite>send</cite> while still fitting within the network-level MTU.</p>
<p>See <cite>set_ciphertext_mtu</cite> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.DTLSChannel.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannel.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Returns a <cite>DTLSChannelStatistics</cite> object with statistics about this connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.DTLSChannelStatistics" title="trio.DTLSChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">DTLSChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id10">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id10" title="Link to this definition">¶</a></dt>
<dd><p>Close this connection, but asynchronously.</p>
<p>This is included to satisfy the <cite>trio.abc.Channel</cite> contract. It's
identical to <cite>close</cite>, but async.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id11">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id11" title="Link to this definition">¶</a></dt>
<dd><p>Close this connection.</p>
<p><cite>DTLSChannel</cite>s don't actually own any OS-level resources – the
socket is owned by the <cite>DTLSEndpoint</cite>, not the individual connections. So
you don't really <em>have</em> to call this. But it will interrupt any other tasks
calling <cite>receive</cite> with a <cite>ClosedResourceError</cite>, and cause future attempts to use
this connection to fail.</p>
<p>You can also use this object as a synchronous or asynchronous context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id12">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_retransmit_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Link to this definition">¶</a></dt>
<dd><p>Perform the handshake.</p>
<p>Calling this is optional – if you don't, then it will be automatically called
the first time you call <cite>send</cite> or <cite>receive</cite>. But calling it explicitly can be
useful in case you want to control the retransmit timeout, use a cancel scope to
place an overall timeout on the handshake, or catch errors from the handshake
specifically.</p>
<p>It's safe to call this multiple times, or call it simultaneously from multiple
tasks – the first call will perform the handshake, and the rest will be no-ops.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>initial_retransmit_timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- <p>Since UDP is an unreliable protocol, it's
possible that some of the packets we send during the handshake will get
lost. To handle this, DTLS uses a timer to automatically retransmit
handshake packets that don't receive a response. This lets you set the
timeout we use to detect packet loss. Ideally, it should be set to ~1.5
times the round-trip time to your peer, but 1 second is a reasonable
default. There's <a class="reference external" href="https://tlswg.org/dtls13-spec/draft-ietf-tls-dtls13.html#name-timer-values">some useful guidance here</a>.</p>
<p>This is the <em>initial</em> timeout, because if packets keep being lost then Trio
will automatically back off to longer values, to avoid overloading the
network.</p>
</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id13">
<span class="sig-name descname"><span class="pre">get_cleartext_mtu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id13" title="Link to this definition">¶</a></dt>
<dd><p>Returns the largest number of bytes that you can pass in a single call to
<cite>send</cite> while still fitting within the network-level MTU.</p>
<p>See <cite>set_ciphertext_mtu</cite> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id14">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id14" title="Link to this definition">¶</a></dt>
<dd><p>Fetch the next packet of data from this connection's peer, waiting if
necessary.</p>
<p>This is safe to call from multiple tasks simultaneously, in case you have some
reason to do that. And more importantly, it's cancellation-safe, meaning that
cancelling a call to <cite>receive</cite> will never cause a packet to be lost or corrupt
the underlying connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id15">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id15" title="Link to this definition">¶</a></dt>
<dd><p>Send a packet of data, securely.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id16">
<span class="sig-name descname"><span class="pre">set_ciphertext_mtu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_mtu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id16" title="Link to this definition">¶</a></dt>
<dd><p>Tells Trio the <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">largest amount of data that can be sent in a single packet to
this peer</a>.</p>
<p>Trio doesn't actually enforce this limit – if you pass a huge packet to <cite>send</cite>,
then we'll dutifully encrypt it and attempt to send it. But calling this method
does have two useful effects:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<ul class="simple">
<li><p>If called before the handshake is performed, then Trio will automatically
fragment handshake messages to fit within the given MTU. It also might
fragment them even smaller, if it detects signs of packet loss, so setting
this should never be necessary to make a successful connection. But, the
packet loss detection only happens after multiple timeouts have expired, so if
you have reason to believe that a smaller MTU is required, then you can set
this to skip those timeouts and establish the connection more quickly.</p></li>
<li><p>It changes the value returned from <cite>get_cleartext_mtu</cite>. So if you have some
kind of estimate of the network-level MTU, then you can use this to figure out
how much overhead DTLS will need for hashes/padding/etc., and how much space
you have left for your application data.</p></li>
</ul>
<p>The MTU here is measuring the largest UDP <em>payload</em> you think can be sent, the
amount of encrypted data that can be handed to the operating system in a single
call to <cite>send</cite>. It should <em>not</em> include IP/UDP headers. Note that OS estimates
of the MTU often are link-layer MTUs, so you have to subtract off 28 bytes on
IPv4 and 48 bytes on IPv6 to get the ciphertext MTU.</p>
<p>By default, Trio assumes an MTU of 1472 bytes on IPv4, and 1452 bytes on IPv6,
which correspond to the common Ethernet MTU of 1500 bytes after accounting for
IP/UDP overhead.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="id17">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id17" title="Link to this definition">¶</a></dt>
<dd><p>Returns a <cite>DTLSChannelStatistics</cite> object with statistics about this connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.DTLSChannelStatistics" title="trio.DTLSChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">DTLSChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.DTLSChannelStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">DTLSChannelStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">incoming_packets_dropped_in_trio</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.DTLSChannelStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Currently this has only one attribute:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">incoming_packets_dropped_in_trio</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>): Gives a count of the number of
incoming packets from this peer that Trio successfully received from the
network, but then got dropped because the internal channel buffer was full. If
this is non-zero, then you might want to call <code class="docutils literal notranslate"><span class="pre">receive</span></code> more often, or use a
larger <code class="docutils literal notranslate"><span class="pre">incoming_packets_buffer</span></code>, or just not worry about it because your
UDP-based protocol should be able to handle the occasional lost packet, right?</p></li>
</ul>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>Trio also has support for Datagram TLS (DTLS), which is like TLS but
for unreliable UDP connections. This can be useful for applications
where TCP's reliable in-order delivery is problematic, like
teleconferencing, latency-sensitive games, and VPNs.</p>
<p>Currently, using DTLS with Trio requires PyOpenSSL. We hope to
eventually allow the use of the stdlib <cite>ssl</cite> module as well, but
unfortunately that's not yet possible.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Note that PyOpenSSL is in many ways lower-level than the
<cite>ssl</cite> module – in particular, it currently <strong>HAS NO BUILT-IN
MECHANISM TO VALIDATE CERTIFICATES</strong>. We <em>strongly</em> recommend that
you use the <a class="reference external" href="https://pypi.org/project/service-identity/">service-identity</a> library to validate
hostnames and certificates.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">DTLSEndpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incoming_packets_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A DTLS endpoint.</p>
<p>A single UDP socket can handle arbitrarily many DTLS connections simultaneously,
acting as a client or server as needed. A <cite>DTLSEndpoint</cite> object holds a UDP socket
and manages these connections, which are represented as <cite>DTLSChannel</cite> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>socket</strong> (<span class="sphinx_autodoc_typehints-type">SocketType</span>) -- (trio.socket.SocketType): A <code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> socket. If you want to accept
incoming connections in server mode, then you should probably bind the socket to
some known port.</p></li>
<li><p><strong>incoming_packets_buffer</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- Each <cite>DTLSChannel</cite> using this socket has its own
buffer that holds incoming packets until you call <cite>~DTLSChannel.receive</cite> to read
them. This lets you adjust the size of this buffer. <cite>~DTLSChannel.statistics</cite>
lets you check if the buffer has overflowed.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id18">
<span class="sig-name descname"><span class="pre">socket</span></span><a class="headerlink" href="#id18" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="id19">
<span class="sig-name descname"><span class="pre">incoming_packets_buffer</span></span><a class="headerlink" href="#id19" title="Link to this definition">¶</a></dt>
<dd><p>Both constructor arguments are also exposed as attributes, in case you need to
access them later.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Initiate an outgoing DTLS connection.</p>
<p>Notice that this is a synchronous method. That's because it doesn't actually
initiate any I/O – it just sets up a <cite>DTLSChannel</cite> object. The actual handshake
doesn't occur until you start using the <cite>DTLSChannel</cite>. This gives you a chance
to do further configuration first, like setting MTU etc.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<span class="sphinx_autodoc_typehints-type">tuple[str, int]</span>) -- The address to connect to. Usually a (host, port) tuple, like
<code class="docutils literal notranslate"><span class="pre">("127.0.0.1",</span> <span class="pre">12345)</span></code>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
this connection.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">DTLSChannel</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>DTLSChannel</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">serve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">async_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Listen for incoming connections, and spawn a handler for each using an
internal nursery.</p>
<p>Similar to <cite>~trio.serve_tcp</cite>, this function never returns until cancelled, or
the <cite>DTLSEndpoint</cite> is closed and all handlers have exited.</p>
<p>Usage commonly looks like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">dtls_channel</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">nursery</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">dtls_endpoint</span><span class="o">.</span><span class="n">serve</span><span class="p">,</span> <span class="n">ssl_context</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
    <span class="c1"># ... do other things here ...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dtls_channel</span></code> passed into the handler function has already performed the
"cookie exchange" part of the DTLS handshake, so the peer address is
trustworthy. But the actual cryptographic handshake doesn't happen until you
start using it, giving you a chance for any last minute configuration, and the
option to catch and handle handshake errors.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
incoming connections.</p></li>
<li><p><strong>async_fn</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[DTLSChannel, Unpack[PosArgsT]], Awaitable[object]]</span>) -- The handler function that will be invoked for each incoming
connection.</p></li>
<li><p><strong>*args</strong> (<span class="sphinx_autodoc_typehints-type">Unpack[PosArgsT]</span>) -- Additional arguments to pass to the handler function.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this socket, and all associated DTLS connections.</p>
<p>This object can also be used as a context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this socket, and all associated DTLS connections.</p>
<p>This object can also be used as a context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Initiate an outgoing DTLS connection.</p>
<p>Notice that this is a synchronous method. That's because it doesn't actually
initiate any I/O – it just sets up a <cite>DTLSChannel</cite> object. The actual handshake
doesn't occur until you start using the <cite>DTLSChannel</cite>. This gives you a chance
to do further configuration first, like setting MTU etc.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> (<span class="sphinx_autodoc_typehints-type">tuple[str, int]</span>) -- The address to connect to. Usually a (host, port) tuple, like
<code class="docutils literal notranslate"><span class="pre">("127.0.0.1",</span> <span class="pre">12345)</span></code>.</p></li>
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
this connection.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">DTLSChannel</span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>DTLSChannel</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">serve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ssl_context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">async_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TASK_STATUS_IGNORED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Listen for incoming connections, and spawn a handler for each using an
internal nursery.</p>
<p>Similar to <cite>~trio.serve_tcp</cite>, this function never returns until cancelled, or
the <cite>DTLSEndpoint</cite> is closed and all handlers have exited.</p>
<p>Usage commonly looks like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">dtls_channel</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">nursery</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">dtls_endpoint</span><span class="o">.</span><span class="n">serve</span><span class="p">,</span> <span class="n">ssl_context</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
    <span class="c1"># ... do other things here ...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dtls_channel</span></code> passed into the handler function has already performed the
"cookie exchange" part of the DTLS handshake, so the peer address is
trustworthy. But the actual cryptographic handshake doesn't happen until you
start using it, giving you a chance for any last minute configuration, and the
option to catch and handle handshake errors.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="（在 pyOpenSSL v24.2.1）"><em>OpenSSL.SSL.Context</em></a>) -- The PyOpenSSL context object to use for
incoming connections.</p></li>
<li><p><strong>async_fn</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[DTLSChannel, Unpack[PosArgsT]], Awaitable[object]]</span>) -- The handler function that will be invoked for each incoming
connection.</p></li>
<li><p><strong>*args</strong> (<span class="sphinx_autodoc_typehints-type">Unpack[PosArgsT]</span>) -- Additional arguments to pass to the handler function.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">DTLSChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">endpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peer_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Channel</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>]</p>
<p>A DTLS connection.</p>
<p>This class has no public constructor – you get instances by calling
<cite>DTLSEndpoint.serve</cite> or <cite>~DTLSEndpoint.connect</cite>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="id20">
<span class="sig-name descname"><span class="pre">endpoint</span></span><a class="headerlink" href="#id20" title="Link to this definition">¶</a></dt>
<dd><p>The <cite>DTLSEndpoint</cite> that this connection is using.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id21">
<span class="sig-name descname"><span class="pre">peer_address</span></span><a class="headerlink" href="#id21" title="Link to this definition">¶</a></dt>
<dd><p>The IP/port of the remote peer that this connection is associated with.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_retransmit_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform the handshake.</p>
<p>Calling this is optional – if you don't, then it will be automatically called
the first time you call <cite>send</cite> or <cite>receive</cite>. But calling it explicitly can be
useful in case you want to control the retransmit timeout, use a cancel scope to
place an overall timeout on the handshake, or catch errors from the handshake
specifically.</p>
<p>It's safe to call this multiple times, or call it simultaneously from multiple
tasks – the first call will perform the handshake, and the rest will be no-ops.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>initial_retransmit_timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- <p>Since UDP is an unreliable protocol, it's
possible that some of the packets we send during the handshake will get
lost. To handle this, DTLS uses a timer to automatically retransmit
handshake packets that don't receive a response. This lets you set the
timeout we use to detect packet loss. Ideally, it should be set to ~1.5
times the round-trip time to your peer, but 1 second is a reasonable
default. There's <a class="reference external" href="https://tlswg.org/dtls13-spec/draft-ietf-tls-dtls13.html#name-timer-values">some useful guidance here</a>.</p>
<p>This is the <em>initial</em> timeout, because if packets keep being lost then Trio
will automatically back off to longer values, to avoid overloading the
network.</p>
</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a packet of data, securely.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Fetch the next packet of data from this connection's peer, waiting if
necessary.</p>
<p>This is safe to call from multiple tasks simultaneously, in case you have some
reason to do that. And more importantly, it's cancellation-safe, meaning that
cancelling a call to <cite>receive</cite> will never cause a packet to be lost or corrupt
the underlying connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this connection.</p>
<p><cite>DTLSChannel</cite>s don't actually own any OS-level resources – the
socket is owned by the <cite>DTLSEndpoint</cite>, not the individual connections. So
you don't really <em>have</em> to call this. But it will interrupt any other tasks
calling <cite>receive</cite> with a <cite>ClosedResourceError</cite>, and cause future attempts to use
this connection to fail.</p>
<p>You can also use this object as a synchronous or asynchronous context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this connection, but asynchronously.</p>
<p>This is included to satisfy the <cite>trio.abc.Channel</cite> contract. It's
identical to <cite>close</cite>, but async.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_ciphertext_mtu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_mtu</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Tells Trio the <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">largest amount of data that can be sent in a single packet to
this peer</a>.</p>
<p>Trio doesn't actually enforce this limit – if you pass a huge packet to <cite>send</cite>,
then we'll dutifully encrypt it and attempt to send it. But calling this method
does have two useful effects:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<ul class="simple">
<li><p>If called before the handshake is performed, then Trio will automatically
fragment handshake messages to fit within the given MTU. It also might
fragment them even smaller, if it detects signs of packet loss, so setting
this should never be necessary to make a successful connection. But, the
packet loss detection only happens after multiple timeouts have expired, so if
you have reason to believe that a smaller MTU is required, then you can set
this to skip those timeouts and establish the connection more quickly.</p></li>
<li><p>It changes the value returned from <cite>get_cleartext_mtu</cite>. So if you have some
kind of estimate of the network-level MTU, then you can use this to figure out
how much overhead DTLS will need for hashes/padding/etc., and how much space
you have left for your application data.</p></li>
</ul>
<p>The MTU here is measuring the largest UDP <em>payload</em> you think can be sent, the
amount of encrypted data that can be handed to the operating system in a single
call to <cite>send</cite>. It should <em>not</em> include IP/UDP headers. Note that OS estimates
of the MTU often are link-layer MTUs, so you have to subtract off 28 bytes on
IPv4 and 48 bytes on IPv6 to get the ciphertext MTU.</p>
<p>By default, Trio assumes an MTU of 1472 bytes on IPv4, and 1452 bytes on IPv6,
which correspond to the common Ethernet MTU of 1500 bytes after accounting for
IP/UDP overhead.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_cleartext_mtu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the largest number of bytes that you can pass in a single call to
<cite>send</cite> while still fitting within the network-level MTU.</p>
<p>See <cite>set_ciphertext_mtu</cite> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a <cite>DTLSChannelStatistics</cite> object with statistics about this connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.DTLSChannelStatistics" title="trio.DTLSChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">DTLSChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this connection, but asynchronously.</p>
<p>This is included to satisfy the <cite>trio.abc.Channel</cite> contract. It's
identical to <cite>close</cite>, but async.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close this connection.</p>
<p><cite>DTLSChannel</cite>s don't actually own any OS-level resources – the
socket is owned by the <cite>DTLSEndpoint</cite>, not the individual connections. So
you don't really <em>have</em> to call this. But it will interrupt any other tasks
calling <cite>receive</cite> with a <cite>ClosedResourceError</cite>, and cause future attempts to use
this connection to fail.</p>
<p>You can also use this object as a synchronous or asynchronous context manager.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_retransmit_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform the handshake.</p>
<p>Calling this is optional – if you don't, then it will be automatically called
the first time you call <cite>send</cite> or <cite>receive</cite>. But calling it explicitly can be
useful in case you want to control the retransmit timeout, use a cancel scope to
place an overall timeout on the handshake, or catch errors from the handshake
specifically.</p>
<p>It's safe to call this multiple times, or call it simultaneously from multiple
tasks – the first call will perform the handshake, and the rest will be no-ops.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>initial_retransmit_timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- <p>Since UDP is an unreliable protocol, it's
possible that some of the packets we send during the handshake will get
lost. To handle this, DTLS uses a timer to automatically retransmit
handshake packets that don't receive a response. This lets you set the
timeout we use to detect packet loss. Ideally, it should be set to ~1.5
times the round-trip time to your peer, but 1 second is a reasonable
default. There's <a class="reference external" href="https://tlswg.org/dtls13-spec/draft-ietf-tls-dtls13.html#name-timer-values">some useful guidance here</a>.</p>
<p>This is the <em>initial</em> timeout, because if packets keep being lost then Trio
will automatically back off to longer values, to avoid overloading the
network.</p>
</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_cleartext_mtu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the largest number of bytes that you can pass in a single call to
<cite>send</cite> while still fitting within the network-level MTU.</p>
<p>See <cite>set_ciphertext_mtu</cite> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">receive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Fetch the next packet of data from this connection's peer, waiting if
necessary.</p>
<p>This is safe to call from multiple tasks simultaneously, in case you have some
reason to do that. And more importantly, it's cancellation-safe, meaning that
cancelling a call to <cite>receive</cite> will never cause a packet to be lost or corrupt
the underlying connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a packet of data, securely.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_ciphertext_mtu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_mtu</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Tells Trio the <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">largest amount of data that can be sent in a single packet to
this peer</a>.</p>
<p>Trio doesn't actually enforce this limit – if you pass a huge packet to <cite>send</cite>,
then we'll dutifully encrypt it and attempt to send it. But calling this method
does have two useful effects:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
<ul class="simple">
<li><p>If called before the handshake is performed, then Trio will automatically
fragment handshake messages to fit within the given MTU. It also might
fragment them even smaller, if it detects signs of packet loss, so setting
this should never be necessary to make a successful connection. But, the
packet loss detection only happens after multiple timeouts have expired, so if
you have reason to believe that a smaller MTU is required, then you can set
this to skip those timeouts and establish the connection more quickly.</p></li>
<li><p>It changes the value returned from <cite>get_cleartext_mtu</cite>. So if you have some
kind of estimate of the network-level MTU, then you can use this to figure out
how much overhead DTLS will need for hashes/padding/etc., and how much space
you have left for your application data.</p></li>
</ul>
<p>The MTU here is measuring the largest UDP <em>payload</em> you think can be sent, the
amount of encrypted data that can be handed to the operating system in a single
call to <cite>send</cite>. It should <em>not</em> include IP/UDP headers. Note that OS estimates
of the MTU often are link-layer MTUs, so you have to subtract off 28 bytes on
IPv4 and 48 bytes on IPv6 to get the ciphertext MTU.</p>
<p>By default, Trio assumes an MTU of 1472 bytes on IPv4, and 1452 bytes on IPv6,
which correspond to the common Ethernet MTU of 1500 bytes after accounting for
IP/UDP overhead.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a <cite>DTLSChannelStatistics</cite> object with statistics about this connection.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.DTLSChannelStatistics" title="trio.DTLSChannelStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">DTLSChannelStatistics</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.</span></span><span class="sig-name descname"><span class="pre">DTLSChannelStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">incoming_packets_dropped_in_trio</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Currently this has only one attribute:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">incoming_packets_dropped_in_trio</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>): Gives a count of the number of
incoming packets from this peer that Trio successfully received from the
network, but then got dropped because the internal channel buffer was full. If
this is non-zero, then you might want to call <code class="docutils literal notranslate"><span class="pre">receive</span></code> more often, or use a
larger <code class="docutils literal notranslate"><span class="pre">incoming_packets_buffer</span></code>, or just not worry about it because your
UDP-based protocol should be able to handle the occasional lost packet, right?</p></li>
</ul>
</dd></dl>
</div>
</div>
</section>
</section>
</article>
</div>
<footer>
<div class="related-pages">
<a class="next-page" href="low_level.html">
<div class="page-info">
<div class="context">
<span>Next</span>
</div>
<div class="title">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code> 进行低级网络编程</div>
</div>
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
</a>
<a class="prev-page" href="index.html">
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
<div class="page-info">
<div class="context">
<span>Previous</span>
</div>
<div class="title">Trio 中的 I/O</div>
</div>
</a>
</div>
<div class="bottom-of-page">
<div class="left-details">
<div class="copyright">
                Copyright © 2017, Nathaniel J. Smith
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
</div>
<div class="right-details">
<div class="icons">
<a aria-label="GitHub" class="muted-link" href="https://github.com/hellowac/trio-zh-cn">
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 16 16">
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill-rule="evenodd"></path>
</svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<aside class="toc-drawer">
<div class="toc-sticky toc-scroll">
<div class="toc-title-container">
<span class="toc-title">
            On this page
          </span>
</div>
<div class="toc-tree-container">
<div class="toc-tree">
<ul>
<li><a class="reference internal" href="#">抽象流 API</a><ul>
<li><a class="reference internal" href="#id1">抽象基类</a><ul>
<li><a class="reference internal" href="#trio.abc.AsyncResource"><code class="docutils literal notranslate"><span class="pre">AsyncResource</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.AsyncResource.aclose"><code class="docutils literal notranslate"><span class="pre">AsyncResource.aclose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.aclose_forcefully"><code class="docutils literal notranslate"><span class="pre">aclose_forcefully()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.SendStream"><code class="docutils literal notranslate"><span class="pre">SendStream</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.SendStream.send_all"><code class="docutils literal notranslate"><span class="pre">SendStream.send_all()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block"><code class="docutils literal notranslate"><span class="pre">SendStream.wait_send_all_might_not_block()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.abc.ReceiveStream"><code class="docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.ReceiveStream.receive_some"><code class="docutils literal notranslate"><span class="pre">ReceiveStream.receive_some()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.abc.Stream"><code class="docutils literal notranslate"><span class="pre">Stream</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.HalfCloseableStream"><code class="docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.HalfCloseableStream.send_eof"><code class="docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.abc.Listener"><code class="docutils literal notranslate"><span class="pre">Listener</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.Listener.accept"><code class="docutils literal notranslate"><span class="pre">Listener.accept()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.abc.SendChannel"><code class="docutils literal notranslate"><span class="pre">SendChannel</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.SendChannel.send"><code class="docutils literal notranslate"><span class="pre">SendChannel.send()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.abc.ReceiveChannel"><code class="docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.ReceiveChannel.receive"><code class="docutils literal notranslate"><span class="pre">ReceiveChannel.receive()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.abc.Channel"><code class="docutils literal notranslate"><span class="pre">Channel</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">通用流工具</a><ul>
<li><a class="reference internal" href="#trio.serve_listeners"><code class="docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream"><code class="docutils literal notranslate"><span class="pre">StapledStream</span></code></a><ul>
<li><a class="reference internal" href="#trio.StapledStream.send_stream"><code class="docutils literal notranslate"><span class="pre">StapledStream.send_stream</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream.receive_stream"><code class="docutils literal notranslate"><span class="pre">StapledStream.receive_stream</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream.aclose"><code class="docutils literal notranslate"><span class="pre">StapledStream.aclose()</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream.receive_some"><code class="docutils literal notranslate"><span class="pre">StapledStream.receive_some()</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream.send_all"><code class="docutils literal notranslate"><span class="pre">StapledStream.send_all()</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream.send_eof"><code class="docutils literal notranslate"><span class="pre">StapledStream.send_eof()</span></code></a></li>
<li><a class="reference internal" href="#trio.StapledStream.wait_send_all_might_not_block"><code class="docutils literal notranslate"><span class="pre">StapledStream.wait_send_all_might_not_block()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">StapledStream.send_stream</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">StapledStream.receive_stream</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#high-level-networking">套接字和网络</a><ul>
<li><a class="reference internal" href="#trio.open_tcp_stream"><code class="docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a></li>
<li><a class="reference internal" href="#trio.serve_tcp"><code class="docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a></li>
<li><a class="reference internal" href="#trio.open_ssl_over_tcp_stream"><code class="docutils literal notranslate"><span class="pre">open_ssl_over_tcp_stream()</span></code></a></li>
<li><a class="reference internal" href="#trio.serve_ssl_over_tcp"><code class="docutils literal notranslate"><span class="pre">serve_ssl_over_tcp()</span></code></a></li>
<li><a class="reference internal" href="#trio.open_unix_socket"><code class="docutils literal notranslate"><span class="pre">open_unix_socket()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream"><code class="docutils literal notranslate"><span class="pre">SocketStream</span></code></a><ul>
<li><a class="reference internal" href="#trio.SocketStream.socket"><code class="docutils literal notranslate"><span class="pre">SocketStream.socket</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.aclose"><code class="docutils literal notranslate"><span class="pre">SocketStream.aclose()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.getsockopt"><code class="docutils literal notranslate"><span class="pre">SocketStream.getsockopt()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.receive_some"><code class="docutils literal notranslate"><span class="pre">SocketStream.receive_some()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.send_all"><code class="docutils literal notranslate"><span class="pre">SocketStream.send_all()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.send_eof"><code class="docutils literal notranslate"><span class="pre">SocketStream.send_eof()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.setsockopt"><code class="docutils literal notranslate"><span class="pre">SocketStream.setsockopt()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketStream.wait_send_all_might_not_block"><code class="docutils literal notranslate"><span class="pre">SocketStream.wait_send_all_might_not_block()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.SocketListener"><code class="docutils literal notranslate"><span class="pre">SocketListener</span></code></a><ul>
<li><a class="reference internal" href="#trio.SocketListener.socket"><code class="docutils literal notranslate"><span class="pre">SocketListener.socket</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketListener.accept"><code class="docutils literal notranslate"><span class="pre">SocketListener.accept()</span></code></a></li>
<li><a class="reference internal" href="#trio.SocketListener.aclose"><code class="docutils literal notranslate"><span class="pre">SocketListener.aclose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.open_tcp_listeners"><code class="docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a></li>
<li><a class="reference internal" href="#trio.open_ssl_over_tcp_listeners"><code class="docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">SocketStream.socket</span></code></a></li>
<li><a class="reference internal" href="#id6"><code class="docutils literal notranslate"><span class="pre">SocketListener.socket</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-tls">SSL / TLS 支持</a><ul>
<li><a class="reference internal" href="#trio.SSLStream"><code class="docutils literal notranslate"><span class="pre">SSLStream</span></code></a><ul>
<li><a class="reference internal" href="#trio.SSLStream.transport_stream"><code class="docutils literal notranslate"><span class="pre">SSLStream.transport_stream</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLStream.aclose"><code class="docutils literal notranslate"><span class="pre">SSLStream.aclose()</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLStream.do_handshake"><code class="docutils literal notranslate"><span class="pre">SSLStream.do_handshake()</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLStream.receive_some"><code class="docutils literal notranslate"><span class="pre">SSLStream.receive_some()</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLStream.send_all"><code class="docutils literal notranslate"><span class="pre">SSLStream.send_all()</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLStream.unwrap"><code class="docutils literal notranslate"><span class="pre">SSLStream.unwrap()</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLStream.wait_send_all_might_not_block"><code class="docutils literal notranslate"><span class="pre">SSLStream.wait_send_all_might_not_block()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.SSLListener"><code class="docutils literal notranslate"><span class="pre">SSLListener</span></code></a><ul>
<li><a class="reference internal" href="#trio.SSLListener.transport_listener"><code class="docutils literal notranslate"><span class="pre">SSLListener.transport_listener</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLListener.accept"><code class="docutils literal notranslate"><span class="pre">SSLListener.accept()</span></code></a></li>
<li><a class="reference internal" href="#trio.SSLListener.aclose"><code class="docutils literal notranslate"><span class="pre">SSLListener.aclose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.NeedHandshakeError"><code class="docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#tls">数据报 TLS 支持</a><ul>
<li><a class="reference internal" href="#trio.DTLSEndpoint"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint</span></code></a><ul>
<li><a class="reference internal" href="#trio.DTLSEndpoint.socket"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.socket</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSEndpoint.incoming_packets_buffer"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.incoming_packets_buffer</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSEndpoint.connect"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.connect()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSEndpoint.serve"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.serve()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSEndpoint.close"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.close()</span></code></a></li>
<li><a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.close()</span></code></a></li>
<li><a class="reference internal" href="#id8"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.connect()</span></code></a></li>
<li><a class="reference internal" href="#id9"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.serve()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.DTLSChannel"><code class="docutils literal notranslate"><span class="pre">DTLSChannel</span></code></a><ul>
<li><a class="reference internal" href="#trio.DTLSChannel.endpoint"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.endpoint</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.peer_address"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.peer_address</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.do_handshake"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.do_handshake()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.send"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.send()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.receive"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.receive()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.close"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.close()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.aclose"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.aclose()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.set_ciphertext_mtu"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.set_ciphertext_mtu()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.get_cleartext_mtu"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.get_cleartext_mtu()</span></code></a></li>
<li><a class="reference internal" href="#trio.DTLSChannel.statistics"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.statistics()</span></code></a></li>
<li><a class="reference internal" href="#id10"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.aclose()</span></code></a></li>
<li><a class="reference internal" href="#id11"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.close()</span></code></a></li>
<li><a class="reference internal" href="#id12"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.do_handshake()</span></code></a></li>
<li><a class="reference internal" href="#id13"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.get_cleartext_mtu()</span></code></a></li>
<li><a class="reference internal" href="#id14"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.receive()</span></code></a></li>
<li><a class="reference internal" href="#id15"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.send()</span></code></a></li>
<li><a class="reference internal" href="#id16"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.set_ciphertext_mtu()</span></code></a></li>
<li><a class="reference internal" href="#id17"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.statistics()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.DTLSChannelStatistics"><code class="docutils literal notranslate"><span class="pre">DTLSChannelStatistics</span></code></a></li>
<li><a class="reference internal" href="#id18"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.socket</span></code></a></li>
<li><a class="reference internal" href="#id19"><code class="docutils literal notranslate"><span class="pre">DTLSEndpoint.incoming_packets_buffer</span></code></a></li>
<li><a class="reference internal" href="#id20"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.endpoint</span></code></a></li>
<li><a class="reference internal" href="#id21"><code class="docutils literal notranslate"><span class="pre">DTLSChannel.peer_address</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</aside>
</div>
</div><script src="../_static/documentation_options.js?v=d2451d57"></script>
<script src="../_static/doctools.js?v=9bcbadda"></script>
<script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
<script src="../_static/scripts/furo.js?v=5fa4622c"></script>
<script src="../_static/tabs.js?v=3ee01567"></script>
<script src="../_static/clipboard.min.js?v=a7894cd8"></script>
<script src="../_static/copybutton.js?v=f281be69"></script>
<script src="../_static/translations.js?v=beaddf03"></script>
</body>
</html>