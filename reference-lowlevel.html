<!DOCTYPE html>

<html class="no-js" data-content_root="./" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="light dark" name="color-scheme"/><meta content="width=device-width, initial-scale=1" name="viewport">
<link href="genindex.html" rel="index" title="索引"/><link href="search.html" rel="search" title="搜索"/><link href="design.html" rel="next" title="设计和内部结构"/><link href="reference-testing.html" rel="prev" title="Trio 中的测试"/>
<link href="_static/favicon-32.png" rel="shortcut icon"/><!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
<title>自省和扩展 Trio - Trio 0.27.0+dev 文档</title>
<link href="_static/pygments.css?v=fa44fd50" rel="stylesheet" type="text/css"/>
<link href="_static/styles/furo.css?v=354aac6f" rel="stylesheet" type="text/css"/>
<link href="_static/sphinx-codeautolink.css?v=125d5c1c" rel="stylesheet" type="text/css"/>
<link href="_static/tabs.css?v=4c969af8" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css?v=76b2166b" rel="stylesheet" type="text/css"/>
<link href="_static/hackrtd.css?v=2d9fc201" rel="stylesheet" type="text/css"/>
<link href="_static/styles/furo-extensions.css?v=302659d7" rel="stylesheet" type="text/css"/>
<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></meta></head>
<body>
<script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<symbol id="svg-toc" viewbox="0 0 24 24">
<title>Contents</title>
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 1024 1024">
<path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"></path>
</svg>
</symbol>
<symbol id="svg-menu" viewbox="0 0 24 24">
<title>Menu</title>
<svg class="feather-menu" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<line x1="3" x2="21" y1="12" y2="12"></line>
<line x1="3" x2="21" y1="6" y2="6"></line>
<line x1="3" x2="21" y1="18" y2="18"></line>
</svg>
</symbol>
<symbol id="svg-arrow-right" viewbox="0 0 24 24">
<title>Expand</title>
<svg class="feather-chevron-right" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<polyline points="9 18 15 12 9 6"></polyline>
</svg>
</symbol>
<symbol id="svg-sun" viewbox="0 0 24 24">
<title>Light mode</title>
<svg class="feather-sun" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="5"></circle>
<line x1="12" x2="12" y1="1" y2="3"></line>
<line x1="12" x2="12" y1="21" y2="23"></line>
<line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line>
<line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line>
<line x1="1" x2="3" y1="12" y2="12"></line>
<line x1="21" x2="23" y1="12" y2="12"></line>
<line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line>
<line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>
</svg>
</symbol>
<symbol id="svg-moon" viewbox="0 0 24 24">
<title>Dark mode</title>
<svg class="icon-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
</svg>
</symbol>
<symbol id="svg-sun-with-moon" viewbox="0 0 24 24">
<title>Auto light/dark, in light mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z" style="opacity: 50%"></path>
<line x1="14.5" x2="14.5" y1="3.25" y2="1.25"></line>
<line x1="14.5" x2="14.5" y1="15.85" y2="17.85"></line>
<line x1="10.044" x2="8.63" y1="5.094" y2="3.68"></line>
<line x1="19" x2="20.414" y1="14.05" y2="15.464"></line>
<line x1="8.2" x2="6.2" y1="9.55" y2="9.55"></line>
<line x1="20.8" x2="22.8" y1="9.55" y2="9.55"></line>
<line x1="10.044" x2="8.63" y1="14.006" y2="15.42"></line>
<line x1="19" x2="20.414" y1="5.05" y2="3.636"></line>
<circle cx="14.5" cy="9.55" r="3.6"></circle>
</svg>
</symbol>
<symbol id="svg-moon-with-sun" viewbox="0 0 24 24">
<title>Auto light/dark, in dark mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"></path>
<line style="opacity: 50%" x1="18" x2="18" y1="3.705" y2="2.5"></line>
<line style="opacity: 50%" x1="18" x2="18" y1="11.295" y2="12.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="4.816" y2="3.964"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="10.212" y2="11.063"></line>
<line style="opacity: 50%" x1="14.205" x2="13.001" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="21.795" x2="23" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="10.184" y2="11.036"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="4.789" y2="3.937"></line>
<circle cx="18" cy="7.5" r="2.169" style="opacity: 50%"></circle>
</svg>
</symbol>
<symbol id="svg-pencil" viewbox="0 0 24 24">
<svg class="icon-tabler-pencil-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4"></path>
<path d="M13.5 6.5l4 4"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
<symbol id="svg-eye" viewbox="0 0 24 24">
<svg class="icon-tabler-eye-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0"></path>
<path d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
</svg>
<input class="sidebar-toggle" id="__navigation" name="__navigation" type="checkbox"/>
<input class="sidebar-toggle" id="__toc" name="__toc" type="checkbox"/>
<label class="overlay sidebar-overlay" for="__navigation">
<div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
<div class="visually-hidden">Hide table of contents sidebar</div>
</label>
<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>
<div class="page">
<header class="mobile-header">
<div class="header-left">
<label class="nav-overlay-icon" for="__navigation">
<div class="visually-hidden">Toggle site navigation sidebar</div>
<i class="icon"><svg><use href="#svg-menu"></use></svg></i>
</label>
</div>
<div class="header-center">
<a href="index.html"><div class="brand">Trio 0.27.0+dev 文档</div></a>
</div>
<div class="header-right">
<div class="theme-toggle-container theme-toggle-header">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-header-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
</header>
<aside class="sidebar-drawer">
<div class="sidebar-container">
<div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
<div class="sidebar-logo-container">
<img alt="Logo" class="sidebar-logo" src="_static/wordmark-transparent.svg"/>
</div>
<span class="sidebar-brand-text">Trio 0.27.0+dev 文档</span>
</a><form action="search.html" class="sidebar-search-container" method="get" role="search">
<input aria-label="搜索" class="sidebar-search" name="q" placeholder="搜索"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
<p class="caption" role="heading"><span class="caption-text">Trio 友好且全面的手册：</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="awesome-trio-libraries.html">超棒的 Trio 库</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="ref-core/index.html">Trio 的核心功能</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Trio 的核心功能</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="ref-core/run.html">运行 Trio</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/general_principles.html">一般原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/time_clock.html">时间和时钟</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/cancel_timeout.html">取消和超时</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/tasks.html">任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/task_local_storeage.html">任务存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/task_sync.html">任务同步和通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/note_async_generator.html">异步生成器注意事项</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/threads.html">线程（如果必须）</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/debugging.html">交互式调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/exc_warn.html">异常和警告</a></li>
</ul>
</input></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="ref-io/index.html">Trio 中的 I/O</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Trio 中的 I/O</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="ref-io/abs_api.html">抽象流 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/low_level.html">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code> 进行低级网络编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/async_file_io.html">异步文件系统 I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/subprocess.html">生成子进程</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/signals.html">信号</a></li>
</ul>
</input></li>
<li class="toctree-l1"><a class="reference internal" href="reference-testing.html">Trio 中的测试</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">自省和扩展 Trio</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">设计和内部结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">发布历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">为 Trio 及相关项目做出贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="releasing.html">准备发布</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-of-conduct.html">行为守则</a></li>
</ul>
</div>
</div>
</div>
</div>
</aside>
<div class="main">
<div class="content">
<div class="article-container">
<a class="back-to-top muted-link" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
</svg>
<span>Back to top</span>
</a>
<div class="content-icon-container">
<div class="view-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/blob/sync-docs/cn_docs/source/reference-lowlevel.rst?plain=true" title="View this page">
<svg><use href="#svg-eye"></use></svg>
<span class="visually-hidden">View this page</span>
</a>
</div><div class="edit-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/edit/sync-docs/cn_docs/source/reference-lowlevel.rst" title="Edit this page">
<svg><use href="#svg-pencil"></use></svg>
<span class="visually-hidden">Edit this page</span>
</a>
</div><div class="theme-toggle-container theme-toggle-content">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-content-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
<article id="furo-main-content" role="main">
<section id="trio">
<h1>自省和扩展 Trio<a class="headerlink" href="#trio" title="Link to this heading">¶</a></h1>
<p><strong>Introspecting and extending Trio with</strong> <code class="docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> 包含了用于检查和扩展 Trio 的低级 API。如果你正在编写普通的日常代码，那么可以完全忽略这个模块。但有时你可能需要一些更低级的操作。以下是一些你应该使用 <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> 的情况示例：</p>
<ul class="simple">
<li><p>你想实现 Trio 尚未（但可能未来会）提供的新的 <a class="reference internal" href="ref-core/task_sync.html#synchronization"><span class="std std-ref">同步原语</span></a>，比如读写锁。</p></li>
<li><p>你想提取低级别的指标来监控应用程序的健康状况。</p></li>
<li><p>你想使用 Trio 尚未（但可能未来会）提供自己封装的低级操作系统接口，比如监听文件系统目录的变化。</p></li>
<li><p>你想实现一个接口，在同一进程中调用 Trio 和另一个事件循环。</p></li>
<li><p>你正在编写调试器，并希望可视化 Trio 的任务树。</p></li>
<li><p>你需要与暴露原始文件描述符的 C 库进行互操作。</p></li>
</ul>
<p>只要你采取适当的预防措施，你不需要害怕 <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>。这些是真正的公共 API，具有严格定义和仔细文档化的语义。它们是我们用来实现 <a class="reference internal" href="ref-core/time_clock.html#module-trio" title="trio"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio</span></code></a> 命名空间中所有漂亮的高级 API 的工具。但要小心。一些严格的语义有 <a class="reference external" href="https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog">可怕的大尖牙</a> 。如果你犯了错误，Trio 可能无法优雅地处理它；在 Trio 的其他部分严格遵循的约定和保证在这里不一定适用。当你使用这个模块时，必须思考如何处理棘手的情况，从而为你的用户暴露一个友好的 Trio 风格 API。</p>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> contains low-level APIs for introspecting and
extending Trio. If you're writing ordinary, everyday code, then you
can ignore this module completely. But sometimes you need something a
bit lower level. Here are some examples of situations where you should
reach for <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>:</p>
<ul class="simple">
<li><p>You want to implement a new <a class="reference internal" href="ref-core/task_sync.html#synchronization"><span class="std std-ref">synchronization primitive</span></a> that Trio doesn't (yet) provide, like a reader-writer lock.</p></li>
<li><p>You want to extract low-level metrics to monitor the health of your application.</p></li>
<li><p>You want to use a low-level operating system interface that Trio doesn't (yet) provide its own wrappers for, like watching a filesystem directory for changes.</p></li>
<li><p>You want to implement an interface for calling between Trio and another event loop within the same process.</p></li>
<li><p>You're writing a debugger and want to visualize Trio's task tree.</p></li>
<li><p>You need to interoperate with a C library whose API exposes raw file descriptors.</p></li>
</ul>
<p>You don't need to be scared of <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>, as long as you
take proper precautions. These are real public APIs, with strictly
defined and carefully documented semantics. They're the same tools we
use to implement all the nice high-level APIs in the <a class="reference internal" href="ref-core/time_clock.html#module-trio" title="trio"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio</span></code></a>
namespace. But, be careful. Some of those strict semantics have <a class="reference external" href="https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog">nasty
big pointy teeth</a>. If you make a
mistake, Trio may not be able to handle it gracefully; conventions and
guarantees that are followed strictly in the rest of Trio do not
always apply. When you use this module, it's your job to think about
how you're going to handle the tricky cases so you can expose a
friendly Trio-style API to your users.</p>
</div>
</div>
<section id="id1">
<h2>调试和检测<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p><strong>Debugging and instrumentation</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 努力提供有用的钩子用于调试和检测。上面记录了一些（nursery <a class="reference internal" href="#instrumentation"><span class="std std-ref">自省属性</span></a> 、<a class="reference internal" href="ref-core/task_sync.html#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Lock.statistics()</span></code></a> 等）。这里还有一些。</p>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<p>Trio tries hard to provide useful hooks for debugging and
instrumentation. Some are documented above (the nursery introspection
attributes, <a class="reference internal" href="ref-core/task_sync.html#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Lock.statistics()</span></code></a>, etc.). Here are some more.</p>
</div>
</div>
<section id="id2">
<h3>全局统计<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<p><strong>Global statistics</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_statistics">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#trio.lowlevel.RunStatistics" title="trio.lowlevel.RunStatistics"><span class="pre">RunStatistics</span></a></span></span><a class="headerlink" href="#trio.lowlevel.current_statistics" title="Link to this definition">¶</a></dt>
<dd><p>返回包含运行循环级别调试信息的对象：</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.RunStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">RunStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tasks_living</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_runnable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seconds_to_next_deadline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">io_statistics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_sync_soon_queue_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.RunStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing run-loop-level debugging information.</p>
<p>Currently, the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_living</span></code> (int): The number of tasks that have been spawned
and not yet exited.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_runnable</span></code> (int): The number of tasks that are currently
queued on the run queue (as opposed to blocked waiting for something
to happen).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seconds_to_next_deadline</span></code> (float): The time until the next
pending cancel scope deadline. May be negative if the deadline has
expired but we haven't yet processed cancellations. May be
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/math.html#math.inf" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">inf</span></code></a> if there are no pending deadlines.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run_sync_soon_queue_size</span></code> (int): The number of
unprocessed callbacks queued via
<a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.lowlevel.TrioToken.run_sync_soon()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">io_statistics</span></code> (object): Some statistics from Trio's I/O
backend. This always has an attribute <code class="docutils literal notranslate"><span class="pre">backend</span></code> which is a string
naming which operating-system-specific I/O backend is in use; the
other attributes vary between backends.</p></li>
</ul>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#trio.lowlevel.RunStatistics" title="trio.lowlevel.RunStatistics"><span class="pre">RunStatistics</span></a></span></span></dt>
<dd><p>Returns an object containing run-loop-level debugging information:</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">RunStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tasks_living</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tasks_runnable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seconds_to_next_deadline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">io_statistics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_sync_soon_queue_size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing run-loop-level debugging information.</p>
<p>Currently, the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_living</span></code> (int): The number of tasks that have been spawned
and not yet exited.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_runnable</span></code> (int): The number of tasks that are currently
queued on the run queue (as opposed to blocked waiting for something
to happen).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seconds_to_next_deadline</span></code> (float): The time until the next
pending cancel scope deadline. May be negative if the deadline has
expired but we haven't yet processed cancellations. May be
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/math.html#math.inf" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">inf</span></code></a> if there are no pending deadlines.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run_sync_soon_queue_size</span></code> (int): The number of
unprocessed callbacks queued via
<a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.lowlevel.TrioToken.run_sync_soon()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">io_statistics</span></code> (object): Some statistics from Trio's I/O
backend. This always has an attribute <code class="docutils literal notranslate"><span class="pre">backend</span></code> which is a string
naming which operating-system-specific I/O backend is in use; the
other attributes vary between backends.</p></li>
</ul>
</dd></dl>
</div>
</div>
</section>
<section id="id3">
<h3>当前时钟<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<p><strong>The current clock</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_clock">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_clock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.current_clock" title="Link to this definition">¶</a></dt>
<dd><p>Returns the current <a class="reference internal" href="ref-core/time_clock.html#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">Clock</span></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="api">
<span id="instrumentation"></span><h3>工具 API<a class="headerlink" href="#api" title="Link to this heading">¶</a></h3>
<p><strong>Instrument API</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p>instrument API 提供了一种标准方式，可以将自定义的监控工具添加到运行循环中。想要制作一个调度延迟的直方图，记录任何阻塞运行循环超过 50 毫秒的任务的堆栈跟踪，或者测量进程运行时间中有多少百分比用于等待 I/O 吗？这里就是你需要的地方。</p>
<p>一般来说，在任何给定时刻，<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 都维护着一组“监控工具”，它们是实现了 <a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Instrument</span></code></a> 接口的对象。当发生有趣的事件时，它会遍历这些监控工具，并通过调用适当的方法来通知它们。教程中有一个 <a class="reference internal" href="tutorial.html#tutorial-instrument-example"><span class="std std-ref">使用它进行追踪的简单示例</span></a>。</p>
<p>由于这在较低级别上钩入了 Trio，因此你必须小心。回调是同步运行的，在许多情况下，如果它们出错，可能没有合理的方式传播这个异常（例如，我们可能已经深入到异常传播机制的内部……）。因此，我们当前的 <a class="reference external" href="https://github.com/python-trio/trio/issues/47">策略</a> 是 (a) 将异常记录到 <code class="docutils literal notranslate"><span class="pre">"trio.abc.Instrument"</span></code> 日志中，默认情况下会将堆栈跟踪打印到标准错误，并且 (b) 禁用引起问题的监控工具。</p>
<p>你可以通过将监控工具传递给 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 来注册初始的监控工具列表。<a class="reference internal" href="#trio.lowlevel.add_instrument" title="trio.lowlevel.add_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_instrument()</span></code></a> 和 <a class="reference internal" href="#trio.lowlevel.remove_instrument" title="trio.lowlevel.remove_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_instrument()</span></code></a> 允许你在运行时添加和移除监控工具。</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.add_instrument">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">add_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.add_instrument" title="Link to this definition">¶</a></dt>
<dd><p>Start instrumenting the current run loop with the given instrument.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instrument</strong> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) -- The instrument to activate.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">instrument</span></code> is already active, does nothing.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.remove_instrument">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">remove_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.remove_instrument" title="Link to this definition">¶</a></dt>
<dd><p>Stop instrumenting the current run loop with the given instrument.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instrument</strong> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) -- The instrument to de-activate.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="（在 Python v3.13）"><strong>KeyError</strong></a> -- if the instrument is not currently active. This could
    occur either because you never added it, or because you added it
    and then it raised an unhandled exception and was automatically
    deactivated.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<p>如果你想构建自己的 <a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></a>，下面是你需要实现的接口：</p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.abc.Instrument">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">Instrument</span></span><a class="headerlink" href="#trio.abc.Instrument" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/abc.html#abc.ABC" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></a></p>
<p>The interface for run loop instrumentation.</p>
<p>Instruments don't have to inherit from this abstract base class, and all
of these methods are optional. This class serves mostly as documentation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.after_io_wait">
<span class="sig-name descname"><span class="pre">after_io_wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.after_io_wait" title="Link to this definition">¶</a></dt>
<dd><p>Called after handling pending I/O.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- The number of seconds we were willing to
wait. This much time may or may not have elapsed, depending on
whether any I/O was ready.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.after_run">
<span class="sig-name descname"><span class="pre">after_run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.after_run" title="Link to this definition">¶</a></dt>
<dd><p>Called just before <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> returns.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.after_task_step">
<span class="sig-name descname"><span class="pre">after_task_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.after_task_step" title="Link to this definition">¶</a></dt>
<dd><p>Called when we return to the main run loop after a task has yielded.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The task that just ran.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.before_io_wait">
<span class="sig-name descname"><span class="pre">before_io_wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.before_io_wait" title="Link to this definition">¶</a></dt>
<dd><p>Called before blocking to wait for I/O readiness.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- The number of seconds we are willing to wait.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.before_run">
<span class="sig-name descname"><span class="pre">before_run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.before_run" title="Link to this definition">¶</a></dt>
<dd><p>Called at the beginning of <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.before_task_step">
<span class="sig-name descname"><span class="pre">before_task_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.before_task_step" title="Link to this definition">¶</a></dt>
<dd><p>Called immediately before we resume running the given task.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The task that is about to run.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.task_exited">
<span class="sig-name descname"><span class="pre">task_exited</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.task_exited" title="Link to this definition">¶</a></dt>
<dd><p>Called when the given task exits.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The finished task.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.task_scheduled">
<span class="sig-name descname"><span class="pre">task_scheduled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.task_scheduled" title="Link to this definition">¶</a></dt>
<dd><p>Called when the given task becomes runnable.</p>
<p>It may still be some time before it actually runs, if there are other
runnable tasks ahead of it.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The task that became runnable.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.abc.Instrument.task_spawned">
<span class="sig-name descname"><span class="pre">task_spawned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.abc.Instrument.task_spawned" title="Link to this definition">¶</a></dt>
<dd><p>Called when the given task is created.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The new task.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>教程中有一个 <a class="reference internal" href="tutorial.html#tutorial-instrument-example"><span class="std std-ref">完整示例</span></a>，展示了如何定义自定义监控工具来记录 Trio 的内部调度决策。</p>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p>The instrument API provides a standard way to add custom
instrumentation to the run loop. Want to make a histogram of
scheduling latencies, log a stack trace of any task that blocks the
run loop for &gt;50 ms, or measure what percentage of your process's
running time is spent waiting for I/O? This is the place.</p>
<p>The general idea is that at any given moment, <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>
maintains a set of "instruments", which are objects that implement the
<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Instrument</span></code></a> interface. When an interesting event
happens, it loops over these instruments and notifies them by calling
an appropriate method. The tutorial has <a class="reference internal" href="tutorial.html#tutorial-instrument-example"><span class="std std-ref">a simple example of
using this for tracing</span></a>.</p>
<p>Since this hooks into Trio at a rather low level, you do have to be
careful. The callbacks are run synchronously, and in many cases if
they error out then there isn't any plausible way to propagate this
exception (for instance, we might be deep in the guts of the exception
propagation machinery...). Therefore our <a class="reference external" href="https://github.com/python-trio/trio/issues/47">current strategy</a> for handling
exceptions raised by instruments is to (a) log an exception to the
<code class="docutils literal notranslate"><span class="pre">"trio.abc.Instrument"</span></code> logger, which by default prints a stack
trace to standard error and (b) disable the offending instrument.</p>
<p>You can register an initial list of instruments by passing them to
<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. <a class="reference internal" href="#trio.lowlevel.add_instrument" title="trio.lowlevel.add_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_instrument()</span></code></a> and
<a class="reference internal" href="#trio.lowlevel.remove_instrument" title="trio.lowlevel.remove_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_instrument()</span></code></a> let you add and remove instruments at
runtime.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">add_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start instrumenting the current run loop with the given instrument.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instrument</strong> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) -- The instrument to activate.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">instrument</span></code> is already active, does nothing.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">remove_instrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stop instrumenting the current run loop with the given instrument.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>instrument</strong> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) -- The instrument to de-activate.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" title="（在 Python v3.13）"><strong>KeyError</strong></a> -- if the instrument is not currently active. This could
    occur either because you never added it, or because you added it
    and then it raised an unhandled exception and was automatically
    deactivated.</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<p>And here's the interface to implement if you want to build your own
<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.abc.</span></span><span class="sig-name descname"><span class="pre">Instrument</span></span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/abc.html#abc.ABC" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></a></p>
<p>The interface for run loop instrumentation.</p>
<p>Instruments don't have to inherit from this abstract base class, and all
of these methods are optional. This class serves mostly as documentation.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">after_io_wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called after handling pending I/O.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- The number of seconds we were willing to
wait. This much time may or may not have elapsed, depending on
whether any I/O was ready.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">after_run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Called just before <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> returns.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">after_task_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called when we return to the main run loop after a task has yielded.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The task that just ran.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">before_io_wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called before blocking to wait for I/O readiness.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>timeout</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="（在 Python v3.13）"><em>float</em></a>) -- The number of seconds we are willing to wait.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">before_run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Called at the beginning of <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">before_task_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called immediately before we resume running the given task.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The task that is about to run.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">task_exited</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called when the given task exits.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The finished task.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">task_scheduled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called when the given task becomes runnable.</p>
<p>It may still be some time before it actually runs, if there are other
runnable tasks ahead of it.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The task that became runnable.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">task_spawned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Called when the given task is created.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- The new task.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<p>The tutorial has a <a class="reference internal" href="tutorial.html#tutorial-instrument-example"><span class="std std-ref">fully-worked example</span></a> of defining a custom instrument to log
Trio's internal scheduling decisions.</p>
</div>
</div>
</section>
</section>
<section id="id4">
<h2>低级进程生成<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p><strong>Low-level process spawning</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.open_process">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">open_process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">command</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.open_process" title="Link to this definition">¶</a></dt>
<dd><p>Execute a child program in a new process.</p>
<p>After construction, you can interact with the child process by writing data to its
<cite>~trio.Process.stdin</cite> stream (a <cite>~trio.abc.SendStream</cite>), reading data from its
<cite>~trio.Process.stdout</cite> and/or <cite>~trio.Process.stderr</cite> streams (both
<cite>~trio.abc.ReceiveStream</cite>s), sending it signals using <cite>~trio.Process.terminate</cite>,
<cite>~trio.Process.kill</cite>, or <cite>~trio.Process.send_signal</cite>, and waiting for it to exit
using <cite>~trio.Process.wait</cite>. See <cite>trio.Process</cite> for details.</p>
<p>Each standard stream is only available if you specify that a pipe should be created
for it. For example, if you pass <code class="docutils literal notranslate"><span class="pre">stdin=subprocess.PIPE</span></code>, you can write to the
<cite>~trio.Process.stdin</cite> stream, else <cite>~trio.Process.stdin</cite> will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Unlike <cite>trio.run_process</cite>, this function doesn't do any kind of automatic
management of the child process. It's up to you to implement whatever semantics you
want.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>command</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Union" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/os.html#os.PathLike" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/os.html#os.PathLike" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Union" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/os.html#os.PathLike" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/os.html#os.PathLike" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>]]]]</span>) -- The command to run. Typically this is a sequence of strings or
bytes such as <code class="docutils literal notranslate"><span class="pre">['ls',</span> <span class="pre">'-l',</span> <span class="pre">'directory</span> <span class="pre">with</span> <span class="pre">spaces']</span></code>, where the
first element names the executable to invoke and the other elements
specify its arguments. With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> in the <code class="docutils literal notranslate"><span class="pre">**options</span></code>, or on
Windows, <code class="docutils literal notranslate"><span class="pre">command</span></code> can be a string or bytes, which will be parsed
following platform-dependent <a class="reference internal" href="ref-io/subprocess.html#subprocess-quoting"><span class="std std-ref">quoting rules</span></a>. In all cases <code class="docutils literal notranslate"><span class="pre">command</span></code> can be a path or a
sequence of paths.</p></li>
<li><p><strong>stdin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> | <a class="reference internal" href="ref-io/subprocess.html#trio._subprocess.HasFileno" title="trio._subprocess.HasFileno"><code class="xref py py-class docutils literal notranslate"><span class="pre">HasFileno</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>) -- Specifies what the child process's standard input
stream should connect to: output written by the parent
(<code class="docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code>), nothing (<code class="docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code>),
or an open file (pass a file descriptor or something whose
<code class="docutils literal notranslate"><span class="pre">fileno</span></code> method returns one). If <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is unspecified,
the child process will have the same standard input stream
as its parent.</p></li>
<li><p><strong>stdout</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> | <a class="reference internal" href="ref-io/subprocess.html#trio._subprocess.HasFileno" title="trio._subprocess.HasFileno"><code class="xref py py-class docutils literal notranslate"><span class="pre">HasFileno</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>) -- Like <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, but for the child process's standard output
stream.</p></li>
<li><p><strong>stderr</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> | <a class="reference internal" href="ref-io/subprocess.html#trio._subprocess.HasFileno" title="trio._subprocess.HasFileno"><code class="xref py py-class docutils literal notranslate"><span class="pre">HasFileno</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>) -- Like <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, but for the child process's standard error
stream. An additional value <code class="docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code> is supported,
which causes the child's standard output and standard error
messages to be intermixed on a single standard output stream,
attached to whatever the <code class="docutils literal notranslate"><span class="pre">stdout</span></code> option says to attach it to.</p></li>
<li><p><strong>**options</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span>) -- Other <a class="reference internal" href="ref-io/subprocess.html#subprocess-options"><span class="std std-ref">general subprocess options</span></a>
are also accepted.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="ref-io/subprocess.html#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a></span></p>
</dd>
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new <cite>trio.Process</cite> object.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- if the process spawning fails, for example because the
    specified command could not be found.</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="i-o">
<h2>低级 I/O 原语<a class="headerlink" href="#i-o" title="Link to this heading">¶</a></h2>
<p><strong>Low-level I/O primitives</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p>不同的环境暴露了不同的低级 API 用于执行异步 I/O。<a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> 以相对直接的方式暴露这些 API，以便为更高级别的代码提供最大限度的能力和灵活性。然而，这也意味着提供的具体 API 可能会根据 Trio 运行的系统有所不同。</p>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>Different environments expose different low-level APIs for performing
async I/O. <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> exposes these APIs in a relatively
direct way, so as to allow maximum power and flexibility for higher
level code. However, this means that the exact API provided may vary
depending on what system Trio is running on.</p>
</div>
</div>
<section id="id5">
<h3>通用 API<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<p><strong>Universally available API</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--5-input--1" name="tab-set--5" type="radio"/><label class="tab-label" for="tab-set--5-input--1">中文</label><div class="tab-content docutils container">
<p>所有环境都提供以下函数：</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.wait_readable">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_readable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.wait_readable" title="Link to this definition">¶</a></dt>
<dd><p>阻塞，直到内核报告给定对象可读。</p>
<p>在 Unix 系统上，<code class="docutils literal notranslate"><span class="pre">obj</span></code> 必须是一个整数文件描述符，或者是一个具有 <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> 方法并返回整数文件描述符的对象。任何类型的文件描述符都可以传递，尽管具体的语义会依赖于你的内核。例如，这可能对磁盘文件没有任何实质性的作用。</p>
<p>在 Windows 系统上，<code class="docutils literal notranslate"><span class="pre">obj</span></code> 必须是一个整数 <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> 句柄，或者是一个具有 <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> 方法并返回整数 <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> 句柄的对象。文件描述符不被支持，句柄也不能指向除 <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> 以外的任何对象。</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- 如果另一个任务已经在等待给定的套接字变为可读。</p></li>
<li><p><a class="reference internal" href="ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- 如果另一个任务在此函数仍在工作时调用了 <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a>。</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.wait_writable">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_writable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.wait_writable" title="Link to this definition">¶</a></dt>
<dd><p>阻塞，直到内核报告给定对象可写。</p>
<p>请参阅 <cite>wait_readable</cite> 中对 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 的定义。</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="ref-core/exc_warn.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> -- 如果另一个任务已经在等待给定的套接字变为可写。</p></li>
<li><p><a class="reference internal" href="ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> -- 如果另一个任务在此函数仍在工作时调用了 <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a>。</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.notify_closing">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">notify_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.notify_closing" title="Link to this definition">¶</a></dt>
<dd><p>在关闭文件描述符（在 Unix 上）或套接字（在 Windows 上）之前调用此函数。这将导致对给定对象的任何 <a class="reference internal" href="#trio.lowlevel.wait_readable" title="trio.lowlevel.wait_readable"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_readable()</span></code></a> 或 <a class="reference internal" href="#trio.lowlevel.wait_writable" title="trio.lowlevel.wait_writable"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_writable()</span></code></a> 调用立即唤醒并引发 <a class="reference internal" href="ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>。</p>
<p>这实际上并不会关闭对象——你仍然需要在之后自己关闭它。另外，在你调用此函数和实际关闭对象之间，你需要小心确保没有新的任务开始等待该对象。所以，正确关闭某个对象通常需要按以下步骤操作：</p>
<ol class="arabic simple">
<li><p>明确标记对象为已关闭，以便任何新的使用尝试在开始之前就会中止。</p></li>
<li><p>调用 <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> 唤醒任何已经存在的使用者。</p></li>
<li><p>实际关闭对象。</p></li>
</ol>
<p>如果这更方便，也可以按不同的顺序执行这些步骤，<em>但前提是</em> 确保在步骤之间没有任何检查点。这样它们都会在一个原子步骤中完成，其他任务就无法知道它们的执行顺序了。</p>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--5-input--2" name="tab-set--5" type="radio"/><label class="tab-label" for="tab-set--5-input--2">英文</label><div class="tab-content docutils container">
<p>All environments provide the following functions:</p>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_readable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>
<p>Block until the kernel reports that the given object is readable.</p>
<p>On Unix systems, <code class="docutils literal notranslate"><span class="pre">obj</span></code> must either be an integer file descriptor,
or else an object with a <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> method which returns an
integer file descriptor. Any kind of file descriptor can be passed,
though the exact semantics will depend on your kernel. For example,
this probably won't do anything useful for on-disk files.</p>
<p>On Windows systems, <code class="docutils literal notranslate"><span class="pre">obj</span></code> must either be an integer <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code>
handle, or else an object with a <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> method which returns
an integer <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> handle. File descriptors aren't supported,
and neither are handles that refer to anything besides a
<code class="docutils literal notranslate"><span class="pre">SOCKET</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">raises trio.BusyResourceError<span class="colon">:</span></dt>
<dd class="field-odd"><p>if another task is already waiting for the given socket to
become readable.</p>
</dd>
<dt class="field-even">raises trio.ClosedResourceError<span class="colon">:</span></dt>
<dd class="field-even"><p>if another task calls <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> while this
function is still working.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_writable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>
<p>Block until the kernel reports that the given object is writable.</p>
<p>See <cite>wait_readable</cite> for the definition of <code class="docutils literal notranslate"><span class="pre">obj</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">raises trio.BusyResourceError<span class="colon">:</span></dt>
<dd class="field-odd"><p>if another task is already waiting for the given socket to
become writable.</p>
</dd>
<dt class="field-even">raises trio.ClosedResourceError<span class="colon">:</span></dt>
<dd class="field-even"><p>if another task calls <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> while this
function is still working.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">notify_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Call this before closing a file descriptor (on Unix) or socket (on
Windows). This will cause any <a class="reference internal" href="#trio.lowlevel.wait_readable" title="trio.lowlevel.wait_readable"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_readable()</span></code></a> or <a class="reference internal" href="#trio.lowlevel.wait_writable" title="trio.lowlevel.wait_writable"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_writable()</span></code></a>
calls on the given object to immediately wake up and raise
<a class="reference internal" href="ref-core/exc_warn.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p>
<p>This doesn't actually close the object – you still have to do that
yourself afterwards. Also, you want to be careful to make sure no
new tasks start waiting on the object in between when you call this
and when it's actually closed. So to close something properly, you
usually want to do these steps in order:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Explicitly mark the object as closed, so that any new attempts</dt><dd><p>to use it will abort before they start.</p>
</dd>
</dl>
</li>
<li><p>Call <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> to wake up any already-existing users.</p></li>
<li><p>Actually close the object.</p></li>
</ol>
<p>It's also possible to do them in a different order if that's more
convenient, <em>but only if</em> you make sure not to have any checkpoints in
between the steps. This way they all happen in a single atomic
step, so other tasks won't be able to tell what order they happened
in anyway.</p>
</dd></dl>
</div>
</div>
</section>
<section id="unix-api">
<h3>Unix 特定 API<a class="headerlink" href="#unix-api" title="Link to this heading">¶</a></h3>
<p><strong>Unix-specific API</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--6-input--1" name="tab-set--6" type="radio"/><label class="tab-label" for="tab-set--6-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="#trio.lowlevel.FdStream" title="trio.lowlevel.FdStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">FdStream</span></code></a> 支持将 Unix 文件（例如管道或 TTY）包装为流。</p>
<p>如果你有两个不同的文件描述符用于发送和接收，并希望将它们捆绑在一起形成一个单一的双向 <a class="reference internal" href="ref-io/abs_api.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>，那么可以使用 <a class="reference internal" href="ref-io/abs_api.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bidirectional_stream</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">StapledStream</span><span class="p">(</span>
    <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">FdStream</span><span class="p">(</span><span class="n">write_fd</span><span class="p">),</span>
    <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">FdStream</span><span class="p">(</span><span class="n">read_fd</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.FdStream">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">FdStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.FdStream" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference internal" href="ref-io/abs_api.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p>
<p>Represents a stream given the file descriptor to a pipe, TTY, etc.</p>
<p><em>fd</em> must refer to a file that is open for reading and/or writing and
supports non-blocking I/O (pipes and TTYs will work, on-disk files probably
not).  The returned stream takes ownership of the fd, so closing the stream
will close the fd too.  As with <cite>os.fdopen</cite>, you should not directly use
an fd after you have wrapped it in a stream using this function.</p>
<p>To be used as a Trio stream, an open file must be placed in non-blocking
mode.  Unfortunately, this impacts all I/O that goes through the
underlying open file, including I/O that uses a different
file descriptor than the one that was passed to Trio. If other threads
or processes are using file descriptors that are related through <cite>os.dup</cite>
or inheritance across <cite>os.fork</cite> to the one that Trio is using, they are
unlikely to be prepared to have non-blocking I/O semantics suddenly
thrust upon them.  For example, you can use
<code class="docutils literal notranslate"><span class="pre">FdStream(os.dup(sys.stdin.fileno()))</span></code> to obtain a stream for reading
from standard input, but it is only safe to do so with heavy caveats: your
stdin must not be shared by any other processes, and you must not make any
calls to synchronous methods of <cite>sys.stdin</cite> until the stream returned by
<cite>FdStream</cite> is closed. See <a class="reference external" href="https://github.com/python-trio/trio/issues/174">issue #174</a> for a discussion of the
challenges involved in relaxing this restriction.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fd</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The fd to be wrapped.</p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <cite>FdStream</cite> object.</p>
</dd>
</dl>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--6-input--2" name="tab-set--6" type="radio"/><label class="tab-label" for="tab-set--6-input--2">英文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="#trio.lowlevel.FdStream" title="trio.lowlevel.FdStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">FdStream</span></code></a> supports wrapping Unix files (such as a pipe or TTY) as
a stream.</p>
<p>If you have two different file descriptors for sending and receiving,
and want to bundle them together into a single bidirectional
<a class="reference internal" href="ref-io/abs_api.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, then use <a class="reference internal" href="ref-io/abs_api.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bidirectional_stream</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">StapledStream</span><span class="p">(</span>
    <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">FdStream</span><span class="p">(</span><span class="n">write_fd</span><span class="p">),</span>
    <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">FdStream</span><span class="p">(</span><span class="n">read_fd</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">FdStream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference internal" href="ref-io/abs_api.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p>
<p>Represents a stream given the file descriptor to a pipe, TTY, etc.</p>
<p><em>fd</em> must refer to a file that is open for reading and/or writing and
supports non-blocking I/O (pipes and TTYs will work, on-disk files probably
not).  The returned stream takes ownership of the fd, so closing the stream
will close the fd too.  As with <cite>os.fdopen</cite>, you should not directly use
an fd after you have wrapped it in a stream using this function.</p>
<p>To be used as a Trio stream, an open file must be placed in non-blocking
mode.  Unfortunately, this impacts all I/O that goes through the
underlying open file, including I/O that uses a different
file descriptor than the one that was passed to Trio. If other threads
or processes are using file descriptors that are related through <cite>os.dup</cite>
or inheritance across <cite>os.fork</cite> to the one that Trio is using, they are
unlikely to be prepared to have non-blocking I/O semantics suddenly
thrust upon them.  For example, you can use
<code class="docutils literal notranslate"><span class="pre">FdStream(os.dup(sys.stdin.fileno()))</span></code> to obtain a stream for reading
from standard input, but it is only safe to do so with heavy caveats: your
stdin must not be shared by any other processes, and you must not make any
calls to synchronous methods of <cite>sys.stdin</cite> until the stream returned by
<cite>FdStream</cite> is closed. See <a class="reference external" href="https://github.com/python-trio/trio/issues/174">issue #174</a> for a discussion of the
challenges involved in relaxing this restriction.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fd</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a>) -- The fd to be wrapped.</p>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>A new <cite>FdStream</cite> object.</p>
</dd>
</dl>
</dd></dl>
</div>
</div>
</section>
<section id="kqueue-api">
<h3>Kqueue 特定 API<a class="headerlink" href="#kqueue-api" title="Link to this heading">¶</a></h3>
<p><strong>Kqueue-specific API</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--7-input--1" name="tab-set--7" type="radio"/><label class="tab-label" for="tab-set--7-input--1">中文</label><div class="tab-content docutils container">
<p>TODO: 这些已经实现，但目前更像是草图而非实际功能。请参阅 <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a>。</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_kqueue">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_kqueue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.current_kqueue" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.wait_kevent">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_kevent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ident</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abort_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.wait_kevent" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.monitor_kevent">
<em class="property"><span class="pre">with</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">monitor_kevent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ident</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><em class="property"><span class="pre"> as</span> <span class="pre">queue</span></em><a class="headerlink" href="#trio.lowlevel.monitor_kevent" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
</div>
<input class="tab-input" id="tab-set--7-input--2" name="tab-set--7" type="radio"/><label class="tab-label" for="tab-set--7-input--2">英文</label><div class="tab-content docutils container">
<p>TODO: these are implemented, but are currently more of a sketch than anything real. See <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a>.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_kqueue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_kevent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ident</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abort_func</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">with</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">monitor_kevent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ident</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><em class="property"><span class="pre"> as</span> <span class="pre">queue</span></em></dt>
<dd></dd></dl>
</div>
</div>
</section>
<section id="windows-api">
<h3>Windows 特定 API<a class="headerlink" href="#windows-api" title="Link to this heading">¶</a></h3>
<p><strong>Windows-specific API</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.WaitForSingleObject">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">WaitForSingleObject</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.WaitForSingleObject" title="Link to this definition">¶</a></dt>
<dd><p>Async and cancellable variant of <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx">WaitForSingleObject</a>.
Windows only.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>handle</strong> -- A Win32 object handle, as a Python integer.</p>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#OSError" title="（在 Python v3.13）"><strong>OSError</strong></a> -- If the handle is invalid, e.g. when it is already closed.</p>
</dd>
</dl>
</dd></dl>
<p>TODO: these are implemented, but are currently more of a sketch than
anything real. See <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a> and <a class="reference external" href="https://github.com/python-trio/trio/issues/52">#52</a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.register_with_iocp">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">register_with_iocp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.register_with_iocp" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.wait_overlapped">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_overlapped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpOverlapped</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.wait_overlapped" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.write_overlapped">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">write_overlapped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.write_overlapped" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.readinto_overlapped">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">readinto_overlapped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.readinto_overlapped" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_iocp">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_iocp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.current_iocp" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.monitor_completion_key">
<em class="property"><span class="pre">with</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">monitor_completion_key</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><em class="property"><span class="pre"> as</span> <span class="pre">queue</span></em><a class="headerlink" href="#trio.lowlevel.monitor_completion_key" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
</section>
</section>
<section id="id6">
<h2>全局状态：系统任务和运行局部变量<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h2>
<p><strong>Global state: system tasks and run-local variables</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.RunVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">RunVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'trio._core._local._NoValue'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.RunVar" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Generic" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="TypeVar, （在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a>]</p>
<p>The run-local variant of a context variable.</p>
<p><a class="reference internal" href="#trio.lowlevel.RunVar" title="trio.lowlevel.RunVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVar</span></code></a> objects are similar to context variable objects,
except that they are shared across a single call to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>
rather than a single task.</p>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.RunVar.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'trio._core._local._NoValue'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.RunVar.get" title="Link to this definition">¶</a></dt>
<dd><p>Gets the value of this <a class="reference internal" href="#trio.lowlevel.RunVar" title="trio.lowlevel.RunVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVar</span></code></a> for the current run call.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">T</span></code>)</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.RunVar.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">token</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.RunVar.reset" title="Link to this definition">¶</a></dt>
<dd><p>Resets the value of this <a class="reference internal" href="#trio.lowlevel.RunVar" title="trio.lowlevel.RunVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVar</span></code></a> to what it was
previously specified by the token.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.RunVar.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.RunVar.set" title="Link to this definition">¶</a></dt>
<dd><p>Sets the value of this <a class="reference internal" href="#trio.lowlevel.RunVar" title="trio.lowlevel.RunVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVar</span></code></a> for this current run
call.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVarToken</span></code>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">T</span></code>)]</span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.spawn_system_task">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">spawn_system_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.spawn_system_task" title="Link to this definition">¶</a></dt>
<dd><p>Spawn a "system" task.</p>
<p>System tasks have a few differences from regular tasks:</p>
<ul class="simple">
<li><p>They don't need an explicit nursery; instead they go into the
internal "system nursery".</p></li>
<li><p>If a system task raises an exception, then it's converted into a
<a class="reference internal" href="ref-core/exc_warn.html#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a> and <em>all</em> tasks are cancelled. If you
write a system task, you should be careful to make sure it doesn't
crash.</p></li>
<li><p>System tasks are automatically cancelled when the main task exits.</p></li>
<li><p>By default, system tasks have <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection
<em>enabled</em>. If you want your task to be interruptible by control-C,
then you need to use <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> explicitly (and
come up with some plan for what to do with a
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, given that system tasks aren't allowed to
raise exceptions).</p></li>
<li><p>System tasks do not inherit context variables from their creator.</p></li>
</ul>
<p>Towards the end of a call to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, after the main
task and all system tasks have exited, the system nursery
becomes closed. At this point, new calls to
<a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a> will raise <code class="docutils literal notranslate"><span class="pre">RuntimeError("Nursery</span>
<span class="pre">is</span> <span class="pre">closed</span> <span class="pre">to</span> <span class="pre">new</span> <span class="pre">arrivals")</span></code> instead of creating a system
task. It's possible to encounter this state either in
a <code class="docutils literal notranslate"><span class="pre">finally</span></code> block in an async generator, or in a callback
passed to <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a> at the right moment.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>async_fn</strong> (<span class="sphinx_autodoc_typehints-type">Callable[[Unpack[PosArgT]], Awaitable[object]]</span>) -- An async callable.</p></li>
<li><p><strong>args</strong> (<span class="sphinx_autodoc_typehints-type">Unpack[PosArgT]</span>) -- Positional arguments for <code class="docutils literal notranslate"><span class="pre">async_fn</span></code>. If you want to pass
keyword arguments, use <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functools.html#functools.partial" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li>
<li><p><strong>name</strong> (<span class="sphinx_autodoc_typehints-type">object</span>) -- The name for this task. Only used for debugging/introspection
(e.g. <code class="docutils literal notranslate"><span class="pre">repr(task_obj)</span></code>). If this isn't a string,
<a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a> will try to make it one. A common use
case is if you're wrapping a function before spawning a new
task, you might pass the original function as the <code class="docutils literal notranslate"><span class="pre">name=</span></code> to
make debugging easier.</p></li>
<li><p><strong>context</strong> (<span class="sphinx_autodoc_typehints-type">contextvars.Context | None</span>) -- An optional <code class="docutils literal notranslate"><span class="pre">contextvars.Context</span></code> object with context variables
to use for this task. You would normally get a copy of the current
context with <code class="docutils literal notranslate"><span class="pre">context</span> <span class="pre">=</span> <span class="pre">contextvars.copy_context()</span></code> and then you would
pass that <code class="docutils literal notranslate"><span class="pre">context</span></code> object here.</p></li>
</ul>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>the newly spawned task</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task">Task</a></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="id7">
<h2>Trio 令牌<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h2>
<p><strong>Trio tokens</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.TrioToken">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">TrioToken</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reentry_queue</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.TrioToken" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An opaque object representing a single call to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p>
<p>It has no public constructor; instead, see <a class="reference internal" href="#trio.lowlevel.current_trio_token" title="trio.lowlevel.current_trio_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_trio_token()</span></code></a>.</p>
<p>This object has two uses:</p>
<ol class="arabic simple">
<li><p>It lets you re-enter the Trio run loop from external threads or signal
handlers. This is the low-level primitive that <a class="reference internal" href="ref-core/threads.html#module-trio.to_thread" title="trio.to_thread"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread()</span></code></a>
and <cite>trio.from_thread</cite> use to communicate with worker threads, that
<cite>trio.open_signal_receiver</cite> uses to receive notifications about
signals, and so forth.</p></li>
<li><p>Each call to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has exactly one associated
<a class="reference internal" href="#trio.lowlevel.TrioToken" title="trio.lowlevel.TrioToken"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrioToken</span></code></a> object, so you can use it to identify a particular
call.</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.TrioToken.run_sync_soon">
<span class="sig-name descname"><span class="pre">run_sync_soon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sync_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idempotent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.TrioToken.run_sync_soon" title="Link to this definition">¶</a></dt>
<dd><p>Schedule a call to <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> to occur in the context of a
Trio task.</p>
<p>This is safe to call from the main thread, from other threads, and
from signal handlers. This is the fundamental primitive used to
re-enter the Trio run loop from outside of it.</p>
<p>The call will happen "soon", but there's no guarantee about exactly
when, and no mechanism provided for finding out when it's happened.
If you need this, you'll have to build your own.</p>
<p>The call is effectively run as part of a system task (see
<a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a>). In particular this means
that:
:rtype: <span class="sphinx_autodoc_typehints-type">None</span></p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection is <em>enabled</em> by default; if
you want <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> to be interruptible by control-C, then you
need to use <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a>
explicitly.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> raises an exception, then it's converted into a
<a class="reference internal" href="ref-core/exc_warn.html#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a> and <em>all</em> tasks are cancelled. You
should be careful that <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> doesn't crash.</p></li>
</ul>
<p>All calls with <code class="docutils literal notranslate"><span class="pre">idempotent=False</span></code> are processed in strict
first-in first-out order.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">idempotent=True</span></code>, then <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code> must be
hashable, and Trio will make a best-effort attempt to discard any
call submission which is equal to an already-pending call. Trio
will process these in first-in first-out order.</p>
<p>Any ordering guarantees apply separately to <code class="docutils literal notranslate"><span class="pre">idempotent=False</span></code>
and <code class="docutils literal notranslate"><span class="pre">idempotent=True</span></code> calls; there's no rule for how calls in the
different categories are ordered with respect to each other.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="ref-core/exc_warn.html#trio.RunFinishedError" title="trio.RunFinishedError"><strong>trio.RunFinishedError</strong></a> -- if the associated call to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>
has already exited. (Any call that <em>doesn't</em> raise this error
is guaranteed to be fully processed before <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>
exits.)</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_trio_token">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_trio_token</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.current_trio_token" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve the <a class="reference internal" href="#trio.lowlevel.TrioToken" title="trio.lowlevel.TrioToken"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrioToken</span></code></a> for the current call to
<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">TrioToken</span></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="id8">
<h2>生成线程<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h2>
<p><strong>Spawning threads</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.start_thread_soon">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">start_thread_soon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deliver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.start_thread_soon" title="Link to this definition">¶</a></dt>
<dd><p>Runs <code class="docutils literal notranslate"><span class="pre">deliver(outcome.capture(fn))</span></code> in a worker thread.</p>
<p>Generally <code class="docutils literal notranslate"><span class="pre">fn</span></code> does some blocking work, and <code class="docutils literal notranslate"><span class="pre">deliver</span></code> delivers the
result back to whoever is interested.</p>
<p>This is a low-level, no-frills interface, very similar to using
<cite>threading.Thread</cite> to spawn a thread directly. The main difference is
that this function tries to reuse threads when possible, so it can be
a bit faster than <cite>threading.Thread</cite>.</p>
<p>Worker threads have the <cite>~threading.Thread.daemon</cite> flag set, which means
that if your main thread exits, worker threads will automatically be
killed. If you want to make sure that your <code class="docutils literal notranslate"><span class="pre">fn</span></code> runs to completion, then
you should make sure that the main thread remains alive until <code class="docutils literal notranslate"><span class="pre">deliver</span></code>
is called.</p>
<p>It is safe to call this function simultaneously from multiple threads.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>sync function</em>) -- Performs arbitrary blocking work.</p></li>
<li><p><strong>deliver</strong> (<em>sync function</em>) -- Takes the <cite>outcome.Outcome</cite> of <code class="docutils literal notranslate"><span class="pre">fn</span></code>, and
delivers it. <em>Must not block.</em></p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
<p>Because worker threads are cached and reused for multiple calls, neither
function should mutate thread-level state, like <cite>threading.local</cite> objects
– or if they do, they should be careful to revert their changes before
returning.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>The split between <code class="docutils literal notranslate"><span class="pre">fn</span></code> and <code class="docutils literal notranslate"><span class="pre">deliver</span></code> serves two purposes. First,
it's convenient, since most callers need something like this anyway.</p>
<p>Second, it avoids a small race condition that could cause too many
threads to be spawned. Consider a program that wants to run several
jobs sequentially on a thread, so the main thread submits a job, waits
for it to finish, submits another job, etc. In theory, this program
should only need one worker thread. But what could happen is:</p>
<ol class="arabic simple">
<li><p>Worker thread: First job finishes, and calls <code class="docutils literal notranslate"><span class="pre">deliver</span></code>.</p></li>
<li><p>Main thread: receives notification that the job finished, and calls
<code class="docutils literal notranslate"><span class="pre">start_thread_soon</span></code>.</p></li>
<li><p>Main thread: sees that no worker threads are marked idle, so spawns
a second worker thread.</p></li>
<li><p>Original worker thread: marks itself as idle.</p></li>
</ol>
<p>To avoid this, threads mark themselves as idle <em>before</em> calling
<code class="docutils literal notranslate"><span class="pre">deliver</span></code>.</p>
<p>Is this potential extra thread a major problem? Maybe not, but it's
easy enough to avoid, and we figure that if the user is trying to
limit how many threads they're using then it's polite to respect that.</p>
</div>
</dd></dl>
</section>
<section id="id9">
<h2>更安全的键盘中断处理<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h2>
<p><strong>Safer KeyboardInterrupt handling</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--8-input--1" name="tab-set--8" type="radio"/><label class="tab-label" for="tab-set--8-input--1">中文</label><div class="tab-content docutils container">
<p>Trio 对 Ctrl-C 的处理旨在平衡可用性和安全性。一方面，在一些敏感区域（如核心调度循环）内，处理任意的 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 异常是不可能的，同时又能保持核心正确性的约束。另一方面，如果用户不小心写了一个无限循环，我们确实希望能够中断它。我们的解决方案是安装一个默认的信号处理器，在信号接收到的地方检查是否可以安全地抛出 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>。如果可以，就抛出；否则，我们将在下一个可用的时机调度一个 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>，将其传递给主任务（类似于 <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> 如何传递）。</p>
<p>这很好，但 – 我们如何知道自己是否在程序的敏感部分呢？</p>
<p>这个问题是通过逐个函数来决定的。默认情况下：</p>
<ul class="simple">
<li><p>普通用户任务中的顶级函数是没有保护的。</p></li>
<li><p>系统任务中的顶级函数是有保护的。</p></li>
<li><p>如果一个函数没有特别说明，那么它会继承调用者的保护状态。</p></li>
</ul>
<p>这意味着你只需要在从受保护代码过渡到非受保护代码，或从非受保护代码过渡到受保护代码的地方覆盖默认设置。</p>
<p>这些过渡是通过两个函数装饰器来实现的：</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.disable_ki_protection">
<span class="sig-prename descclassname"><span class="pre">@</span></span><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">disable_ki_protection</span></span><a class="headerlink" href="#trio.lowlevel.disable_ki_protection" title="Link to this definition">¶</a></dt>
<dd><p>装饰器，用于标记给定的普通函数、生成器函数、异步函数或异步生成器函数在处理 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 时没有保护，即该函数中的代码 <em>可以</em> 被 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 在任何时候强行中断。</p>
<p>如果同一个函数上有多个装饰器，应该将此装饰器放在最底部（最靠近实际函数的位置）。</p>
<p>一个使用此装饰器的示例是在实现像 <a class="reference internal" href="ref-core/threads.html#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> 这样的函数时，后者使用 <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a> 进入 Trio 线程。<a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_sync_soon()</span></code></a> 的回调是在启用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 保护的情况下运行的，而 <a class="reference internal" href="ref-core/threads.html#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> 利用这一点安全地设置将响应发送回原线程的机制，但在进入用户提供的函数时使用 <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a>。</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.enable_ki_protection">
<span class="sig-prename descclassname"><span class="pre">@</span></span><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">enable_ki_protection</span></span><a class="headerlink" href="#trio.lowlevel.enable_ki_protection" title="Link to this definition">¶</a></dt>
<dd><p>装饰器，用于标记给定的普通函数、生成器函数、异步函数或异步生成器函数在处理 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 时是受保护的，即该函数中的代码 <em>不会</em> 被 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 强行中断。（尽管如果它包含任何 <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">检查点</span></a>，那么在这些检查点处仍然可以接收 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>，这被视为一种礼貌的中断。）</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>请非常小心，仅在你知道某个函数会在有限时间内退出，或者定期经过检查点时，才使用此装饰器。（当然，你的所有函数都应该具备这个特性，但如果在这里搞错了，你甚至无法使用 Ctrl-C 来退出！）</p>
</div>
<p>如果同一个函数上有多个装饰器，应该将此装饰器放在最底部（最靠近实际函数的位置）。</p>
<p>一个使用此装饰器的示例是在像 <a class="reference internal" href="ref-core/task_sync.html#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> 这样的对象的 <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> 实现中，如果 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 发生在不恰当的时机，可能会导致锁处于不一致的状态，从而引发死锁。</p>
<p>由于 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 保护是按代码对象追踪的，任何尝试以不同方式条件性地保护相同代码块的做法可能不会按预期行为执行。如果你试图条件性地保护一个闭包，它会变成无条件保护:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">protect</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">currently_ki_protected</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">protect</span><span class="p">:</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">enable_ki_protection</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>  <span class="c1"># 一旦被保护...</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>  <span class="c1"># ...总是被保护</span>

<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你确实需要条件性保护，可以通过为闭包的每个 KI 保护实例提供独立的代码对象来实现:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">protect</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">currently_ki_protected</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">protect</span><span class="p">:</span>
        <span class="n">inner</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">replace</span><span class="p">()</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">enable_ki_protection</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span>

<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">)</span>
</pre></div>
</div>
<p>（默认情况下不这样做，因为它会带来一些内存开销，并减少在 CPython 最新版本中优化特化的潜力。）</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.currently_ki_protected">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">currently_ki_protected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.currently_ki_protected" title="Link to this definition">¶</a></dt>
<dd><p>Check whether the calling code has <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection
enabled.</p>
<p>It's surprisingly easy to think that one's <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>
protection is enabled when it isn't, or vice-versa. This function tells
you what Trio thinks of the matter, which makes it useful for <code class="docutils literal notranslate"><span class="pre">assert</span></code>s
and unit tests.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protection is enabled, and False otherwise.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）">bool</a></p>
</dd>
</dl>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--8-input--2" name="tab-set--8" type="radio"/><label class="tab-label" for="tab-set--8-input--2">英文</label><div class="tab-content docutils container">
<p>Trio's handling of control-C is designed to balance usability and
safety. On the one hand, there are sensitive regions (like the core
scheduling loop) where it's simply impossible to handle arbitrary
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> exceptions while maintaining our core
correctness invariants. On the other, if the user accidentally writes
an infinite loop, we do want to be able to break out of that. Our
solution is to install a default signal handler which checks whether
it's safe to raise <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at the place where the
signal is received. If so, then we do; otherwise, we schedule a
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> to be delivered to the main task at the next
available opportunity (similar to how <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> is
delivered).</p>
<p>So that's great, but – how do we know whether we're in one of the
sensitive parts of the program or not?</p>
<p>This is determined on a function-by-function basis. By default:</p>
<ul class="simple">
<li><p>The top-level function in regular user tasks is unprotected.</p></li>
<li><p>The top-level function in system tasks is protected.</p></li>
<li><p>If a function doesn't specify otherwise, then it inherits the
protection state of its caller.</p></li>
</ul>
<p>This means you only need to override the defaults at places where you
transition from protected code to unprotected code or vice-versa.</p>
<p>These transitions are accomplished using two function decorators:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">@</span></span><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">disable_ki_protection</span></span></dt>
<dd><p>Decorator that marks the given regular function, generator
function, async function, or async generator function as
unprotected against <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, i.e., the code inside
this function <em>can</em> be rudely interrupted by
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at any moment.</p>
<p>If you have multiple decorators on the same function, then this
should be at the bottom of the stack (closest to the actual
function).</p>
<p>An example of where you'd use this is in implementing something
like <a class="reference internal" href="ref-core/threads.html#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a>, which uses
<a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a> to get into the Trio
thread. <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_sync_soon()</span></code></a> callbacks are run with
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection enabled, and
<a class="reference internal" href="ref-core/threads.html#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> takes advantage of this to safely set up
the machinery for sending a response back to the original thread, but
then uses <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> when entering the
user-provided function.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">@</span></span><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">enable_ki_protection</span></span></dt>
<dd><p>Decorator that marks the given regular function, generator
function, async function, or async generator function as protected
against <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, i.e., the code inside this
function <em>won't</em> be rudely interrupted by
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>. (Though if it contains any
<a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoints</span></a>, then it can still receive
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at those. This is considered a polite
interruption.)</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Be very careful to only use this decorator on functions that you
know will either exit in bounded time, or else pass through a
checkpoint regularly. (Of course all of your functions should
have this property, but if you mess it up here then you won't
even be able to use control-C to escape!)</p>
</div>
<p>If you have multiple decorators on the same function, then this
should be at the bottom of the stack (closest to the actual
function).</p>
<p>An example of where you'd use this is on the <code class="docutils literal notranslate"><span class="pre">__exit__</span></code>
implementation for something like a <a class="reference internal" href="ref-core/task_sync.html#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, where a
poorly-timed <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> could leave the lock in an
inconsistent state and cause a deadlock.</p>
<p>Since KeyboardInterrupt protection is tracked per code object, any attempt to
conditionally protect the same block of code in different ways is unlikely to behave
how you expect. If you try to conditionally protect a closure, it will be
unconditionally protected instead:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">protect</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">currently_ki_protected</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">protect</span><span class="p">:</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">enable_ki_protection</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>  <span class="c1"># once protected ...</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>  <span class="c1"># ... always protected</span>

<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">)</span>
</pre></div>
</div>
<p>If you really need conditional protection, you can achieve it by giving each
KI-protected instance of the closure its own code object:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">protect</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">currently_ki_protected</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">protect</span><span class="p">:</span>
        <span class="n">inner</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">replace</span><span class="p">()</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">enable_ki_protection</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">amain</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
    <span class="k">assert</span> <span class="n">example</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span>

<span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">amain</span><span class="p">)</span>
</pre></div>
</div>
<p>(This isn't done by default because it carries some memory overhead and reduces
the potential for specializing optimizations in recent versions of CPython.)</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">currently_ki_protected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check whether the calling code has <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection
enabled.</p>
<p>It's surprisingly easy to think that one's <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>
protection is enabled when it isn't, or vice-versa. This function tells
you what Trio thinks of the matter, which makes it useful for <code class="docutils literal notranslate"><span class="pre">assert</span></code>s
and unit tests.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protection is enabled, and False otherwise.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）">bool</a></p>
</dd>
</dl>
</dd></dl>
</div>
</div>
</section>
<section id="id10">
<h2>睡眠和唤醒<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h2>
<p><strong>Sleeping and waking</strong></p>
<section id="id11">
<h3>等待队列抽象<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h3>
<p><strong>Wait queue abstraction</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">ParkingLot</span></span><a class="headerlink" href="#trio.lowlevel.ParkingLot" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A fair wait queue with cancellation and requeueing.</p>
<p>This class encapsulates the tricky parts of implementing a wait
queue. It's useful for implementing higher-level synchronization
primitives like queues and locks.</p>
<p>In addition to the methods below, you can use <code class="docutils literal notranslate"><span class="pre">len(parking_lot)</span></code> to get
the number of parked tasks, and <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">parking_lot:</span> <span class="pre">...</span></code> to check whether
there are any parked tasks.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.broken_by">
<span class="sig-name descname"><span class="pre">broken_by</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list[Task]</span></em><a class="headerlink" href="#trio.lowlevel.ParkingLot.broken_by" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.break_lot">
<span class="sig-name descname"><span class="pre">break_lot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.break_lot" title="Link to this definition">¶</a></dt>
<dd><p>Break this lot, with <code class="docutils literal notranslate"><span class="pre">task</span></code> noted as the task that broke it.</p>
<p>This causes all parked tasks to raise an error, and any
future tasks attempting to park to error. Unpark &amp; repark become no-ops as the
parking lot is empty.</p>
<p>The error raised contains a reference to the task sent as a parameter. The task
is also saved in the parking lot in the <code class="docutils literal notranslate"><span class="pre">broken_by</span></code> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.park">
<em class="property"><span class="pre">await</span> </em><span class="sig-name descname"><span class="pre">park</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.park" title="Link to this definition">¶</a></dt>
<dd><p>Park the current task until woken by a call to <a class="reference internal" href="#trio.lowlevel.ParkingLot.unpark" title="trio.lowlevel.ParkingLot.unpark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpark()</span></code></a> or
<a class="reference internal" href="#trio.lowlevel.ParkingLot.unpark_all" title="trio.lowlevel.ParkingLot.unpark_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpark_all()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>BrokenResourceError</strong></a> -- if attempting to park in a broken lot, or the lot
    breaks before we get to unpark.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.repark">
<span class="sig-name descname"><span class="pre">repark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_lot</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.repark" title="Link to this definition">¶</a></dt>
<dd><p>Move parked tasks from one <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> object to another.</p>
<p>This dequeues <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks from one lot, and requeues them on
another, preserving order. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">parker</span><span class="p">(</span><span class="n">lot</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"sleeping"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">lot</span><span class="o">.</span><span class="n">park</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"woken"</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">lot1</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">ParkingLot</span><span class="p">()</span>
    <span class="n">lot2</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">ParkingLot</span><span class="p">()</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">parker</span><span class="p">,</span> <span class="n">lot1</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">wait_all_tasks_blocked</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lot1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lot2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">lot1</span><span class="o">.</span><span class="n">repark</span><span class="p">(</span><span class="n">lot2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lot1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lot2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># This wakes up the task that was originally parked in lot1</span>
        <span class="n">lot2</span><span class="o">.</span><span class="n">unpark</span><span class="p">()</span>
</pre></div>
</div>
<p>If there are fewer than <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks parked, then reparks as many
tasks as are available and then returns successfully.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_lot</strong> (<a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><em>ParkingLot</em></a>) -- the parking lot to move tasks to.</p></li>
<li><p><strong>count</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em>|</em><a class="reference external" href="https://docs.python.org/3/library/math.html/inf" title="（在 Python v3.12）"><em>math.inf</em></a>) -- the number of tasks to move.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.repark_all">
<span class="sig-name descname"><span class="pre">repark_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_lot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.repark_all" title="Link to this definition">¶</a></dt>
<dd><p>Move all parked tasks from one <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> object to
another.</p>
<p>See <a class="reference internal" href="#trio.lowlevel.ParkingLot.repark" title="trio.lowlevel.ParkingLot.repark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">repark()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.statistics">
<span class="sig-name descname"><span class="pre">statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.statistics" title="Link to this definition">¶</a></dt>
<dd><p>Return an object containing debugging information.</p>
<p>Currently the following fields are defined:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.lowlevel.ParkingLotStatistics" title="trio.lowlevel.ParkingLotStatistics"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLotStatistics</span></code></a></span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lot's
<a class="reference internal" href="#trio.lowlevel.ParkingLot.park" title="trio.lowlevel.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">park()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.unpark">
<span class="sig-name descname"><span class="pre">unpark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.unpark" title="Link to this definition">¶</a></dt>
<dd><p>Unpark one or more tasks.</p>
<p>This wakes up <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks that are blocked in <a class="reference internal" href="#trio.lowlevel.ParkingLot.park" title="trio.lowlevel.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">park()</span></code></a>. If
there are fewer than <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks parked, then wakes as many tasks
are available and then returns successfully.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>count</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/math.html/inf" title="（在 Python v3.12）"><em>math.inf</em></a>) -- the number of tasks to unpark.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">list[Task]</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLot.unpark_all">
<span class="sig-name descname"><span class="pre">unpark_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLot.unpark_all" title="Link to this definition">¶</a></dt>
<dd><p>Unpark all parked tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">list[Task]</span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.ParkingLotStatistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">ParkingLotStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tasks_waiting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.ParkingLotStatistics" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>An object containing debugging information for a ParkingLot.</p>
<p>Currently, the following fields are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code> (int): The number of tasks blocked on this lot's
<a class="reference internal" href="#trio.lowlevel.ParkingLot.park" title="trio.lowlevel.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.lowlevel.ParkingLot.park()</span></code></a> method.</p></li>
</ul>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.add_parking_lot_breaker">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">add_parking_lot_breaker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.add_parking_lot_breaker" title="Link to this definition">¶</a></dt>
<dd><p>Register a task as a breaker for a lot. See <a class="reference internal" href="#trio.lowlevel.ParkingLot.break_lot" title="trio.lowlevel.ParkingLot.break_lot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ParkingLot.break_lot()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> -- if the task has already exited.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.remove_parking_lot_breaker">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">remove_parking_lot_breaker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.remove_parking_lot_breaker" title="Link to this definition">¶</a></dt>
<dd><p>Deregister a task as a breaker for a lot. See <a class="reference internal" href="#trio.lowlevel.ParkingLot.break_lot" title="trio.lowlevel.ParkingLot.break_lot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ParkingLot.break_lot()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="id12">
<h3>低级检查点函数<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h3>
<p><strong>Low-level checkpoint functions</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--9-input--1" name="tab-set--9" type="radio"/><label class="tab-label" for="tab-set--9-input--1">中文</label><div class="tab-content docutils container">
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.checkpoint">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">checkpoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.checkpoint" title="Link to this definition">¶</a></dt>
<dd><p>A pure <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p>
<p>This checks for cancellation and allows other tasks to be scheduled,
without otherwise blocking.</p>
<p>Note that the scheduler has the option of ignoring this and continuing to
run the current task if it decides this is appropriate (e.g. for increased
efficiency).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(0)</span></code> (which is implemented by calling
<a class="reference internal" href="#trio.lowlevel.checkpoint" title="trio.lowlevel.checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint()</span></code></a>.)</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<p>接下来的两个函数是 <em>一起</em> 使用的，构成一个检查点：</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.checkpoint_if_cancelled">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">checkpoint_if_cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.checkpoint_if_cancelled" title="Link to this definition">¶</a></dt>
<dd><p>Issue a <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoint</span></a> if the calling context has been
cancelled.</p>
<p>Equivalent to (but potentially more efficient than):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">trio</span><span class="o">.</span><span class="n">current_effective_deadline</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="n">inf</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
</pre></div>
</div>
<p>This is either a no-op, or else it allow other tasks to be scheduled and
then raises <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>.</p>
<p>Typically used together with <a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint" title="trio.lowlevel.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.cancel_shielded_checkpoint">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">cancel_shielded_checkpoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.cancel_shielded_checkpoint" title="Link to this definition">¶</a></dt>
<dd><p>Introduce a schedule point, but not a cancel point.</p>
<p>This is <em>not</em> a <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoint</span></a>, but it is half of a
checkpoint, and when combined with <a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled" title="trio.lowlevel.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> it can
make a full checkpoint.</p>
<p>Equivalent to (but potentially more efficient than):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">CancelScope</span><span class="p">(</span><span class="n">shield</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<p>这些函数通常用于那些可能会阻塞也可能不会阻塞的操作中，并且你想实现 Trio 的标准检查点语义。示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">operation_that_maybe_blocks</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">checkpoint_if_cancelled</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">attempt_operation</span><span class="p">()</span>
    <span class="k">except</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BlockingIOError" title="BlockingIOError"><span class="ne">BlockingIOError</span></a><span class="p">:</span>
        <span class="c1"># 需要阻塞并重试，下面会执行</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 操作成功，完成检查点然后返回</span>
        <span class="k">await</span> <span class="n">cancel_shielded_checkpoint</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">wait_for_operation_to_be_ready</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attempt_operation</span><span class="p">()</span>
        <span class="k">except</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BlockingIOError" title="BlockingIOError"><span class="ne">BlockingIOError</span></a><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
<p>这个逻辑有点复杂，但它完成了以下所有操作：</p>
<ul class="simple">
<li><p>每个成功的执行路径都会经过一个检查点（假设 <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code> 是一个无条件的检查点）</p></li>
<li><p>我们的 <a class="reference internal" href="ref-core/cancel_timeout.html#cancellable-primitives"><span class="std std-ref">取消语义</span></a> 规定，只有当操作未执行时，才会抛出 <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>。在早期退出分支中使用 <a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint" title="trio.lowlevel.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a> 实现了这一点。</p></li>
<li><p>在我们最终会阻塞的路径上，我们在阻塞之前不会通过任何调度点，从而避免了一些不必要的工作。</p></li>
<li><p>通过将 <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">True:</span></code> 循环放在 <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">BlockingIOError:</span></code> 块之外，避免了将 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BlockingIOError" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> 隐式地与 <code class="docutils literal notranslate"><span class="pre">attempt_operation</span></code> 或 <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code> 中抛出的任何错误串联起来。</p></li>
</ul>
<p>这些函数在其他情况下也非常有用。例如，当 <a class="reference internal" href="ref-core/threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> 在工作线程中调度一些工作时，它会阻塞直到工作完成（因此它是一个调度点），但默认情况下不允许取消。所以，为了确保该调用始终作为一个检查点执行，它会在启动线程之前调用 <a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled" title="trio.lowlevel.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a>。</p>
</div>
<input class="tab-input" id="tab-set--9-input--2" name="tab-set--9" type="radio"/><label class="tab-label" for="tab-set--9-input--2">英文</label><div class="tab-content docutils container">
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">checkpoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>A pure <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p>
<p>This checks for cancellation and allows other tasks to be scheduled,
without otherwise blocking.</p>
<p>Note that the scheduler has the option of ignoring this and continuing to
run the current task if it decides this is appropriate (e.g. for increased
efficiency).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(0)</span></code> (which is implemented by calling
<a class="reference internal" href="#trio.lowlevel.checkpoint" title="trio.lowlevel.checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint()</span></code></a>.)</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<p>The next two functions are used <em>together</em> to make up a checkpoint:</p>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">checkpoint_if_cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Issue a <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoint</span></a> if the calling context has been
cancelled.</p>
<p>Equivalent to (but potentially more efficient than):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">trio</span><span class="o">.</span><span class="n">current_effective_deadline</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="n">inf</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
</pre></div>
</div>
<p>This is either a no-op, or else it allow other tasks to be scheduled and
then raises <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>.</p>
<p>Typically used together with <a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint" title="trio.lowlevel.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">cancel_shielded_checkpoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Introduce a schedule point, but not a cancel point.</p>
<p>This is <em>not</em> a <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">checkpoint</span></a>, but it is half of a
checkpoint, and when combined with <a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled" title="trio.lowlevel.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> it can
make a full checkpoint.</p>
<p>Equivalent to (but potentially more efficient than):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">CancelScope</span><span class="p">(</span><span class="n">shield</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<p>These are commonly used in cases where you have an operation that
might-or-might-not block, and you want to implement Trio's standard
checkpoint semantics. Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">operation_that_maybe_blocks</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">checkpoint_if_cancelled</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">attempt_operation</span><span class="p">()</span>
    <span class="k">except</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BlockingIOError" title="BlockingIOError"><span class="ne">BlockingIOError</span></a><span class="p">:</span>
        <span class="c1"># need to block and then retry, which we do below</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># operation succeeded, finish the checkpoint then return</span>
        <span class="k">await</span> <span class="n">cancel_shielded_checkpoint</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">wait_for_operation_to_be_ready</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attempt_operation</span><span class="p">()</span>
        <span class="k">except</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BlockingIOError" title="BlockingIOError"><span class="ne">BlockingIOError</span></a><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
<p>This logic is a bit convoluted, but accomplishes all of the following:</p>
<ul class="simple">
<li><p>Every successful execution path passes through a checkpoint (assuming that <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code> is an unconditional checkpoint)</p></li>
<li><p>Our <a class="reference internal" href="ref-core/cancel_timeout.html#cancellable-primitives"><span class="std std-ref">cancellation semantics</span></a> say that <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> should only be raised if the operation didn't happen. Using <a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint" title="trio.lowlevel.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a> on the early-exit branch accomplishes this.</p></li>
<li><p>On the path where we do end up blocking, we don't pass through any schedule points before that, which avoids some unnecessary work.</p></li>
<li><p>Avoids implicitly chaining the <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BlockingIOError" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> with any errors raised by <code class="docutils literal notranslate"><span class="pre">attempt_operation</span></code> or <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code>, by keeping the <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">True:</span></code> loop outside of the <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">BlockingIOError:</span></code> block.</p></li>
</ul>
<p>These functions can also be useful in other situations. For example,
when <a class="reference internal" href="ref-core/threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> schedules some work to run in a
worker thread, it blocks until the work is finished (so it's a
schedule point), but by default it doesn't allow cancellation. So to
make sure that the call always acts as a checkpoint, it calls
<a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled" title="trio.lowlevel.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> before starting the thread.</p>
</div>
</div>
</section>
<section id="id13">
<h3>低级阻塞<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h3>
<p><strong>Low-level blocking</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--10-input--1" name="tab-set--10" type="radio"/><label class="tab-label" for="tab-set--10-input--1">中文</label><div class="tab-content docutils container">
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.wait_task_rescheduled">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_task_rescheduled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abort_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.wait_task_rescheduled" title="Link to this definition">¶</a></dt>
<dd><p>Put the current task to sleep, with cancellation support.</p>
<p>This is the lowest-level API for blocking in Trio. Every time a
<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> blocks, it does so by calling this function
(usually indirectly via some higher-level API).</p>
<p>This is a tricky interface with no guard rails. If you can use
<a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> or the built-in I/O wait functions instead, then you
should.</p>
<p>Generally the way it works is that before calling this function, you make
arrangements for "someone" to call <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task
at some later point.</p>
<p>Then you call <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, passing in <code class="docutils literal notranslate"><span class="pre">abort_func</span></code>, an
"abort callback".</p>
<p>(Terminology: in Trio, "aborting" is the process of attempting to
interrupt a blocked task to deliver a cancellation.)</p>
<p>There are two possibilities for what happens next:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></span></p>
<ol class="arabic">
<li><p>"Someone" calls <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task, and
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> returns or raises whatever value or error
was passed to <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p></li>
<li><p>The call's context transitions to a cancelled state (e.g. due to a
timeout expiring). When this happens, the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> is called. Its
interface looks like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">abort_func</span><span class="p">(</span><span class="n">raise_cancel</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">Abort</span><span class="o">.</span><span class="n">SUCCEEDED</span>  <span class="c1"># or FAILED</span>
</pre></div>
</div>
<p>It should attempt to clean up any state associated with this call, and
in particular, arrange that <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> will <em>not</em> be called
later. If (and only if!) it is successful, then it should return
<a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, in which case the task will automatically be
rescheduled with an appropriate <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> error.</p>
<p>Otherwise, it should return <a class="reference internal" href="#id14" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. This means that the
task can't be cancelled at this time, and still has to make sure that
"someone" eventually calls <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p>
<p>At that point there are again two possibilities. You can simply ignore
the cancellation altogether: wait for the operation to complete and
then reschedule and continue as normal. (For example, this is what
<a class="reference internal" href="ref-core/threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> does if cancellation is disabled.)
The other possibility is that the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> does succeed in
cancelling the operation, but for some reason isn't able to report that
right away. (Example: on Windows, it's possible to request that an
async ("overlapped") I/O operation be cancelled, but this request is
<em>also</em> asynchronous – you don't find out until later whether the
operation was actually cancelled or not.)  To report a delayed
cancellation, then you should reschedule the task yourself, and call
the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback passed to <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> to raise a
<a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> (or possibly <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>) exception
into this task. Either of the approaches sketched below can work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Option 1:</span>
<span class="c1"># Catch the exception from raise_cancel and inject it into the task.</span>
<span class="c1"># (This is what Trio does automatically for you if you return</span>
<span class="c1"># Abort.SUCCEEDED.)</span>
<span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">reschedule</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">outcome</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">raise_cancel</span><span class="p">))</span>

<span class="c1"># Option 2:</span>
<span class="c1"># wait to be woken by "someone", and then decide whether to raise</span>
<span class="c1"># the error from inside the task.</span>
<span class="n">outer_raise_cancel</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span> <span class="nf">abort</span><span class="p">(</span><span class="n">inner_raise_cancel</span><span class="p">):</span>
    <span class="k">nonlocal</span> <span class="n">outer_raise_cancel</span>
    <span class="n">outer_raise_cancel</span> <span class="o">=</span> <span class="n">inner_raise_cancel</span>
    <span class="n">TRY_TO_CANCEL_OPERATION</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">Abort</span><span class="o">.</span><span class="n">FAILED</span>
<span class="k">await</span> <span class="n">wait_task_rescheduled</span><span class="p">(</span><span class="n">abort</span><span class="p">)</span>
<span class="k">if</span> <span class="n">OPERATION_WAS_SUCCESSFULLY_CANCELLED</span><span class="p">:</span>
    <span class="c1"># raises the error</span>
    <span class="n">outer_raise_cancel</span><span class="p">()</span>
</pre></div>
</div>
<p>In any case it's guaranteed that we only call the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> at most
once per call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p>
</li>
</ol>
<p>Sometimes, it's useful to be able to share some mutable sleep-related data
between the sleeping task, the abort function, and the waking task. You
can use the sleeping task's <a class="reference internal" href="#trio.lowlevel.Task.custom_sleep_data" title="trio.lowlevel.Task.custom_sleep_data"><code class="xref py py-data docutils literal notranslate"><span class="pre">custom_sleep_data</span></code></a> attribute to
store this data, and Trio won't touch it, except to make sure that it gets
cleared when the task is rescheduled.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> raises an error, or returns any value other than
<a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> or <a class="reference internal" href="#id14" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>, then Trio will crash
violently. Be careful! Similarly, it is entirely possible to deadlock a
Trio program by failing to reschedule a blocked task, or cause havoc by
calling <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> too many times. Remember what we said up
above about how you should use a higher-level API if at all possible?</p>
</div>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.Abort">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">Abort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names=&lt;not</span> <span class="pre">given&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.Abort" title="Link to this definition">¶</a></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/enum.html#enum.Enum" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a></p>
<p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/enum.html#enum.Enum" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a> used as the return value from abort functions.</p>
<p>See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.</p>
<dl class="py data">
<dt class="sig sig-object py" id="trio.lowlevel.Abort.SUCCEEDED">
<span class="sig-name descname"><span class="pre">SUCCEEDED</span></span><a class="headerlink" href="#trio.lowlevel.Abort.SUCCEEDED" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="trio.lowlevel.Abort.FAILED">
<span class="sig-name descname"><span class="pre">FAILED</span></span><a class="headerlink" href="#trio.lowlevel.Abort.FAILED" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.reschedule">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">reschedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">next_send=&lt;object</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.reschedule" title="Link to this definition">¶</a></dt>
<dd><p>Reschedule the given task with the given
<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><code class="xref py py-class docutils literal notranslate"><span class="pre">outcome.Outcome</span></code></a>.</p>
<p>See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for the gory details.</p>
<p>There must be exactly one call to <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> for every call to
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>. (And when counting, keep in mind that
returning <a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> from an abort callback is equivalent
to calling <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> once.)</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- the task to be rescheduled. Must be blocked
in a call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li>
<li><p><strong>next_send</strong> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><em>outcome.Outcome</em></a>) -- the value (or error) to return (or
raise) from <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<p>这里有一个使用 <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> 直接实现的锁类示例。该实现存在一些缺陷，包括缺乏公平性、O(n) 的取消操作、缺少错误检查、未在非阻塞路径上插入检查点等。如果你真的想实现自己的锁，应该研究 <a class="reference internal" href="ref-core/task_sync.html#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a> 的实现，并使用 <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a>，它为你解决了一些这些问题。但这个示例确实说明了 <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> API 的基本结构：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NotVeryGoodLock</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_held</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 我们可能需要多次尝试才能获得锁。</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_held</span><span class="p">:</span>
            <span class="c1"># 有其他人持有锁，因此我们需要等待。</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">abort_fn</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">Abort</span><span class="o">.</span><span class="n">SUCCEEDED</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">wait_task_rescheduled</span><span class="p">(</span><span class="n">abort_fn</span><span class="p">)</span>
            <span class="c1"># 在这一点，锁已经被释放了——但是可能在我们醒来之前，</span>
            <span class="c1"># 别人已经抢先拿到了锁。所以我们要重新检查 'while' 条件。</span>
        <span class="c1"># 如果我们到达这一点，意味着 'while' 条件刚刚失败，所以我们知道没有人持有锁，</span>
        <span class="c1"># 并且我们可以获取它。</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_held</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_held</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="p">:</span>
            <span class="n">woken_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">reschedule</span><span class="p">(</span><span class="n">woken_task</span><span class="p">)</span>
</pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--10-input--2" name="tab-set--10" type="radio"/><label class="tab-label" for="tab-set--10-input--2">英文</label><div class="tab-content docutils container">
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">wait_task_rescheduled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abort_func</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Put the current task to sleep, with cancellation support.</p>
<p>This is the lowest-level API for blocking in Trio. Every time a
<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> blocks, it does so by calling this function
(usually indirectly via some higher-level API).</p>
<p>This is a tricky interface with no guard rails. If you can use
<a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> or the built-in I/O wait functions instead, then you
should.</p>
<p>Generally the way it works is that before calling this function, you make
arrangements for "someone" to call <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task
at some later point.</p>
<p>Then you call <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, passing in <code class="docutils literal notranslate"><span class="pre">abort_func</span></code>, an
"abort callback".</p>
<p>(Terminology: in Trio, "aborting" is the process of attempting to
interrupt a blocked task to deliver a cancellation.)</p>
<p>There are two possibilities for what happens next:
:rtype: <span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Any" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></span></p>
<ol class="arabic">
<li><p>"Someone" calls <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task, and
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> returns or raises whatever value or error
was passed to <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p></li>
<li><p>The call's context transitions to a cancelled state (e.g. due to a
timeout expiring). When this happens, the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> is called. Its
interface looks like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">abort_func</span><span class="p">(</span><span class="n">raise_cancel</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">Abort</span><span class="o">.</span><span class="n">SUCCEEDED</span>  <span class="c1"># or FAILED</span>
</pre></div>
</div>
<p>It should attempt to clean up any state associated with this call, and
in particular, arrange that <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> will <em>not</em> be called
later. If (and only if!) it is successful, then it should return
<a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, in which case the task will automatically be
rescheduled with an appropriate <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> error.</p>
<p>Otherwise, it should return <a class="reference internal" href="#id14" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. This means that the
task can't be cancelled at this time, and still has to make sure that
"someone" eventually calls <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p>
<p>At that point there are again two possibilities. You can simply ignore
the cancellation altogether: wait for the operation to complete and
then reschedule and continue as normal. (For example, this is what
<a class="reference internal" href="ref-core/threads.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> does if cancellation is disabled.)
The other possibility is that the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> does succeed in
cancelling the operation, but for some reason isn't able to report that
right away. (Example: on Windows, it's possible to request that an
async ("overlapped") I/O operation be cancelled, but this request is
<em>also</em> asynchronous – you don't find out until later whether the
operation was actually cancelled or not.)  To report a delayed
cancellation, then you should reschedule the task yourself, and call
the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback passed to <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> to raise a
<a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> (or possibly <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>) exception
into this task. Either of the approaches sketched below can work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Option 1:</span>
<span class="c1"># Catch the exception from raise_cancel and inject it into the task.</span>
<span class="c1"># (This is what Trio does automatically for you if you return</span>
<span class="c1"># Abort.SUCCEEDED.)</span>
<span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">reschedule</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">outcome</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">raise_cancel</span><span class="p">))</span>

<span class="c1"># Option 2:</span>
<span class="c1"># wait to be woken by "someone", and then decide whether to raise</span>
<span class="c1"># the error from inside the task.</span>
<span class="n">outer_raise_cancel</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span> <span class="nf">abort</span><span class="p">(</span><span class="n">inner_raise_cancel</span><span class="p">):</span>
    <span class="k">nonlocal</span> <span class="n">outer_raise_cancel</span>
    <span class="n">outer_raise_cancel</span> <span class="o">=</span> <span class="n">inner_raise_cancel</span>
    <span class="n">TRY_TO_CANCEL_OPERATION</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">Abort</span><span class="o">.</span><span class="n">FAILED</span>
<span class="k">await</span> <span class="n">wait_task_rescheduled</span><span class="p">(</span><span class="n">abort</span><span class="p">)</span>
<span class="k">if</span> <span class="n">OPERATION_WAS_SUCCESSFULLY_CANCELLED</span><span class="p">:</span>
    <span class="c1"># raises the error</span>
    <span class="n">outer_raise_cancel</span><span class="p">()</span>
</pre></div>
</div>
<p>In any case it's guaranteed that we only call the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> at most
once per call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p>
</li>
</ol>
<p>Sometimes, it's useful to be able to share some mutable sleep-related data
between the sleeping task, the abort function, and the waking task. You
can use the sleeping task's <a class="reference internal" href="#trio.lowlevel.Task.custom_sleep_data" title="trio.lowlevel.Task.custom_sleep_data"><code class="xref py py-data docutils literal notranslate"><span class="pre">custom_sleep_data</span></code></a> attribute to
store this data, and Trio won't touch it, except to make sure that it gets
cleared when the task is rescheduled.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> raises an error, or returns any value other than
<a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> or <a class="reference internal" href="#id14" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>, then Trio will crash
violently. Be careful! Similarly, it is entirely possible to deadlock a
Trio program by failing to reschedule a blocked task, or cause havoc by
calling <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> too many times. Remember what we said up
above about how you should use a higher-level API if at all possible?</p>
</div>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">Abort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names=&lt;not</span> <span class="pre">given&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary=None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>基类：<a class="reference external" href="https://docs.python.org/zh-cn/3/library/enum.html#enum.Enum" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a></p>
<p><a class="reference external" href="https://docs.python.org/zh-cn/3/library/enum.html#enum.Enum" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a> used as the return value from abort functions.</p>
<p>See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.</p>
<dl class="py data">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">SUCCEEDED</span></span><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="id14">
<span class="sig-name descname"><span class="pre">FAILED</span></span><a class="headerlink" href="#id14" title="Link to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">reschedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">next_send=&lt;object</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reschedule the given task with the given
<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><code class="xref py py-class docutils literal notranslate"><span class="pre">outcome.Outcome</span></code></a>.</p>
<p>See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for the gory details.</p>
<p>There must be exactly one call to <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> for every call to
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>. (And when counting, keep in mind that
returning <a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> from an abort callback is equivalent
to calling <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> once.)</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) -- the task to be rescheduled. Must be blocked
in a call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li>
<li><p><strong>next_send</strong> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><em>outcome.Outcome</em></a>) -- the value (or error) to return (or
raise) from <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
<p>Here's an example lock class implemented using
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> directly. This implementation has a
number of flaws, including lack of fairness, O(n) cancellation,
missing error checking, failure to insert a checkpoint on the
non-blocking path, etc. If you really want to implement your own lock,
then you should study the implementation of <a class="reference internal" href="ref-core/task_sync.html#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a> and use
<a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a>, which handles some of these issues for you. But
this does serve to illustrate the basic structure of the
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> API:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NotVeryGoodLock</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_held</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We might have to try several times to acquire the lock.</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_held</span><span class="p">:</span>
            <span class="c1"># Someone else has the lock, so we have to wait.</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">abort_fn</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">Abort</span><span class="o">.</span><span class="n">SUCCEEDED</span>
            <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">wait_task_rescheduled</span><span class="p">(</span><span class="n">abort_fn</span><span class="p">)</span>
            <span class="c1"># At this point the lock was released -- but someone else</span>
            <span class="c1"># might have swooped in and taken it again before we</span>
            <span class="c1"># woke up. So we loop around to check the 'while' condition</span>
            <span class="c1"># again.</span>
        <span class="c1"># if we reach this point, it means that the 'while' condition</span>
        <span class="c1"># has just failed, so we know no-one is holding the lock, and</span>
        <span class="c1"># we can take it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_held</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_held</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="p">:</span>
            <span class="n">woken_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_tasks</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">reschedule</span><span class="p">(</span><span class="n">woken_task</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id15">
<h2>任务 API<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h2>
<p><strong>Task API</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_root_task">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_root_task</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.current_root_task" title="Link to this definition">¶</a></dt>
<dd><p>Returns the current root <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p>This is the task that is the ultimate parent of all other tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.current_task">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">current_task</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.current_task" title="Link to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object representing the current task.</p>
<dl class="field-list simple">
<dt class="field-odd">返回<span class="colon">:</span></dt>
<dd class="field-odd"><p>the <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> that called <a class="reference internal" href="#trio.lowlevel.current_task" title="trio.lowlevel.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task">Task</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="trio.lowlevel.Task">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">Task</span></span><a class="headerlink" href="#trio.lowlevel.Task" title="Link to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object represents a concurrent "thread" of
execution. It has no public constructor; Trio internally creates a
<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object for each call to <code class="docutils literal notranslate"><span class="pre">nursery.start(...)</span></code> or
<code class="docutils literal notranslate"><span class="pre">nursery.start_soon(...)</span></code>.</p>
<p>Its public members are mostly useful for introspection and
debugging:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#trio.lowlevel.Task.name" title="Link to this definition">¶</a></dt>
<dd><p>String containing this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>'s name. Usually the name
of the function this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> is running, but can be
overridden by passing <code class="docutils literal notranslate"><span class="pre">name=</span></code> to <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">start_soon</span></code>.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.coro">
<span class="sig-name descname"><span class="pre">coro</span></span><a class="headerlink" href="#trio.lowlevel.Task.coro" title="Link to this definition">¶</a></dt>
<dd><p>This task's coroutine object.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="trio.lowlevel.Task.iter_await_frames">
<em class="property"><span class="pre">for</span> <span class="pre">...</span> <span class="pre">in</span> </em><span class="sig-name descname"><span class="pre">iter_await_frames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.Task.iter_await_frames" title="Link to this definition">¶</a></dt>
<dd><p>Iterates recursively over the coroutine-like objects this
task is waiting on, yielding the frame and line number at each
frame.</p>
<p>This is similar to <cite>traceback.walk_stack</cite> in a synchronous
context. Note that <cite>traceback.walk_stack</cite> returns frames from
the bottom of the call stack to the top, while this function
starts from <cite>Task.coro &lt;trio.lowlevel.Task.coro&gt;</cite> and works it
way down.</p>
<p>Example usage: extracting a stack trace:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">traceback</span>

<span class="k">def</span> <span class="nf">print_stack_for_task</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">StackSummary</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">iter_await_frames</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">format</span><span class="p">()))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Iterator" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>[<a class="reference external" href="https://docs.python.org/3/library/types.html/FrameType" title="（在 Python v3.12）"><code class="xref py py-class docutils literal notranslate"><span class="pre">FrameType</span></code></a>, <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>]]</span></p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.context">
<span class="sig-name descname"><span class="pre">context</span></span><a class="headerlink" href="#trio.lowlevel.Task.context" title="Link to this definition">¶</a></dt>
<dd><p>This task's <a class="reference external" href="https://docs.python.org/zh-cn/3/library/contextvars.html#contextvars.Context" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.parent_nursery">
<span class="sig-name descname"><span class="pre">parent_nursery</span></span><a class="headerlink" href="#trio.lowlevel.Task.parent_nursery" title="Link to this definition">¶</a></dt>
<dd><p>The nursery this task is inside (or None if this is the "init"
task).</p>
<p>Example use case: drawing a visualization of the task tree in a
debugger.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.eventual_parent_nursery">
<span class="sig-name descname"><span class="pre">eventual_parent_nursery</span></span><a class="headerlink" href="#trio.lowlevel.Task.eventual_parent_nursery" title="Link to this definition">¶</a></dt>
<dd><p>The nursery this task will be inside after it calls
<code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>.</p>
<p>If this task has already called <code class="docutils literal notranslate"><span class="pre">started()</span></code>, or if it was not
spawned using <cite>nursery.start() &lt;trio.Nursery.start&gt;</cite>, then
its <cite>eventual_parent_nursery</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.child_nurseries">
<span class="sig-name descname"><span class="pre">child_nurseries</span></span><a class="headerlink" href="#trio.lowlevel.Task.child_nurseries" title="Link to this definition">¶</a></dt>
<dd><p>The nurseries this task contains.</p>
<p>This is a list, with outer nurseries before inner nurseries.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="trio.lowlevel.Task.custom_sleep_data">
<span class="sig-name descname"><span class="pre">custom_sleep_data</span></span><a class="headerlink" href="#trio.lowlevel.Task.custom_sleep_data" title="Link to this definition">¶</a></dt>
<dd><p>Trio doesn't assign this variable any meaning, except that it
sets it to <code class="docutils literal notranslate"><span class="pre">None</span></code> whenever a task is rescheduled. It can be
used to share data between the different tasks involved in
putting a task to sleep and then waking it up again. (See
<a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.)</p>
</dd></dl>
</dd></dl>
</section>
<section id="guest-mode">
<span id="id16"></span><h2>使用“访客模式”在其他事件循环之上运行 Trio<a class="headerlink" href="#guest-mode" title="Link to this heading">¶</a></h2>
<p><strong>Using "guest mode" to run Trio on top of other event loops</strong></p>
<section id="id17">
<h3>什么是“访客模式”？<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h3>
<p><strong>What is "guest mode"?</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--11-input--1" name="tab-set--11" type="radio"/><label class="tab-label" for="tab-set--11-input--1">中文</label><div class="tab-content docutils container">
<p>事件循环充当中央协调器，管理程序中的所有 IO 操作。通常，这意味着你的应用程序需要选择一个事件循环，并将其用于所有操作。但如果你喜欢 Trio，并且还需要使用像 <a class="reference external" href="https://en.wikipedia.org/wiki/Qt_(software)">Qt</a> 或 <a class="reference external" href="https://www.pygame.org/">PyGame</a> 这样有自己事件循环的框架呢？那你就需要一种方法同时运行这两个事件循环。</p>
<p>确实可以将多个事件循环结合起来，但标准的做法都有显著的缺点：</p>
<ul class="simple">
<li><p><strong>轮询：</strong> 这种方式是使用 <a class="reference external" href="https://en.wikipedia.org/wiki/Busy_waiting">忙等待</a> 来手动检查两个事件循环的 IO，每秒多次。这会增加延迟，浪费 CPU 时间和电力。</p></li>
<li><p><strong>可插拔 IO 后端：</strong> 这种方式是将一个事件循环的 API 重新实现为另一个事件循环的 API，这样你实际上只有一个事件循环。这需要为每对你想要集成的事件循环进行大量工作，并且不同的后端最终会导致不一致的行为，迫使用户按照最小公分母来编程。如果两个事件循环暴露的功能集不同，甚至可能无法将其中一个事件循环实现为另一个的形式。</p></li>
<li><p><strong>在不同的线程中运行两个事件循环：</strong> 这种方法可行，但大多数事件循环的 API 都不是线程安全的，因此在这种方法中，你需要小心追踪哪些代码在哪个事件循环中运行，并且每次与另一个事件循环交互时都必须使用显式的线程间消息传递——否则就可能面临隐晦的竞态条件和数据损坏。</p></li>
</ul>
<p>因此，Trio 提供了第四种选择：<strong>来宾模式</strong>。来宾模式允许你在其他“主机”事件循环（如 Qt）上运行 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>。它的优点有：</p>
<ul>
<li><p><strong>高效性：</strong> 来宾模式是事件驱动的，而不是使用忙等待，因此它具有低延迟，不浪费电力。</p></li>
<li><p><strong>无需考虑线程：</strong> 你的 Trio 代码与主机事件循环运行在同一个线程中，因此你可以自由地从主机调用同步的 Trio API，并且从 Trio 调用同步的主机 API。例如，如果你正在使用 Qt 作为主机循环制作 GUI 应用，那么创建一个 <a class="reference external" href="https://doc.qt.io/qt-5/qpushbutton.html">取消按钮</a> 并将其连接到 <a class="reference internal" href="ref-core/cancel_timeout.html#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.CancelScope</span></code></a> 就像编写以下代码一样简单：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Trio 代码可以创建 Qt 对象而不需要任何特别的步骤...</span>
<span class="n">my_cancel_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s2">"Cancel"</span><span class="p">)</span>
<span class="c1"># ...Qt 也可以轻松地回调 Trio</span>
<span class="n">my_cancel_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">my_cancel_scope</span><span class="o">.</span><span class="n">cancel</span><span class="p">)</span>
</pre></div>
</div>
<p>（对于异步 API，事情就不那么简单了，但你可以使用同步 API 在两个世界之间建立显式的桥梁，例如通过队列来传递异步函数及其结果。）</p>
</li>
<li><p><strong>一致的行为：</strong> 来宾模式使用与常规 Trio 相同的代码：相同的调度器，相同的 IO 代码，完全相同的实现。所以你可以获得完整的功能集，所有东西都会按预期行为工作。</p></li>
<li><p><strong>简单的集成和广泛的兼容性：</strong> 几乎所有的事件循环都提供某种线程安全的“调度回调”操作，而这正是你需要的，可以用它作为主机事件循环。</p></li>
</ul>
</div>
<input class="tab-input" id="tab-set--11-input--2" name="tab-set--11" type="radio"/><label class="tab-label" for="tab-set--11-input--2">英文</label><div class="tab-content docutils container">
<p>An event loop acts as a central coordinator to manage all the IO happening in your program. Normally, that means that your application has to pick one event loop, and use it for everything. But what if you like Trio, but also need to use a framework like <a class="reference external" href="https://en.wikipedia.org/wiki/Qt_(software)">Qt</a> or <a class="reference external" href="https://www.pygame.org/">PyGame</a> that has its own event loop? Then you need some way to run both event loops at once.</p>
<p>It is possible to combine event loops, but the standard approaches all have significant downsides:</p>
<ul class="simple">
<li><p><strong>Polling:</strong> this is where you use a <a class="reference external" href="https://en.wikipedia.org/wiki/Busy_waiting">busy-loop</a> to manually check for IO on both event loops many times per second. This adds latency, and wastes CPU time and electricity.</p></li>
<li><p><strong>Pluggable IO backends:</strong> this is where you reimplement one of the event loop APIs on top of the other, so you effectively end up with just one event loop. This requires a significant amount of work for each pair of event loops you want to integrate, and different backends inevitably end up with inconsistent behavior, forcing users to program against the least-common-denominator. And if the two event loops expose different feature sets, it may not even be possible to implement one in terms of the other.</p></li>
<li><p><strong>Running the two event loops in separate threads:</strong> This works, but most event loop APIs aren't thread-safe, so in this approach you need to keep careful track of which code runs on which event loop, and remember to use explicit inter-thread messaging whenever you interact with the other loop – or else risk obscure race conditions and data corruption.</p></li>
</ul>
<p>That's why Trio offers a fourth option: <strong>guest mode</strong>. Guest mode lets you execute <cite>trio.run</cite> on top of some other "host" event loop, like Qt. Its advantages are:</p>
<ul>
<li><p>Efficiency: guest mode is event-driven instead of using a busy-loop, so it has low latency and doesn't waste electricity.</p></li>
<li><p>No need to think about threads: your Trio code runs in the same thread as the host event loop, so you can freely call sync Trio APIs from the host, and call sync host APIs from Trio. For example, if you're making a GUI app with Qt as the host loop, then making a <a class="reference external" href="https://doc.qt.io/qt-5/qpushbutton.html">cancel button</a> and connecting it to a <cite>trio.CancelScope</cite> is as easy as writing:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Trio code can create Qt objects without any special ceremony...</span>
<span class="n">my_cancel_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s2">"Cancel"</span><span class="p">)</span>
<span class="c1"># ...and Qt can call back to Trio just as easily</span>
<span class="n">my_cancel_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">my_cancel_scope</span><span class="o">.</span><span class="n">cancel</span><span class="p">)</span>
</pre></div>
</div>
<p>(For async APIs, it's not that simple, but you can use sync APIs to
build explicit bridges between the two worlds, e.g. by passing async
functions and their results back and forth through queues.)</p>
</div></blockquote>
</li>
<li><p>Consistent behavior: guest mode uses the same code as regular Trio: the same scheduler, same IO code, same everything. So you get the full feature set and everything acts the way you expect.</p></li>
<li><p>Simple integration and broad compatibility: pretty much every event loop offers some threadsafe "schedule a callback" operation, and that's all you need to use it as a host loop.</p></li>
</ul>
</div>
</div>
</section>
<section id="id18">
<h3>真的吗？怎么可能？<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h3>
<p><strong>Really? How is that possible?</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--12-input--1" name="tab-set--12" type="radio"/><label class="tab-label" for="tab-set--12-input--1">中文</label><div class="tab-content docutils container">
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>你可以在不阅读本节的情况下使用来宾模式。此部分是为那些喜欢了解工作原理的人准备的。</p>
</div>
<p>所有事件循环的基本结构是相同的。它们反复执行两个操作：</p>
<ol class="arabic simple">
<li><p>等待操作系统通知它们发生了某些有趣的事情，比如数据到达一个套接字或者超时已过。它们通过调用平台特定的 <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> 系统调用来实现这一点——例如 <code class="docutils literal notranslate"><span class="pre">select</span></code>、 <code class="docutils literal notranslate"><span class="pre">epoll</span></code>、 <code class="docutils literal notranslate"><span class="pre">kqueue</span></code>、 <code class="docutils literal notranslate"><span class="pre">GetQueuedCompletionEvents</span></code> 等等。</p></li>
<li><p>执行所有关心所发生事情的用户任务，然后返回第一步。</p></li>
</ol>
<p>问题出在第一步。两个不同的事件循环在同一个线程中可以轮流执行第二步中的用户任务，但当它们处于空闲状态且没有任何事情发生时，它们不能同时调用各自的 <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> 函数。</p>
<p>“轮询”和“可插拔后端”策略通过修改事件循环来解决这个问题，让两个第一步可以在同一线程中同时运行。将所有内容保持在一个线程中对第二步很好，但第一步的修改会引发问题。</p>
<p>“分离线程”策略通过将两个步骤移动到不同的线程中来解决这个问题。这使得第一步可以正常工作，但缺点是，第二步中的用户任务也会在单独的线程中运行，因此用户必须处理线程间的协调问题。</p>
<p>来宾模式的想法是结合每种方法的优点：我们将 Trio 的第一步移到一个独立的工作线程中，同时将 Trio 的第二步保持在主机主线程中。这样，当应用程序空闲时，两个事件循环会在各自的线程中同时执行 <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code>。但是，当应用程序唤醒并且你的代码实际运行时，所有操作都发生在一个线程中。线程的复杂性完全由 Trio 透明地处理。</p>
<p>具体来说，我们将 Trio 的内部事件循环展开成一个回调链，每当一个回调完成时，它会根据需要将下一个回调安排到主机事件循环或工作线程中。因此，主机事件循环需要提供的唯一功能是将回调从工作线程调度到主线程。</p>
<p>Trio 与主机事件循环之间的协调确实增加了一些开销。主要的成本是在线程之间切换，因为这需要线程间消息传递。这个成本是比较低的（大约几微秒，假设主机事件循环高效实现），但并不是免费的。</p>
<p>不过，我们可以进行一个不错的优化：我们只在 <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> 调用实际上进入休眠时需要线程，也就是说，当 Trio 部分的程序空闲且没有任务时。在切换到工作线程之前，我们会再次检查是否空闲，如果不是，就跳过工作线程，直接进入第二步。这意味着你的应用程序只有在它本该休眠的时候才会支付额外的线程切换成本，因此它对应用程序整体性能的影响应该是最小的。</p>
<p>总的开销将取决于你的主机事件循环、平台、应用程序等。但我们预计，在大多数情况下，以来宾模式运行的应用程序应该比使用 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 的相同代码慢 5-10%。如果你发现这个估算不适用于你的应用，请告诉我们，我们会看看是否能解决它！</p>
</div>
<input class="tab-input" id="tab-set--12-input--2" name="tab-set--12" type="radio"/><label class="tab-label" for="tab-set--12-input--2">英文</label><div class="tab-content docutils container">
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>You can use guest mode without reading this section. It's included for those who enjoy understanding how things work.</p>
</div>
<p>All event loops have the same basic structure. They loop through two operations, over and over:</p>
<ol class="arabic simple">
<li><p>Wait for the operating system to notify them that something interesting has happened, like data arriving on a socket or a timeout passing. They do this by invoking a platform-specific <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> system call – <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">epoll</span></code>, <code class="docutils literal notranslate"><span class="pre">kqueue</span></code>, <code class="docutils literal notranslate"><span class="pre">GetQueuedCompletionEvents</span></code>, etc.</p></li>
<li><p>Run all the user tasks that care about whatever happened, then go back to step 1.</p></li>
</ol>
<p>The problem here is step 1. Two different event loops on the same
thread can take turns running user tasks in step 2, but when they're
idle and nothing is happening, they can't both invoke their own
<code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> function at the same time.</p>
<p>The "polling" and "pluggable backend" strategies solve this by hacking
the loops so both step 1s can run at the same time in the same thread.
Keeping everything in one thread is great for step 2, but the step 1
hacks create problems.</p>
<p>The "separate threads" strategy solves this by moving both steps into
separate threads. This makes step 1 work, but the downside is that now
the user tasks in step 2 are running separate threads as well, so
users are forced to deal with inter-thread coordination.</p>
<p>The idea behind guest mode is to combine the best parts of each
approach: we move Trio's step 1 into a separate worker thread, while
keeping Trio's step 2 in the main host thread. This way, when the
application is idle, both event loops do their
<code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> at the same time in their own
threads. But when the app wakes up and your code is actually running,
it all happens in a single thread. The threading trickiness is all
handled transparently inside Trio.</p>
<p>Concretely, we unroll Trio's internal event loop into a chain of
callbacks, and as each callback finishes, it schedules the next
callback onto the host loop or a worker thread as appropriate. So the
only thing the host loop has to provide is a way to schedule a
callback onto the main thread from a worker thread.</p>
<p>Coordinating between Trio and the host loop does add some overhead.
The main cost is switching in and out of the background thread, since
this requires cross-thread messaging. This is cheap (on the order of a
few microseconds, assuming your host loop is implemented efficiently),
but it's not free.</p>
<p>But, there's a nice optimization we can make: we only <em>need</em> the
thread when our <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> call actually
sleeps, that is, when the Trio part of your program is idle and has
nothing to do. So before we switch into the worker thread, we
double-check whether we're idle, and if not, then we skip the worker
thread and jump directly to step 2. This means that your app only pays
the extra thread-switching penalty at moments when it would otherwise
be sleeping, so it should have minimal effect on your app's overall
performance.</p>
<p>The total overhead will depend on your host loop, your platform, your
application, etc. But we expect that in most cases, apps running in
guest mode should only be 5-10% slower than the same code using
<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. If you find that's not true for your app, then please let
us know and we'll see if we can fix it!</p>
</div>
</div>
</section>
<section id="guest-run-implementation">
<span id="id19"></span><h3>为您最喜欢的事件循环实现访客模式<a class="headerlink" href="#guest-run-implementation" title="Link to this heading">¶</a></h3>
<p><strong>Implementing guest mode for your favorite event loop</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--13-input--1" name="tab-set--13" type="radio"/><label class="tab-label" for="tab-set--13-input--1">中文</label><div class="tab-content docutils container">
<p>让我们看看你需要做些什么，将 Trio 的来宾模式与最喜欢的事件循环结合起来。将本节视为一个检查清单。</p>
<p><strong>入门：</strong> 第一步是让一些基本功能工作。这里是一个在 asyncio 上运行 Trio 的最小示例，你可以将其作为模板：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="asyncio"><span class="nn">asyncio</span></a>
<span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="c1"># 一个小型的 Trio 程序</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">trio_main</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" title="range"><span class="nb">range</span></a><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="s2">"Hello from Trio!"</span><span class="p">)</span>
        <span class="c1"># 这是在 Trio 内部，所以我们必须使用 Trio 的 API</span>
        <span class="k">await</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">"trio done!"</span>

<span class="c1"># 将其作为来宾运行在 asyncio 中的代码</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">asyncio_main</span><span class="p">():</span>
    <span class="n">asyncio_loop</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span></a><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sync_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">asyncio_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">done_callback</span><span class="p">(</span><span class="n">trio_main_outcome</span><span class="p">):</span>
        <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="sa">f</span><span class="s2">"Trio 程序结束，结果是: </span><span class="si">{</span><span class="n">trio_main_outcome</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="c1"># 这是魔法发生的地方：</span>
    <a class="sphinx-codeautolink-a" href="reference-lowlevel.html#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">start_guest_run</span></a><span class="p">(</span>
        <span class="n">trio_main</span><span class="p">,</span>
        <span class="n">run_sync_soon_threadsafe</span><span class="o">=</span><span class="n">run_sync_soon_threadsafe</span><span class="p">,</span>
        <span class="n">done_callback</span><span class="o">=</span><span class="n">done_callback</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># 让主机循环运行一段时间，以便 trio_main 有时间完成。</span>
    <span class="c1"># （警告：这是一种 hack，下面会讨论更好的方法。）</span>
    <span class="c1">#</span>
    <span class="c1"># 这个函数在 asyncio 中，因此我们必须使用 asyncio 的 API。</span>
    <span class="k">await</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio-runner.html#asyncio.run" title="asyncio.run"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">asyncio_main</span><span class="p">())</span>
</pre></div>
</div>
<p>你可以看到，我们使用了特定于 asyncio 的 API 启动一个事件循环，
然后调用了 <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.lowlevel.start_guest_run()</span></code></a>。这个函数与 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 非常相似，
并且接受相同的所有参数。但它有两个区别：</p>
<p>首先，它不会阻塞直到 <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> 完成，而是将 <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> 安排在主机循环上运行，
然后立即返回。所以 <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> 是在后台运行的——这就是为什么我们需要等待并给它时间完成的原因。</p>
<p>其次，它需要两个额外的关键字参数：
<code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code> 和 <code class="docutils literal notranslate"><span class="pre">done_callback</span></code>。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>，我们需要一个函数，这个函数接收一个同步回调并将其安排在主机事件循环中运行。这个函数需要是“线程安全的”，也就是说，你可以从任何线程安全地调用它。所以你需要搞清楚如何使用主机循环的 API 编写一个这样的函数。对于 asyncio，这很简单，因为 <code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.call_soon_threadsafe()</span></code> 正好做了我们需要的事情；而对于其他事件循环，可能会更加复杂。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">done_callback</span></code>，你传入一个函数，当 Trio 运行结束时，Trio 会自动调用该函数，这样你就能知道它完成了并了解发生了什么。对于这个基本的入门版本，我们只是打印结果；在下一节中，我们会讨论更好的替代方案。</p>
<p>到这个阶段，你应该能够在主机事件循环中运行一个简单的 Trio 程序。接下来，我们将把这个原型转变为更稳健的实现。</p>
<p><strong>事件循环的生命周期：</strong> 大多数事件循环中最棘手的事情之一是正确地关闭事件循环。并且当有两个事件循环时，这变得更加困难！</p>
<p>如果可能的话，我们建议遵循以下模式：</p>
<ul class="simple">
<li><p>启动主机事件循环</p></li>
<li><p>立即调用 <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a> 来启动 Trio</p></li>
<li><p>当 Trio 完成并且你的 <code class="docutils literal notranslate"><span class="pre">done_callback</span></code> 被调用时，关闭主机事件循环</p></li>
<li><p>确保没有其他代码关闭主机事件循环</p></li>
</ul>
<p>这样，你的两个事件循环就有相同的生命周期，当 Trio 函数完成时，程序会自动退出。</p>
<p>下面是如何扩展我们的 asyncio 示例来实现这个模式：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 改进版本，在 Trio 完成后正确关闭</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">asyncio_main</span><span class="p">():</span>
    <span class="n">asyncio_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sync_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">asyncio_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

<span class="hll">    <span class="c1"># 修改后的 'done' 回调：设置一个 Future</span>
</span><span class="hll">    <span class="n">done_fut</span> <span class="o">=</span> <span class="n">asyncio_loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
</span><span class="hll">    <span class="k">def</span> <span class="nf">done_callback</span><span class="p">(</span><span class="n">trio_main_outcome</span><span class="p">):</span>
</span><span class="hll">        <span class="n">done_fut</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">trio_main_outcome</span><span class="p">)</span>
</span>
    <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">start_guest_run</span><span class="p">(</span>
        <span class="n">trio_main</span><span class="p">,</span>
        <span class="n">run_sync_soon_threadsafe</span><span class="o">=</span><span class="n">run_sync_soon_threadsafe</span><span class="p">,</span>
        <span class="n">done_callback</span><span class="o">=</span><span class="n">done_callback</span><span class="p">,</span>
    <span class="p">)</span>

<span class="hll">    <span class="c1"># 等待来宾程序完成</span>
</span><span class="hll">    <span class="n">trio_main_outcome</span> <span class="o">=</span> <span class="k">await</span> <span class="n">done_fut</span>
</span><span class="hll">    <span class="c1"># 传递返回值或异常</span>
</span><span class="hll">    <span class="k">return</span> <span class="n">trio_main_outcome</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span>
</span></pre></div>
</div>
<p>然后，你可以将所有这些机制封装在一个实用函数中，
它暴露一个类似于 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 的 API，但能同时运行两个事件循环：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trio_run_with_asyncio</span><span class="p">(</span><span class="n">trio_main</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">trio_run_kwargs</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncio_main</span><span class="p">():</span>
        <span class="c1"># 同上</span>
        <span class="o">...</span>

    <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">asyncio_main</span><span class="p">())</span>
</pre></div>
</div>
<p>从技术上讲，使用其他模式也是可能的。但你必须遵守一些重要的限制：</p>
<ul>
<li><p><strong>你必须让 Trio 程序运行到完成。</strong> 许多事件循环允许你在任何时刻停止事件循环，而任何挂起的回调/任务等...就不会运行了。Trio 遵循一种更结构化的系统，你可以取消任务，但代码总是会运行到完成，因此 <code class="docutils literal notranslate"><span class="pre">finally</span></code> 块会执行，资源会被清理等。如果你在 <code class="docutils literal notranslate"><span class="pre">done_callback</span></code> 被调用之前提前停止了主机事件循环，那么这会中断 Trio 程序的运行，且没有机会进行清理。这可能会导致代码处于不一致的状态，并且肯定会导致 Trio 的内部状态不一致，若你在该线程中再次使用 Trio，将会发生错误。</p>
<p>有些程序需要能够随时退出，例如响应 GUI 窗口的关闭或用户从菜单中选择“退出”。在这些情况下，我们建议将整个程序包装在一个 <a class="reference internal" href="ref-core/cancel_timeout.html#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.CancelScope</span></code></a> 中，并在你想退出时取消它。</p>
</li>
<li><p>每个主机事件循环只能同时运行一个 <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a>。如果你尝试启动第二个，将会引发错误。如果你需要同时运行多个 Trio 函数，那么应该启动一个单独的 Trio 运行，打开一个 nursery，然后将函数作为子任务启动在这个 nursery 中。</p></li>
<li><p>除非你或你的主机事件循环在启动 Trio 之前注册了 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.SIGINT" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> 的处理程序（这并不常见），否则 Trio 会接管对 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 的处理。由于 Trio 无法判断哪个主机代码是安全的进行中断，它将只向 Trio 部分的代码传递 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>。如果你的程序设置为在 Trio 部分退出时退出，这没问题，因为 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 会从 Trio 传播出去，然后触发主机事件循环的关闭，这正是你希望的行为。</p></li>
</ul>
<p>鉴于这些限制，我们认为最简单的方法是始终将两个事件循环一起启动和停止。</p>
<p><strong>信号管理：</strong> <a class="reference external" href="https://en.wikipedia.org/wiki/Signal_(IPC)">"信号"</a> 是一种低级的进程间通信原语。当你按下控制-C来终止程序时，就是使用了一个信号。Python 中的信号处理有 <a class="reference external" href="https://vorpus.org/blog/control-c-handling-in-python-and-trio/">很多复杂的部分</a>。
其中一部分是 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>，它用于确保事件循环在信号到达时能够唤醒并做出响应。
（如果你曾经遇到事件循环忽视控制-C的情况，可能是因为它们没有正确使用
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>。）</p>
<p>但是，只有一个事件循环可以同时使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>。在来宾模式下，这可能会导致问题：Trio 和主机事件循环可能会争夺谁来使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>。</p>
<p>某些事件循环（如 asyncio）如果没有在这场争斗中获胜，则无法正常工作。幸运的是，Trio 对此并不那么挑剔：只要 <em>有人</em> 确保程序在信号到达时能唤醒，它应该能正常工作。所以，如果你的主机事件循环需要使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>，那么你应该禁用 Trio 的 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> 支持，这样两个事件循环就能正常工作。</p>
<p>另一方面，如果你的主机事件循环不使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>，那么确保一切正常工作的唯一方法是 <em>启用</em> Trio 的 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> 支持。</p>
<p>默认情况下，Trio 假设你的主机事件循环没有使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>。它会尝试检测这种与主机事件循环冲突的情况，并打印警告——但不幸的是，在检测到时，损害已经发生。因此，如果你收到此警告，则应通过传递 <code class="docutils literal notranslate"><span class="pre">host_uses_signal_set_wakeup_fd=True</span></code> 给 <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a> 来禁用 Trio 的 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> 支持。</p>
<p>如果在初始原型中没有看到任何警告，你 <em>可能</em> 没问题。但要确保无误，最好的办法是检查你的主机事件循环源代码。例如，asyncio 可能会根据 Python 版本和操作系统使用或不使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>。</p>
<p><strong>一个小优化：</strong> 最后，考虑进行一个小优化。有些事件循环提供了它们的“尽快调用此函数” API 的两个版本：一个可以从任何线程使用，另一个只能在事件循环线程中使用，后者更便宜。例如，asyncio 提供了 <code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.call_soon_threadsafe()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.call_soon()</span></code>。</p>
<p>如果你的事件循环有这样的区分，那么你还可以传递 <code class="docutils literal notranslate"><span class="pre">run_sync_soon_not_threadsafe=...</span></code> 关键字参数给 <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a>，在适当的时候，Trio 会自动使用它。</p>
<p>如果你的事件循环没有这样的区分，那就不用担心； <code class="docutils literal notranslate"><span class="pre">run_sync_soon_not_threadsafe=</span></code> 是可选的。（如果没有传递，Trio 会在所有情况下使用线程安全的版本。）</p>
<p><strong>就这样！</strong> 如果你按照这些步骤操作，你应该已经成功地将两个事件循环干净地集成在一起了。去做一些酷炫的 GUI / 游戏 / 其他的项目吧！</p>
</div>
<input class="tab-input" id="tab-set--13-input--2" name="tab-set--13" type="radio"/><label class="tab-label" for="tab-set--13-input--2">英文</label><div class="tab-content docutils container">
<p>Let's walk through what you need to do to integrate Trio's guest mode
with your favorite event loop. Treat this section like a checklist.</p>
<p><strong>Getting started:</strong> The first step is to get something basic working.
Here's a minimal example of running Trio on top of asyncio, that you
can use as a model:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="asyncio"><span class="nn">asyncio</span></a>
<span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="c1"># A tiny Trio program</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">trio_main</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" title="range"><span class="nb">range</span></a><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="s2">"Hello from Trio!"</span><span class="p">)</span>
        <span class="c1"># This is inside Trio, so we have to use Trio APIs</span>
        <span class="k">await</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">"trio done!"</span>

<span class="c1"># The code to run it as a guest inside asyncio</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">asyncio_main</span><span class="p">():</span>
    <span class="n">asyncio_loop</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span></a><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sync_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">asyncio_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">done_callback</span><span class="p">(</span><span class="n">trio_main_outcome</span><span class="p">):</span>
        <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="sa">f</span><span class="s2">"Trio program ended with: </span><span class="si">{</span><span class="n">trio_main_outcome</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="c1"># This is where the magic happens:</span>
    <a class="sphinx-codeautolink-a" href="reference-lowlevel.html#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">start_guest_run</span></a><span class="p">(</span>
        <span class="n">trio_main</span><span class="p">,</span>
        <span class="n">run_sync_soon_threadsafe</span><span class="o">=</span><span class="n">run_sync_soon_threadsafe</span><span class="p">,</span>
        <span class="n">done_callback</span><span class="o">=</span><span class="n">done_callback</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Let the host loop run for a while to give trio_main time to</span>
    <span class="c1"># finish. (WARNING: This is a hack. See below for better</span>
    <span class="c1"># approaches.)</span>
    <span class="c1">#</span>
    <span class="c1"># This function is in asyncio, so we have to use asyncio APIs.</span>
    <span class="k">await</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/asyncio-runner.html#asyncio.run" title="asyncio.run"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">asyncio_main</span><span class="p">())</span>
</pre></div>
</div>
<p>You can see we're using asyncio-specific APIs to start up a loop, and
then we call <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.lowlevel.start_guest_run()</span></code></a>. This function is very
similar to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, and takes all the same arguments. But it has
two differences:</p>
<p>First, instead of blocking until <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> has finished, it
schedules <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> to start running on top of the host loop, and
then returns immediately. So <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> is running in the
background – that's why we have to sleep and give it time to finish.</p>
<p>And second, it requires two extra keyword arguments:
<code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>, and <code class="docutils literal notranslate"><span class="pre">done_callback</span></code>.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>, we need a function that takes a
synchronous callback, and schedules it to run on your host loop. And
this function needs to be "threadsafe" in the sense that you can
safely call it from any thread. So you need to figure out how to write
a function that does that using your host loop's API. For asyncio,
this is easy because <code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.call_soon_threadsafe()</span></code> does exactly
what we need; for your loop, it might be more or less complicated.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">done_callback</span></code>, you pass in a function that Trio will
automatically invoke when the Trio run finishes, so you know it's done
and what happened. For this basic starting version, we just print the
result; in the next section we'll discuss better alternatives.</p>
<p>At this stage you should be able to run a simple Trio program inside
your host loop. Now we'll turn that prototype into something solid.</p>
<p><strong>Loop lifetimes:</strong> One of the trickiest things in most event loops is
shutting down correctly. And having two event loops makes this even
harder!</p>
<p>If you can, we recommend following this pattern:</p>
<ul class="simple">
<li><p>Start up your host loop</p></li>
<li><p>Immediately call <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a> to start Trio</p></li>
<li><p>When Trio finishes and your <code class="docutils literal notranslate"><span class="pre">done_callback</span></code> is invoked, shut down the host loop</p></li>
<li><p>Make sure that nothing else shuts down your host loop</p></li>
</ul>
<p>This way, your two event loops have the same lifetime, and your
program automatically exits when your Trio function finishes.</p>
<p>Here's how we'd extend our asyncio example to implement this pattern:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Improved version, that shuts down properly after Trio finishes</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">asyncio_main</span><span class="p">():</span>
    <span class="n">asyncio_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sync_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">asyncio_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

<span class="hll">    <span class="c1"># Revised 'done' callback: set a Future</span>
</span><span class="hll">    <span class="n">done_fut</span> <span class="o">=</span> <span class="n">asyncio_loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
</span><span class="hll">    <span class="k">def</span> <span class="nf">done_callback</span><span class="p">(</span><span class="n">trio_main_outcome</span><span class="p">):</span>
</span><span class="hll">        <span class="n">done_fut</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">trio_main_outcome</span><span class="p">)</span>
</span>
    <span class="n">trio</span><span class="o">.</span><span class="n">lowlevel</span><span class="o">.</span><span class="n">start_guest_run</span><span class="p">(</span>
        <span class="n">trio_main</span><span class="p">,</span>
        <span class="n">run_sync_soon_threadsafe</span><span class="o">=</span><span class="n">run_sync_soon_threadsafe</span><span class="p">,</span>
        <span class="n">done_callback</span><span class="o">=</span><span class="n">done_callback</span><span class="p">,</span>
    <span class="p">)</span>

<span class="hll">    <span class="c1"># Wait for the guest run to finish</span>
</span><span class="hll">    <span class="n">trio_main_outcome</span> <span class="o">=</span> <span class="k">await</span> <span class="n">done_fut</span>
</span><span class="hll">    <span class="c1"># Pass through the return value or exception from the guest run</span>
</span><span class="hll">    <span class="k">return</span> <span class="n">trio_main_outcome</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span>
</span></pre></div>
</div>
<p>And then you can encapsulate all this machinery in a utility function
that exposes a <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>-like API, but runs both loops together:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trio_run_with_asyncio</span><span class="p">(</span><span class="n">trio_main</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">trio_run_kwargs</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncio_main</span><span class="p">():</span>
        <span class="c1"># same as above</span>
        <span class="o">...</span>

    <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">asyncio_main</span><span class="p">())</span>
</pre></div>
</div>
<p>Technically, it is possible to use other patterns. But there are some
important limitations you have to respect:</p>
<ul>
<li><p><strong>You must let the Trio program run to completion.</strong> Many event loops let you stop the event loop at any point, and any pending callbacks/tasks/etc. just... don't run. Trio follows a more structured system, where you can cancel things, but the code always runs to completion, so <code class="docutils literal notranslate"><span class="pre">finally</span></code> blocks run, resources are cleaned up, etc. If you stop your host loop early, before the <code class="docutils literal notranslate"><span class="pre">done_callback</span></code> is invoked, then that cuts off the Trio run in the middle without a chance to clean up. This can leave your code in an inconsistent state, and will definitely leave Trio's internals in an inconsistent state, which will cause errors if you try to use Trio again in that thread.</p>
<p>Some programs need to be able to quit at any time, for example in response to a GUI window being closed or a user selecting a "Quit" from a menu. In these cases, we recommend wrapping your whole program in a <a class="reference internal" href="ref-core/cancel_timeout.html#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.CancelScope</span></code></a>, and cancelling it when you want to quit.</p>
</li>
<li><p>Each host loop can only have one <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a> at a time. If you try to start a second one, you'll get an error. If you need to run multiple Trio functions at the same time, then start up a single Trio run, open a nursery, and then start your functions as child tasks in that nursery.</p></li>
<li><p>Unless you or your host loop register a handler for <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.SIGINT" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> before starting Trio (this is not common), then Trio will take over delivery of <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>s. And since Trio can't tell which host code is safe to interrupt, it will only deliver <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> into the Trio part of your code. This is fine if your program is set up to exit when the Trio part exits, because the <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> will propagate out of Trio and then trigger the shutdown of your host loop, which is just what you want.</p></li>
</ul>
<p>Given these constraints, we think the simplest approach is to always
start and stop the two loops together.</p>
<p><strong>Signal management:</strong> <a class="reference external" href="https://en.wikipedia.org/wiki/Signal_(IPC)">"Signals"</a> are a low-level
inter-process communication primitive. When you hit control-C to kill
a program, that uses a signal. Signal handling in Python has <a class="reference external" href="https://vorpus.org/blog/control-c-handling-in-python-and-trio/">a lot of
moving parts</a>.
One of those parts is <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>, which event loops use to
make sure that they wake up when a signal arrives so they can respond
to it. (If you've ever had an event loop ignore you when you hit
control-C, it was probably because they weren't using
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> correctly.)</p>
<p>But, only one event loop can use <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> at a time. And
in guest mode that can cause problems: Trio and the host loop might
start fighting over who's using <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>.</p>
<p>Some event loops, like asyncio, won't work correctly unless they win
this fight. Fortunately, Trio is a little less picky: as long as
<em>someone</em> makes sure that the program wakes up when a signal arrives,
it should work correctly. So if your host loop wants
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>, then you should disable Trio's
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> support, and then both loops will work
correctly.</p>
<p>On the other hand, if your host loop doesn't use
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>, then the only way to make everything work
correctly is to <em>enable</em> Trio's <a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> support.</p>
<p>By default, Trio assumes that your host loop doesn't use
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a>. It does try to detect when this creates a
conflict with the host loop, and print a warning – but unfortunately,
by the time it detects it, the damage has already been done. So if
you're getting this warning, then you should disable Trio's
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> support by passing
<code class="docutils literal notranslate"><span class="pre">host_uses_signal_set_wakeup_fd=True</span></code> to <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a>.</p>
<p>If you aren't seeing any warnings with your initial prototype, you're
<em>probably</em> fine. But the only way to be certain is to check your host
loop's source. For example, asyncio may or may not use
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/signal.html#signal.set_wakeup_fd" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.set_wakeup_fd()</span></code></a> depending on the Python version and operating
system.</p>
<p><strong>A small optimization:</strong> Finally, consider a small optimization. Some
event loops offer two versions of their "call this function soon" API:
one that can be used from any thread, and one that can only be used
from the event loop thread, with the latter being cheaper. For
example, asyncio has both <code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.call_soon_threadsafe()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.loop.call_soon()</span></code>.</p>
<p>If you have a loop like this, then you can also pass a
<code class="docutils literal notranslate"><span class="pre">run_sync_soon_not_threadsafe=...</span></code> kwarg to <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a>, and
Trio will automatically use it when appropriate.</p>
<p>If your loop doesn't have a split like this, then don't worry about
it; <code class="docutils literal notranslate"><span class="pre">run_sync_soon_not_threadsafe=</span></code> is optional. (If it's not
passed, then Trio will just use your threadsafe version in all cases.)</p>
<p><strong>That's it!</strong> If you've followed all these steps, you should now have
a cleanly-integrated hybrid event loop. Go make some cool
GUIs/games/whatever!</p>
</div>
</div>
</section>
<section id="id20">
<h3>限制<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h3>
<p><strong>Limitations</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--14-input--1" name="tab-set--14" type="radio"/><label class="tab-label" for="tab-set--14-input--1">中文</label><div class="tab-content docutils container">
<p>通常，几乎所有的 Trio 功能在来宾模式下都应该可以正常工作。唯一的例外是那些依赖于 Trio 完全了解程序正在做什么的功能，因为显然，它不能控制主机事件循环或查看它的行为。</p>
<p>自定义时钟可以在来宾模式下使用，但它们只会影响 Trio 的超时，而不会影响主机事件循环的超时。并且 <a class="reference internal" href="reference-testing.html#testing-time"><span class="std std-ref">autojump clock</span></a> 以及相关的 <a class="reference internal" href="reference-testing.html#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.testing.wait_all_tasks_blocked()</span></code></a> 技术上可以在来宾模式下使用，但它们只会考虑 Trio 任务，来决定是否跳过时钟或是否所有任务都被阻塞。</p>
</div>
<input class="tab-input" id="tab-set--14-input--2" name="tab-set--14" type="radio"/><label class="tab-label" for="tab-set--14-input--2">英文</label><div class="tab-content docutils container">
<p>In general, almost all Trio features should work in guest mode. The
exception is features which rely on Trio having a complete picture of
everything that your program is doing, since obviously, it can't
control the host loop or see what it's doing.</p>
<p>Custom clocks can be used in guest mode, but they only affect Trio
timeouts, not host loop timeouts. And the <a class="reference internal" href="reference-testing.html#testing-time"><span class="std std-ref">autojump clock</span></a> and related <a class="reference internal" href="reference-testing.html#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.testing.wait_all_tasks_blocked()</span></code></a> can
technically be used in guest mode, but they'll only take Trio tasks
into account when decided whether to jump the clock or whether all
tasks are blocked.</p>
</div>
</div>
</section>
<section id="id21">
<h3>参考<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h3>
<p><strong>Reference</strong></p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.start_guest_run">
<span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">start_guest_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_sync_soon_threadsafe</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">done_callback</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_sync_soon_not_threadsafe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_uses_signal_set_wakeup_fd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instruments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restrict_keyboard_interrupt_to_checkpoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_exception_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.start_guest_run" title="Link to this definition">¶</a></dt>
<dd><p>Start a "guest" run of Trio on top of some other "host" event loop.</p>
<p>Each host loop can only have one guest run at a time.</p>
<p>You should always let the Trio run finish before stopping the host loop;
if not, it may leave Trio's internal data structures in an inconsistent
state. You might be able to get away with it if you immediately exit the
program, but it's safest not to go there in the first place.</p>
<p>Generally, the best way to do this is wrap this in a function that starts
the host loop and then immediately starts the guest run, and then shuts
down the host when the guest run completes.</p>
<p>Once <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a> returns successfully, the guest run
has been set up enough that you can invoke sync-colored Trio
functions such as <a class="reference internal" href="ref-core/time_clock.html#trio.current_time" title="trio.current_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_time()</span></code></a>, <a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a>,
and <a class="reference internal" href="#trio.lowlevel.current_trio_token" title="trio.lowlevel.current_trio_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_trio_token()</span></code></a>. If a <cite>~trio.TrioInternalError</cite> occurs
during this early setup of the guest run, it will be raised out of
<a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a>.  All other errors, including all errors
raised by the <em>async_fn</em>, will be delivered to your
<em>done_callback</em> at some point after <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a> returns
successfully.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>run_sync_soon_threadsafe</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>]], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>]</span>) -- <p>An arbitrary callable, which will be passed a
function as its sole argument:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_run_sync_soon_threadsafe</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This callable should schedule <code class="docutils literal notranslate"><span class="pre">fn()</span></code> to be run by the host on its
next pass through its loop. <strong>Must support being called from
arbitrary threads.</strong></p>
</p></li>
<li><p><strong>done_callback</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Outcome</span></code></a>[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.TypeVar" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>(<code class="docutils literal notranslate"><span class="pre">RetT</span></code>)]], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>]</span>) -- <p>An arbitrary callable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_done_callback</span><span class="p">(</span><span class="n">run_outcome</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>When the Trio run has finished, Trio will invoke this callback to let
you know. The argument is an <cite>outcome.Outcome</cite>, reporting what would
have been returned or raised by <cite>trio.run</cite>. This function can do
anything you want, but commonly you'll want it to shut down the
host loop, unwrap the outcome, etc.</p>
</p></li>
<li><p><strong>run_sync_soon_not_threadsafe</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Callable" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>[[], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>]], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>] | <a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span>) -- Like <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>, but
will only be called from inside the host loop's main thread.
Optional, but if your host loop allows you to implement this more
efficiently than <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code> then passing it will
make things a bit faster.</p></li>
<li><p><strong>host_uses_signal_set_wakeup_fd</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="（在 Python v3.13）"><em>bool</em></a>) -- Pass <cite>True</cite> if your host loop
uses <cite>signal.set_wakeup_fd</cite>, and <cite>False</cite> otherwise. For more details,
see <a class="reference internal" href="#guest-run-implementation"><span class="std std-ref">为您最喜欢的事件循环实现访客模式</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/constants.html#None" title="（在 Python v3.13）"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></span></p>
</dd>
</dl>
<p>For the meaning of other arguments, see <cite>trio.run</cite>.</p>
</dd></dl>
</section>
</section>
<section id="live-coroutine-handoff">
<span id="id22"></span><h2>在协程运行器之间交接实时协程对象<a class="headerlink" href="#live-coroutine-handoff" title="Link to this heading">¶</a></h2>
<p><strong>Handing off live coroutine objects between coroutine runners</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--15-input--1" name="tab-set--15" type="radio"/><label class="tab-label" for="tab-set--15-input--1">中文</label><div class="tab-content docutils container">
<p>在内部，Python 的 async/await 语法是基于“协程对象”和“协程运行器”这一概念构建的。协程对象表示异步调用栈的状态。但单独来看，这只是一个静态对象，什么都不做。如果你希望它执行任何操作，你需要一个协程运行器来推动它向前执行。每个 Trio 任务都有一个关联的协程对象（见 <a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>），而 Trio 调度器充当了它们的协程运行器。</p>
<p>但当然，Trio 并不是 Python 中唯一的协程运行器——<a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 有一个，其他事件循环也有，甚至你可以自己定义一个。</p>
<p>在一些非常、非常不寻常的情况下，甚至有意义将一个协程对象在不同的协程运行器之间来回传递。这就是本节内容的主题。这是一个 <em>极其</em> 特殊的用例，需要对 Python 的 async/await 内部工作原理有较高的理解。有关动机示例，请参见 <a class="reference external" href="https://github.com/python-trio/trio-asyncio/issues/42">trio-asyncio issue #42</a> 和 <a class="reference external" href="https://github.com/python-trio/trio/issues/649">trio issue #649</a>。有关协程工作原理的更多细节，我们推荐 André Caron 的 <a class="reference external" href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">A tale of event loops</a>，或者直接查看 <a class="reference external" href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a> 获取完整细节。</p>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.permanently_detach_coroutine_object">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">permanently_detach_coroutine_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">final_outcome</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.permanently_detach_coroutine_object" title="Link to this definition">¶</a></dt>
<dd><p>Permanently detach the current task from the Trio scheduler.</p>
<p>Normally, a Trio task doesn't exit until its coroutine object exits. When
you call this function, Trio acts like the coroutine object just exited
and the task terminates with the given outcome. This is useful if you want
to permanently switch the coroutine object over to a different coroutine
runner.</p>
<p>When the calling coroutine enters this function it's running under Trio,
and when the function returns it's running under the foreign coroutine
runner.</p>
<p>You should make sure that the coroutine object has released any
Trio-specific resources it has acquired (e.g. nurseries).</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>final_outcome</strong> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><em>outcome.Outcome</em></a>) -- Trio acts as if the current task exited
with the given return value or exception.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span></p>
</dd>
</dl>
<p>Returns or raises whatever value or exception the new coroutine runner
uses to resume the coroutine.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.temporarily_detach_coroutine_object">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">temporarily_detach_coroutine_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abort_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.temporarily_detach_coroutine_object" title="Link to this definition">¶</a></dt>
<dd><p>Temporarily detach the current coroutine object from the Trio
scheduler.</p>
<p>When the calling coroutine enters this function it's running under Trio,
and when the function returns it's running under the foreign coroutine
runner.</p>
<p>The Trio <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> will continue to exist, but will be suspended until
you use <a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object" title="trio.lowlevel.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a> to resume it. In the
mean time, you can use another coroutine runner to schedule the coroutine
object. In fact, you have to – the function doesn't return until the
coroutine is advanced from outside.</p>
<p>Note that you'll need to save the current <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to later
resume; you can retrieve it with <a class="reference internal" href="#trio.lowlevel.current_task" title="trio.lowlevel.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>. You can also use
this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to retrieve the coroutine object – see
<a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>abort_func</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Callable" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Callable" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>[[], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.NoReturn" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a>]], <a class="reference internal" href="#trio.lowlevel.Abort" title="trio.lowlevel.Abort"><code class="xref py py-class docutils literal notranslate"><span class="pre">Abort</span></code></a>]</span>) -- Same as for <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, except that it
must return <a class="reference internal" href="#id14" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. (If it returned
<a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, then Trio would attempt to reschedule the
detached task directly without going through
<a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object" title="trio.lowlevel.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a>, which would be bad.)
Your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> should still arrange for whatever the coroutine
object is doing to be cancelled, and then reattach to Trio and call
the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback, if possible.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span></p>
</dd>
</dl>
<p>Returns or raises whatever value or exception the new coroutine runner
uses to resume the coroutine.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="trio.lowlevel.reattach_detached_coroutine_object">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">reattach_detached_coroutine_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yield_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#trio.lowlevel.reattach_detached_coroutine_object" title="Link to this definition">¶</a></dt>
<dd><p>Reattach a coroutine object that was detached using
<a class="reference internal" href="#trio.lowlevel.temporarily_detach_coroutine_object" title="trio.lowlevel.temporarily_detach_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">temporarily_detach_coroutine_object()</span></code></a>.</p>
<p>When the calling coroutine enters this function it's running under the
foreign coroutine runner, and when the function returns it's running under
Trio.</p>
<p>This must be called from inside the coroutine being resumed, and yields
whatever value you pass in. (Presumably you'll pass a value that will
cause the current coroutine runner to stop scheduling this task.) Then the
coroutine is resumed by the Trio scheduler at the next opportunity.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>Task</em></a>) -- The Trio task object that the current coroutine was
detached from.</p></li>
<li><p><strong>yield_value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><em>object</em></a>) -- The object to yield to the current coroutine
runner.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</div>
<input class="tab-input" id="tab-set--15-input--2" name="tab-set--15" type="radio"/><label class="tab-label" for="tab-set--15-input--2">英文</label><div class="tab-content docutils container">
<p>Internally, Python's async/await syntax is built around the idea of
"coroutine objects" and "coroutine runners". A coroutine object
represents the state of an async callstack. But by itself, this is
just a static object that sits there. If you want it to do anything,
you need a coroutine runner to push it forward. Every Trio task has an
associated coroutine object (see <a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>), and the Trio
scheduler acts as their coroutine runner.</p>
<p>But of course, Trio isn't the only coroutine runner in Python –
<a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> has one, other event loops have them, you can even
define your own.</p>
<p>And in some very, very unusual circumstances, it even makes sense to
transfer a single coroutine object back and forth between different
coroutine runners. That's what this section is about. This is an
<em>extremely</em> exotic use case, and assumes a lot of expertise in how
Python async/await works internally. For motivating examples, see
<a class="reference external" href="https://github.com/python-trio/trio-asyncio/issues/42">trio-asyncio issue #42</a>, and <a class="reference external" href="https://github.com/python-trio/trio/issues/649">trio
issue #649</a>. For
more details on how coroutines work, we recommend André Caron's <a class="reference external" href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">A
tale of event loops</a>, or
going straight to <a class="reference external" href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a> for the full details.</p>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">permanently_detach_coroutine_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">final_outcome</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Permanently detach the current task from the Trio scheduler.</p>
<p>Normally, a Trio task doesn't exit until its coroutine object exits. When
you call this function, Trio acts like the coroutine object just exited
and the task terminates with the given outcome. This is useful if you want
to permanently switch the coroutine object over to a different coroutine
runner.</p>
<p>When the calling coroutine enters this function it's running under Trio,
and when the function returns it's running under the foreign coroutine
runner.</p>
<p>You should make sure that the coroutine object has released any
Trio-specific resources it has acquired (e.g. nurseries).</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>final_outcome</strong> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="（在 outcome v1.3.0.post0+dev）"><em>outcome.Outcome</em></a>) -- Trio acts as if the current task exited
with the given return value or exception.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span></p>
</dd>
</dl>
<p>Returns or raises whatever value or exception the new coroutine runner
uses to resume the coroutine.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">temporarily_detach_coroutine_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abort_func</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Temporarily detach the current coroutine object from the Trio
scheduler.</p>
<p>When the calling coroutine enters this function it's running under Trio,
and when the function returns it's running under the foreign coroutine
runner.</p>
<p>The Trio <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> will continue to exist, but will be suspended until
you use <a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object" title="trio.lowlevel.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a> to resume it. In the
mean time, you can use another coroutine runner to schedule the coroutine
object. In fact, you have to – the function doesn't return until the
coroutine is advanced from outside.</p>
<p>Note that you'll need to save the current <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to later
resume; you can retrieve it with <a class="reference internal" href="#trio.lowlevel.current_task" title="trio.lowlevel.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>. You can also use
this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to retrieve the coroutine object – see
<a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>abort_func</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Callable" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>[[<a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.Callable" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>[[], <a class="reference external" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.NoReturn" title="（在 Python v3.13）"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a>]], <a class="reference internal" href="#trio.lowlevel.Abort" title="trio.lowlevel.Abort"><code class="xref py py-class docutils literal notranslate"><span class="pre">Abort</span></code></a>]</span>) -- Same as for <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, except that it
must return <a class="reference internal" href="#id14" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. (If it returned
<a class="reference internal" href="#id0" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, then Trio would attempt to reschedule the
detached task directly without going through
<a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object" title="trio.lowlevel.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a>, which would be bad.)
Your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> should still arrange for whatever the coroutine
object is doing to be cancelled, and then reattach to Trio and call
the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback, if possible.</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></span></p>
</dd>
</dl>
<p>Returns or raises whatever value or exception the new coroutine runner
uses to resume the coroutine.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py">
<em class="property"><span class="pre">await</span> </em><span class="sig-prename descclassname"><span class="pre">trio.lowlevel.</span></span><span class="sig-name descname"><span class="pre">reattach_detached_coroutine_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yield_value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reattach a coroutine object that was detached using
<a class="reference internal" href="#trio.lowlevel.temporarily_detach_coroutine_object" title="trio.lowlevel.temporarily_detach_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">temporarily_detach_coroutine_object()</span></code></a>.</p>
<p>When the calling coroutine enters this function it's running under the
foreign coroutine runner, and when the function returns it's running under
Trio.</p>
<p>This must be called from inside the coroutine being resumed, and yields
whatever value you pass in. (Presumably you'll pass a value that will
cause the current coroutine runner to stop scheduling this task.) Then the
coroutine is resumed by the Trio scheduler at the next opportunity.</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>Task</em></a>) -- The Trio task object that the current coroutine was
detached from.</p></li>
<li><p><strong>yield_value</strong> (<a class="reference external" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="（在 Python v3.13）"><em>object</em></a>) -- The object to yield to the current coroutine
runner.</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type">None</span></p>
</dd>
</dl>
</dd></dl>
</div>
</div>
</section>
</section>
</article>
</div>
<footer>
<div class="related-pages">
<a class="next-page" href="design.html">
<div class="page-info">
<div class="context">
<span>Next</span>
</div>
<div class="title">设计和内部结构</div>
</div>
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
</a>
<a class="prev-page" href="reference-testing.html">
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
<div class="page-info">
<div class="context">
<span>Previous</span>
</div>
<div class="title">Trio 中的测试</div>
</div>
</a>
</div>
<div class="bottom-of-page">
<div class="left-details">
<div class="copyright">
                Copyright © 2017, Nathaniel J. Smith
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
</div>
<div class="right-details">
<div class="icons">
<a aria-label="GitHub" class="muted-link" href="https://github.com/hellowac/trio-zh-cn">
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 16 16">
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill-rule="evenodd"></path>
</svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<aside class="toc-drawer">
<div class="toc-sticky toc-scroll">
<div class="toc-title-container">
<span class="toc-title">
            On this page
          </span>
</div>
<div class="toc-tree-container">
<div class="toc-tree">
<ul>
<li><a class="reference internal" href="#">自省和扩展 Trio</a><ul>
<li><a class="reference internal" href="#id1">调试和检测</a><ul>
<li><a class="reference internal" href="#id2">全局统计</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.current_statistics"><code class="docutils literal notranslate"><span class="pre">current_statistics()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.RunStatistics"><code class="docutils literal notranslate"><span class="pre">RunStatistics</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">当前时钟</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.current_clock"><code class="docutils literal notranslate"><span class="pre">current_clock()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#api">工具 API</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.add_instrument"><code class="docutils literal notranslate"><span class="pre">add_instrument()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.remove_instrument"><code class="docutils literal notranslate"><span class="pre">remove_instrument()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument"><code class="docutils literal notranslate"><span class="pre">Instrument</span></code></a><ul>
<li><a class="reference internal" href="#trio.abc.Instrument.after_io_wait"><code class="docutils literal notranslate"><span class="pre">Instrument.after_io_wait()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.after_run"><code class="docutils literal notranslate"><span class="pre">Instrument.after_run()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.after_task_step"><code class="docutils literal notranslate"><span class="pre">Instrument.after_task_step()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.before_io_wait"><code class="docutils literal notranslate"><span class="pre">Instrument.before_io_wait()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.before_run"><code class="docutils literal notranslate"><span class="pre">Instrument.before_run()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.before_task_step"><code class="docutils literal notranslate"><span class="pre">Instrument.before_task_step()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.task_exited"><code class="docutils literal notranslate"><span class="pre">Instrument.task_exited()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.task_scheduled"><code class="docutils literal notranslate"><span class="pre">Instrument.task_scheduled()</span></code></a></li>
<li><a class="reference internal" href="#trio.abc.Instrument.task_spawned"><code class="docutils literal notranslate"><span class="pre">Instrument.task_spawned()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id4">低级进程生成</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.open_process"><code class="docutils literal notranslate"><span class="pre">open_process()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-o">低级 I/O 原语</a><ul>
<li><a class="reference internal" href="#id5">通用 API</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.wait_readable"><code class="docutils literal notranslate"><span class="pre">wait_readable()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.wait_writable"><code class="docutils literal notranslate"><span class="pre">wait_writable()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.notify_closing"><code class="docutils literal notranslate"><span class="pre">notify_closing()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#unix-api">Unix 特定 API</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.FdStream"><code class="docutils literal notranslate"><span class="pre">FdStream</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#kqueue-api">Kqueue 特定 API</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.current_kqueue"><code class="docutils literal notranslate"><span class="pre">current_kqueue()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.wait_kevent"><code class="docutils literal notranslate"><span class="pre">wait_kevent()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.monitor_kevent"><code class="docutils literal notranslate"><span class="pre">monitor_kevent()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#windows-api">Windows 特定 API</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.WaitForSingleObject"><code class="docutils literal notranslate"><span class="pre">WaitForSingleObject()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.register_with_iocp"><code class="docutils literal notranslate"><span class="pre">register_with_iocp()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.wait_overlapped"><code class="docutils literal notranslate"><span class="pre">wait_overlapped()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.write_overlapped"><code class="docutils literal notranslate"><span class="pre">write_overlapped()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.readinto_overlapped"><code class="docutils literal notranslate"><span class="pre">readinto_overlapped()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.current_iocp"><code class="docutils literal notranslate"><span class="pre">current_iocp()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.monitor_completion_key"><code class="docutils literal notranslate"><span class="pre">monitor_completion_key()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id6">全局状态：系统任务和运行局部变量</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.RunVar"><code class="docutils literal notranslate"><span class="pre">RunVar</span></code></a><ul>
<li><a class="reference internal" href="#trio.lowlevel.RunVar.get"><code class="docutils literal notranslate"><span class="pre">RunVar.get()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.RunVar.reset"><code class="docutils literal notranslate"><span class="pre">RunVar.reset()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.RunVar.set"><code class="docutils literal notranslate"><span class="pre">RunVar.set()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.lowlevel.spawn_system_task"><code class="docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">Trio 令牌</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.TrioToken"><code class="docutils literal notranslate"><span class="pre">TrioToken</span></code></a><ul>
<li><a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon"><code class="docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.lowlevel.current_trio_token"><code class="docutils literal notranslate"><span class="pre">current_trio_token()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">生成线程</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.start_thread_soon"><code class="docutils literal notranslate"><span class="pre">start_thread_soon()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">更安全的键盘中断处理</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.disable_ki_protection"><code class="docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.enable_ki_protection"><code class="docutils literal notranslate"><span class="pre">enable_ki_protection()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.currently_ki_protected"><code class="docutils literal notranslate"><span class="pre">currently_ki_protected()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">睡眠和唤醒</a><ul>
<li><a class="reference internal" href="#id11">等待队列抽象</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot"><code class="docutils literal notranslate"><span class="pre">ParkingLot</span></code></a><ul>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.broken_by"><code class="docutils literal notranslate"><span class="pre">ParkingLot.broken_by</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.break_lot"><code class="docutils literal notranslate"><span class="pre">ParkingLot.break_lot()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.park"><code class="docutils literal notranslate"><span class="pre">ParkingLot.park()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.repark"><code class="docutils literal notranslate"><span class="pre">ParkingLot.repark()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.repark_all"><code class="docutils literal notranslate"><span class="pre">ParkingLot.repark_all()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.statistics"><code class="docutils literal notranslate"><span class="pre">ParkingLot.statistics()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.unpark"><code class="docutils literal notranslate"><span class="pre">ParkingLot.unpark()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLot.unpark_all"><code class="docutils literal notranslate"><span class="pre">ParkingLot.unpark_all()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.lowlevel.ParkingLotStatistics"><code class="docutils literal notranslate"><span class="pre">ParkingLotStatistics</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.add_parking_lot_breaker"><code class="docutils literal notranslate"><span class="pre">add_parking_lot_breaker()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.remove_parking_lot_breaker"><code class="docutils literal notranslate"><span class="pre">remove_parking_lot_breaker()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">低级检查点函数</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.checkpoint"><code class="docutils literal notranslate"><span class="pre">checkpoint()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled"><code class="docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint"><code class="docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">低级阻塞</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled"><code class="docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Abort"><code class="docutils literal notranslate"><span class="pre">Abort</span></code></a><ul>
<li><a class="reference internal" href="#trio.lowlevel.Abort.SUCCEEDED"><code class="docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Abort.FAILED"><code class="docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trio.lowlevel.reschedule"><code class="docutils literal notranslate"><span class="pre">reschedule()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a></li>
<li><a class="reference internal" href="#id14"><code class="docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id15">任务 API</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.current_root_task"><code class="docutils literal notranslate"><span class="pre">current_root_task()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.current_task"><code class="docutils literal notranslate"><span class="pre">current_task()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task"><code class="docutils literal notranslate"><span class="pre">Task</span></code></a><ul>
<li><a class="reference internal" href="#trio.lowlevel.Task.name"><code class="docutils literal notranslate"><span class="pre">Task.name</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.coro"><code class="docutils literal notranslate"><span class="pre">Task.coro</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.iter_await_frames"><code class="docutils literal notranslate"><span class="pre">Task.iter_await_frames()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.context"><code class="docutils literal notranslate"><span class="pre">Task.context</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.parent_nursery"><code class="docutils literal notranslate"><span class="pre">Task.parent_nursery</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.eventual_parent_nursery"><code class="docutils literal notranslate"><span class="pre">Task.eventual_parent_nursery</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.child_nurseries"><code class="docutils literal notranslate"><span class="pre">Task.child_nurseries</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.Task.custom_sleep_data"><code class="docutils literal notranslate"><span class="pre">Task.custom_sleep_data</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#guest-mode">使用“访客模式”在其他事件循环之上运行 Trio</a><ul>
<li><a class="reference internal" href="#id17">什么是“访客模式”？</a></li>
<li><a class="reference internal" href="#id18">真的吗？怎么可能？</a></li>
<li><a class="reference internal" href="#guest-run-implementation">为您最喜欢的事件循环实现访客模式</a></li>
<li><a class="reference internal" href="#id20">限制</a></li>
<li><a class="reference internal" href="#id21">参考</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.start_guest_run"><code class="docutils literal notranslate"><span class="pre">start_guest_run()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#live-coroutine-handoff">在协程运行器之间交接实时协程对象</a><ul>
<li><a class="reference internal" href="#trio.lowlevel.permanently_detach_coroutine_object"><code class="docutils literal notranslate"><span class="pre">permanently_detach_coroutine_object()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.temporarily_detach_coroutine_object"><code class="docutils literal notranslate"><span class="pre">temporarily_detach_coroutine_object()</span></code></a></li>
<li><a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object"><code class="docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</aside>
</div>
</div><script src="_static/documentation_options.js?v=d2451d57"></script>
<script src="_static/doctools.js?v=9bcbadda"></script>
<script src="_static/sphinx_highlight.js?v=dc90522c"></script>
<script src="_static/scripts/furo.js?v=5fa4622c"></script>
<script src="_static/tabs.js?v=3ee01567"></script>
<script src="_static/clipboard.min.js?v=a7894cd8"></script>
<script src="_static/copybutton.js?v=f281be69"></script>
<script src="_static/translations.js?v=beaddf03"></script>
</body>
</html>