<!DOCTYPE html>

<html class="no-js" data-content_root="./" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="light dark" name="color-scheme"/><meta content="width=device-width, initial-scale=1" name="viewport">
<link href="genindex.html" rel="index" title="索引"/><link href="search.html" rel="search" title="搜索"/><link href="awesome-trio-libraries.html" rel="next" title="超棒的 Trio 库"/><link href="index.html" rel="prev" title="Trio: 一个用于异步并发和 I/O 的友好 Python 库"/>
<link href="_static/favicon-32.png" rel="shortcut icon"/><!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
<title>教程 - Trio 0.27.0+dev 文档</title>
<link href="_static/pygments.css?v=fa44fd50" rel="stylesheet" type="text/css"/>
<link href="_static/styles/furo.css?v=354aac6f" rel="stylesheet" type="text/css"/>
<link href="_static/sphinx-codeautolink.css?v=125d5c1c" rel="stylesheet" type="text/css"/>
<link href="_static/tabs.css?v=4c969af8" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css?v=76b2166b" rel="stylesheet" type="text/css"/>
<link href="_static/hackrtd.css?v=2d9fc201" rel="stylesheet" type="text/css"/>
<link href="_static/styles/furo-extensions.css?v=302659d7" rel="stylesheet" type="text/css"/>
<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></meta></head>
<body>
<script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<symbol id="svg-toc" viewbox="0 0 24 24">
<title>Contents</title>
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 1024 1024">
<path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"></path>
</svg>
</symbol>
<symbol id="svg-menu" viewbox="0 0 24 24">
<title>Menu</title>
<svg class="feather-menu" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<line x1="3" x2="21" y1="12" y2="12"></line>
<line x1="3" x2="21" y1="6" y2="6"></line>
<line x1="3" x2="21" y1="18" y2="18"></line>
</svg>
</symbol>
<symbol id="svg-arrow-right" viewbox="0 0 24 24">
<title>Expand</title>
<svg class="feather-chevron-right" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<polyline points="9 18 15 12 9 6"></polyline>
</svg>
</symbol>
<symbol id="svg-sun" viewbox="0 0 24 24">
<title>Light mode</title>
<svg class="feather-sun" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="5"></circle>
<line x1="12" x2="12" y1="1" y2="3"></line>
<line x1="12" x2="12" y1="21" y2="23"></line>
<line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line>
<line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line>
<line x1="1" x2="3" y1="12" y2="12"></line>
<line x1="21" x2="23" y1="12" y2="12"></line>
<line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line>
<line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>
</svg>
</symbol>
<symbol id="svg-moon" viewbox="0 0 24 24">
<title>Dark mode</title>
<svg class="icon-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
</svg>
</symbol>
<symbol id="svg-sun-with-moon" viewbox="0 0 24 24">
<title>Auto light/dark, in light mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z" style="opacity: 50%"></path>
<line x1="14.5" x2="14.5" y1="3.25" y2="1.25"></line>
<line x1="14.5" x2="14.5" y1="15.85" y2="17.85"></line>
<line x1="10.044" x2="8.63" y1="5.094" y2="3.68"></line>
<line x1="19" x2="20.414" y1="14.05" y2="15.464"></line>
<line x1="8.2" x2="6.2" y1="9.55" y2="9.55"></line>
<line x1="20.8" x2="22.8" y1="9.55" y2="9.55"></line>
<line x1="10.044" x2="8.63" y1="14.006" y2="15.42"></line>
<line x1="19" x2="20.414" y1="5.05" y2="3.636"></line>
<circle cx="14.5" cy="9.55" r="3.6"></circle>
</svg>
</symbol>
<symbol id="svg-moon-with-sun" viewbox="0 0 24 24">
<title>Auto light/dark, in dark mode</title>
<svg class="icon-custom-derived-from-feather-sun-and-tabler-moon" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"></path>
<line style="opacity: 50%" x1="18" x2="18" y1="3.705" y2="2.5"></line>
<line style="opacity: 50%" x1="18" x2="18" y1="11.295" y2="12.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="4.816" y2="3.964"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="10.212" y2="11.063"></line>
<line style="opacity: 50%" x1="14.205" x2="13.001" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="21.795" x2="23" y1="7.5" y2="7.5"></line>
<line style="opacity: 50%" x1="15.316" x2="14.464" y1="10.184" y2="11.036"></line>
<line style="opacity: 50%" x1="20.711" x2="21.563" y1="4.789" y2="3.937"></line>
<circle cx="18" cy="7.5" r="2.169" style="opacity: 50%"></circle>
</svg>
</symbol>
<symbol id="svg-pencil" viewbox="0 0 24 24">
<svg class="icon-tabler-pencil-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4"></path>
<path d="M13.5 6.5l4 4"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
<symbol id="svg-eye" viewbox="0 0 24 24">
<svg class="icon-tabler-eye-code" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0"></path>
<path d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008"></path>
<path d="M20 21l2 -2l-2 -2"></path>
<path d="M17 17l-2 2l2 2"></path>
</svg>
</symbol>
</svg>
<input class="sidebar-toggle" id="__navigation" name="__navigation" type="checkbox"/>
<input class="sidebar-toggle" id="__toc" name="__toc" type="checkbox"/>
<label class="overlay sidebar-overlay" for="__navigation">
<div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
<div class="visually-hidden">Hide table of contents sidebar</div>
</label>
<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>
<div class="page">
<header class="mobile-header">
<div class="header-left">
<label class="nav-overlay-icon" for="__navigation">
<div class="visually-hidden">Toggle site navigation sidebar</div>
<i class="icon"><svg><use href="#svg-menu"></use></svg></i>
</label>
</div>
<div class="header-center">
<a href="index.html"><div class="brand">Trio 0.27.0+dev 文档</div></a>
</div>
<div class="header-right">
<div class="theme-toggle-container theme-toggle-header">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-header-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
</header>
<aside class="sidebar-drawer">
<div class="sidebar-container">
<div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
<div class="sidebar-logo-container">
<img alt="Logo" class="sidebar-logo" src="_static/wordmark-transparent.svg"/>
</div>
<span class="sidebar-brand-text">Trio 0.27.0+dev 文档</span>
</a><form action="search.html" class="sidebar-search-container" method="get" role="search">
<input aria-label="搜索" class="sidebar-search" name="q" placeholder="搜索"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
<p class="caption" role="heading"><span class="caption-text">Trio 友好且全面的手册：</span></p>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="awesome-trio-libraries.html">超棒的 Trio 库</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="ref-core/index.html">Trio 的核心功能</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Trio 的核心功能</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="ref-core/run.html">运行 Trio</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/general_principles.html">一般原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/time_clock.html">时间和时钟</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/cancel_timeout.html">取消和超时</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/tasks.html">任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/task_local_storeage.html">任务存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/task_sync.html">任务同步和通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/note_async_generator.html">异步生成器注意事项</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/threads.html">线程（如果必须）</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/debugging.html">交互式调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-core/exc_warn.html">异常和警告</a></li>
</ul>
</input></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="ref-io/index.html">Trio 中的 I/O</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Trio 中的 I/O</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="ref-io/abs_api.html">抽象流 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/low_level.html">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code> 进行低级网络编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/async_file_io.html">异步文件系统 I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/subprocess.html">生成子进程</a></li>
<li class="toctree-l2"><a class="reference internal" href="ref-io/signals.html">信号</a></li>
</ul>
</input></li>
<li class="toctree-l1"><a class="reference internal" href="reference-testing.html">Trio 中的测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference-lowlevel.html">自省和扩展 Trio</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">设计和内部结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">发布历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">为 Trio 及相关项目做出贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="releasing.html">准备发布</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-of-conduct.html">行为守则</a></li>
</ul>
</div>
</div>
</div>
</div>
</aside>
<div class="main">
<div class="content">
<div class="article-container">
<a class="back-to-top muted-link" href="#">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
</svg>
<span>Back to top</span>
</a>
<div class="content-icon-container">
<div class="view-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/blob/sync-docs/cn_docs/source/tutorial.rst?plain=true" title="View this page">
<svg><use href="#svg-eye"></use></svg>
<span class="visually-hidden">View this page</span>
</a>
</div><div class="edit-this-page">
<a class="muted-link" href="https://github.com/hellowac/trio-zh-cn/edit/sync-docs/cn_docs/source/tutorial.rst" title="Edit this page">
<svg><use href="#svg-pencil"></use></svg>
<span class="visually-hidden">Edit this page</span>
</a>
</div><div class="theme-toggle-container theme-toggle-content">
<button class="theme-toggle">
<div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
<svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
<svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
<svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
<svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
</button>
</div>
<label class="toc-overlay-icon toc-content-icon" for="__toc">
<div class="visually-hidden">Toggle table of contents sidebar</div>
<i class="icon"><svg><use href="#svg-toc"></use></svg></i>
</label>
</div>
<article id="furo-main-content" role="main">
<section id="id1">
<h1>教程<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p><strong>Tutorial</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p>欢迎来到 Trio 教程！Trio 是一个现代 Python 库，用于编写异步应用程序——也就是说，用于编写那些需要通过并行化 I/O 来同时完成多项任务的程序，比如一个并行抓取大量页面的网络爬虫，或是一个处理多个下载请求的 Web 服务器……诸如此类的任务。在这里，我们将尝试以温和的方式介绍使用 Trio 的异步编程。</p>
<p>我们假设您对 Python 已有一定了解，但别担心——我们不假设您对异步编程或 Python 的新特性 <code class="docutils literal notranslate"><span class="pre">async/await</span></code> 有任何基础。</p>
<p>另外，与许多 <code class="docutils literal notranslate"><span class="pre">async/await</span></code> 教程不同，我们假设您的目标是*使用* Trio 编写有趣的程序，因此我们不会深入探讨 Python 解释器内部如何实现 <code class="docutils literal notranslate"><span class="pre">async/await</span></code> 的细节。“协程”这个词也不会出现。事实上，除非您想要*实现*一个像 Trio 这样的库，否则您实际上并不*需要*了解这些内容（不过，我们会提供一些链接，供想深入学习的读者参考）。</p>
<p>好了，准备好了吗？我们开始吧。</p>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"/><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p>Welcome to the Trio tutorial! Trio is a modern Python library for
writing asynchronous applications – that is, programs that want to do
multiple things at the same time with parallelized I/O, like a web
spider that fetches lots of pages in parallel, a web server juggling
lots of simultaneous downloads... that sort of thing. Here we'll try
to give a gentle introduction to asynchronous programming with Trio.</p>
<p>We assume that you're familiar with Python in general, but don't worry
– we don't assume you know anything about asynchronous programming or
Python's new <code class="docutils literal notranslate"><span class="pre">async/await</span></code> feature.</p>
<p>Also, unlike many <code class="docutils literal notranslate"><span class="pre">async/await</span></code> tutorials, we assume that your goal
is to <em>use</em> Trio to write interesting programs, so we won't go into
the nitty-gritty details of how <code class="docutils literal notranslate"><span class="pre">async/await</span></code> is implemented inside
the Python interpreter. The word "coroutine" is never mentioned. The
fact is, you really don't <em>need</em> to know any of that stuff unless you
want to <em>implement</em> a library like Trio, so we leave it out (though
we'll throw in a few links for those who want to dig deeper).</p>
<p>Okay, ready? Let's get started.</p>
</div>
</div>
<section id="id2">
<h2>开始之前<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p><strong>Before you begin</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<ol class="arabic simple">
<li><p>确保您使用的是 Python 3.9 或更高版本。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--upgrade</span> <span class="pre">trio``（在</span> <span class="pre">Windows</span> <span class="pre">上可能需要</span>
<span class="pre">``py</span> <span class="pre">-3</span> <span class="pre">-m</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--upgrade</span> <span class="pre">trio</span></code> – <a class="reference external" href="https://packaging.python.org/installing/">详情请见</a>）</p></li>
<li><p>能否运行 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">trio</span></code>？如果可以，那您就可以开始了！</p></li>
</ol>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"/><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<ol class="arabic simple" start="4">
<li><p>Make sure you're using Python 3.9 or newer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--upgrade</span> <span class="pre">trio</span></code> (or on Windows, maybe
<code class="docutils literal notranslate"><span class="pre">py</span> <span class="pre">-3</span> <span class="pre">-m</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--upgrade</span> <span class="pre">trio</span></code> – <a class="reference external" href="https://packaging.python.org/installing/">details</a>)</p></li>
<li><p>Can you <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">trio</span></code>? If so then you're good to go!</p></li>
</ol>
</div>
</div>
</section>
<section id="id3">
<h2>如果您迷失或感到困惑……<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p><strong>If you get lost or confused...</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<p>……那么我们希望知道！我们有一个友好的 <a class="reference external" href="https://gitter.im/python-trio/general">聊天频道</a>，您可以在 StackOverflow 上使用 <a class="reference external" href="https://stackoverflow.com/questions/ask?tags=python+python-trio">"python-trio" 标签提问</a>，或者直接 <a class="reference external" href="https://github.com/python-trio/trio/issues/new">提交一个问题</a> （如果我们的文档令人困惑，这是我们的责任，我们希望能修正它！）。</p>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"/><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<p>...then we want to know! We have a friendly <a class="reference external" href="https://gitter.im/python-trio/general">chat channel</a>, you can ask questions
<a class="reference external" href="https://stackoverflow.com/questions/ask?tags=python+python-trio">using the "python-trio" tag on StackOverflow</a>, or just
<a class="reference external" href="https://github.com/python-trio/trio/issues/new">file a bug</a> (if
our documentation is confusing, that's our fault, and we want to fix
it!).</p>
</div>
</div>
</section>
<section id="id4">
<h2>异步函数<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p><strong>Async functions</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p>Python 3.5 添加了一个重要的新特性：异步函数。使用 Trio 的核心就是编写异步函数，因此让我们从这里开始。</p>
<p>异步函数的定义与普通函数相似，只是将 <code class="docutils literal notranslate"><span class="pre">def</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 普通函数</span>
<span class="k">def</span> <span class="nf">regular_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1"># 异步函数</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>
</div>
<p>“Async” 是 “asynchronous”（异步）的缩写；有时我们将像 <code class="docutils literal notranslate"><span class="pre">regular_double</span></code> 这样的普通函数称为“同步函数”，以将其与异步函数区分开来。</p>
<p>从用户的角度来看，异步函数与普通函数之间有两个区别：</p>
<ol class="arabic">
<li><p>要调用异步函数，必须使用 <code class="docutils literal notranslate"><span class="pre">await</span></code> 关键字。因此，您需要写成 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_double(3)</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">regular_double(3)</span></code>。</p></li>
<li><p>您不能在普通函数的主体内使用 <code class="docutils literal notranslate"><span class="pre">await</span></code> 关键字。如果尝试这样做，将会出现语法错误：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="k">await</span> <span class="n">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># &lt;-- 这里会出现 SyntaxError</span>
</pre></div>
</div>
<p>但是在异步函数内部，<code class="docutils literal notranslate"><span class="pre">await</span></code> 是允许的：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">print_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="k">await</span> <span class="n">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># &lt;-- 没问题！</span>
</pre></div>
</div>
</li>
</ol>
<p>现在，让我们思考一下其中的影响：如果调用异步函数需要 <code class="docutils literal notranslate"><span class="pre">await</span></code>，并且只有异步函数可以使用 <code class="docutils literal notranslate"><span class="pre">await</span></code> …… 这里有一个小表格：</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>如果一个函数是这样</p></th>
<th class="head"><p>想要调用一个这样的函数</p></th>
<th class="head"><p>是否可以实现？</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sync</p></td>
<td><p>sync</p></td>
<td><p>✓</p></td>
</tr>
<tr class="row-odd"><td><p>sync</p></td>
<td><p>async</p></td>
<td><p><strong>NOPE</strong></p></td>
</tr>
<tr class="row-even"><td><p>async</p></td>
<td><p>sync</p></td>
<td><p>✓</p></td>
</tr>
<tr class="row-odd"><td><p>async</p></td>
<td><p>async</p></td>
<td><p>✓</p></td>
</tr>
</tbody>
</table>
</div>
<p>总结一下：对用户来说，异步函数相较于普通函数的唯一优势在于异步函数拥有一个特权：它们可以调用其他异步函数。</p>
<p>这会立刻引发两个问题：怎么实现？以及为什么要实现？具体来说：</p>
<p>当 Python 程序启动时，它是在运行普通的同步代码。这就引发了一个先有鸡还是先有蛋的问题：一旦我们运行了一个异步函数，我们就可以调用其他异步函数，但是 <em>如何</em> 调用第一个异步函数呢？</p>
<p>而且，如果编写异步函数的唯一原因是它可以调用其他异步函数，那么 <em>为什么</em> 我们一开始会想使用它们？这看上去作为一个特权有些没有意义。难道不更简单直接地……完全不用任何异步函数吗？</p>
<p>这就是像 Trio 这样的异步库的作用所在。它提供了两件东西：</p>
<ol class="arabic" start="3">
<li><p>一个运行器函数，这是一个特殊的 <em>同步</em> 函数，可以接收并调用一个 <em>异步</em> 函数。在 Trio 中，这个函数是 <code class="docutils literal notranslate"><span class="pre">trio.run</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<a class="sphinx-codeautolink-a" href="ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">async_double</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 返回 6</span>
</pre></div>
</div>
<p>这就解答了“如何实现”的问题。</p>
</li>
<li><p>一组有用的异步函数——特别是用于执行 I/O 的函数。这就解答了“为什么要实现”的问题：这些函数是异步的，并且很有用，所以如果您想使用它们，就必须编写异步代码。如果您觉得跟踪这些 <code class="docutils literal notranslate"><span class="pre">async</span></code> 和 <code class="docutils literal notranslate"><span class="pre">await</span></code> 很麻烦，那也无能为力——这是必然的！（好吧，您可以选择不使用 Trio。这是一个合理的选项。但事实证明，这些 <code class="docutils literal notranslate"><span class="pre">async/await</span></code> 其实是有好处的，我们稍后会讨论。）</p>
<p>这里是一个使用 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 的示例函数。(<a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 类似于 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/time.html#time.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a>，但具有更多的异步特性。）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">double_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">await</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 无操作持续 6 秒后返回</span>
</pre></div>
</div>
</li>
</ol>
<p id="async-sandwich">所以，实际上我们这个 <code class="docutils literal notranslate"><span class="pre">async_double</span></code> 函数是一个不太好的示例。意思是，它可以运行，没有什么 <em>问题</em> ，但它其实是多余的：完全可以写成普通函数，这样反而会更实用。而 <code class="docutils literal notranslate"><span class="pre">double_sleep</span></code> 则更为典型：我们必须将其设为异步函数，因为它调用了另一个异步函数。最终结果形成了一种异步三明治结构，两边是 Trio 中的代码，中间是我们的代码：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>trio.run -&gt; double_sleep -&gt; trio.sleep
</pre></div>
</div>
<p>这种“三明治”结构是异步代码的典型模式；一般来说，结构如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>trio.run -&gt; [异步函数] -&gt; ... -&gt; [异步函数] -&gt; trio.whatever
</pre></div>
</div>
<p>正是位于 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">trio.whatever</span></code> 之间路径上的这些函数需要是异步的。Trio 提供了异步的“面包”，然后您的代码就成为了这个异步三明治中的“美味异步夹心”。其他函数（例如，您在过程中调用的辅助函数）通常应该是常规的非异步函数。</p>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"/><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p>Python 3.5 added a major new feature: async functions. Using Trio is
all about writing async functions, so let's start there.</p>
<p>An async function is defined like a normal function, except you write
<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> instead of <code class="docutils literal notranslate"><span class="pre">def</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># A regular function</span>
<span class="k">def</span> <span class="nf">regular_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1"># An async function</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>
</div>
<p>"Async" is short for "asynchronous"; we'll sometimes refer to regular
functions like <code class="docutils literal notranslate"><span class="pre">regular_double</span></code> as "synchronous functions", to
distinguish them from async functions.</p>
<p>From a user's point of view, there are two differences between an
async function and a regular function:</p>
<ol class="arabic" start="5">
<li><p>To call an async function, you have to use the <code class="docutils literal notranslate"><span class="pre">await</span></code>
keyword. So instead of writing <code class="docutils literal notranslate"><span class="pre">regular_double(3)</span></code>, you write
<code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_double(3)</span></code>.</p></li>
<li><p>You can't use the <code class="docutils literal notranslate"><span class="pre">await</span></code> keyword inside the body of a regular
function. If you try it, you'll get a syntax error:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="k">await</span> <span class="n">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># &lt;-- SyntaxError here</span>
</pre></div>
</div>
<p>But inside an async function, <code class="docutils literal notranslate"><span class="pre">await</span></code> is allowed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">print_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="k">await</span> <span class="n">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># &lt;-- OK!</span>
</pre></div>
</div>
</li>
</ol>
<p>Now, let's think about the consequences here: if you need <code class="docutils literal notranslate"><span class="pre">await</span></code> to
call an async function, and only async functions can use
<code class="docutils literal notranslate"><span class="pre">await</span></code>... here's a little table:</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>If a function like this</p></th>
<th class="head"><p>wants to call a function like this</p></th>
<th class="head"><p>is it gonna happen?</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sync</p></td>
<td><p>sync</p></td>
<td><p>✓</p></td>
</tr>
<tr class="row-odd"><td><p>sync</p></td>
<td><p>async</p></td>
<td><p><strong>NOPE</strong></p></td>
</tr>
<tr class="row-even"><td><p>async</p></td>
<td><p>sync</p></td>
<td><p>✓</p></td>
</tr>
<tr class="row-odd"><td><p>async</p></td>
<td><p>async</p></td>
<td><p>✓</p></td>
</tr>
</tbody>
</table>
</div>
<p>So in summary: As a user, the entire advantage of async functions over
regular functions is that async functions have a superpower: they can
call other async functions.</p>
<p>This immediately raises two questions: how, and why? Specifically:</p>
<p>When your Python program starts up, it's running regular old sync
code. So there's a chicken-and-the-egg problem: once we're running an
async function we can call other async functions, but <em>how</em> do we call
that first async function?</p>
<p>And, if the only reason to write an async function is that it can call
other async functions, <em>why</em> on earth would we ever use them in
the first place? I mean, as superpowers go this seems a bit
pointless. Wouldn't it be simpler to just... not use any async
functions at all?</p>
<p>This is where an async library like Trio comes in. It provides two
things:</p>
<ol class="arabic" start="7">
<li><p>A runner function, which is a special <em>synchronous</em> function that
takes and calls an <em>asynchronous</em> function. In Trio, this is
<code class="docutils literal notranslate"><span class="pre">trio.run</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">async_double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<a class="sphinx-codeautolink-a" href="ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">async_double</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># returns 6</span>
</pre></div>
</div>
<p>So that answers the "how" part.</p>
</li>
<li><p>A bunch of useful async functions – in particular, functions for
doing I/O. So that answers the "why": these functions are async,
and they're useful, so if you want to use them, you have to write
async code. If you think keeping track of these <code class="docutils literal notranslate"><span class="pre">async</span></code> and
<code class="docutils literal notranslate"><span class="pre">await</span></code> things is annoying, then too bad – you've got no choice
in the matter! (Well, OK, you could just not use Trio. That's a
legitimate option. But it turns out that the <code class="docutils literal notranslate"><span class="pre">async/await</span></code> stuff
is actually a good thing, for reasons we'll discuss a little bit
later.)</p>
<p>Here's an example function that uses
<a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a>. (<a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> is like <a class="reference external" href="https://docs.python.org/zh-cn/3/library/time.html#time.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a>,
but with more async.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">double_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">await</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># does nothing for 6 seconds then returns</span>
</pre></div>
</div>
</li>
</ol>
<p>So it turns out our <code class="docutils literal notranslate"><span class="pre">async_double</span></code> function is actually a bad
example. I mean, it works, it's fine, there's nothing <em>wrong</em> with it,
but it's pointless: it could just as easily be written as a regular
function, and it would be more useful that way. <code class="docutils literal notranslate"><span class="pre">double_sleep</span></code> is a
much more typical example: we have to make it async, because it calls
another async function. The end result is a kind of async sandwich,
with Trio on both sides and our code in the middle:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>trio.run -&gt; double_sleep -&gt; trio.sleep
</pre></div>
</div>
<p>This "sandwich" structure is typical for async code; in general, it
looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>trio.run -&gt; [async function] -&gt; ... -&gt; [async function] -&gt; trio.whatever
</pre></div>
</div>
<p>It's exactly the functions on the path between <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> and
<code class="docutils literal notranslate"><span class="pre">trio.whatever</span></code> that have to be async. Trio provides the async
bread, and then your code makes up the async sandwich's tasty async
filling. Other functions (e.g., helpers you call along the way) should
generally be regular, non-async functions.</p>
</div>
</div>
<section id="await">
<h3>警告：不要忘记 <code class="docutils literal notranslate"><span class="pre">await</span></code> ！<a class="headerlink" href="#await" title="Link to this heading">¶</a></h3>
<p><strong>Warning: don't forget that</strong> <code class="docutils literal notranslate"><span class="pre">await</span></code> !</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p>现在是个好时机，可以打开 Python 提示符，尝试编写简单的异步函数，并使用 <code class="docutils literal notranslate"><span class="pre">trio.run</span></code> 运行它们。</p>
<p>在这个过程中，您可能会编写类似以下的代码，尝试调用一个异步函数，却遗漏了 <code class="docutils literal notranslate"><span class="pre">await</span></code> ：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/time.html#module-time" title="time"><span class="nn">time</span></a>
<span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">broken_double_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="s2">"*打哈欠* 准备入睡"</span><span class="p">)</span>
   <span class="n">start_time</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/time.html#time.perf_counter" title="time.perf_counter"><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span></a><span class="p">()</span>

   <span class="c1"># 哎呀，我们忘了加 'await'！</span>
   <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

   <span class="n">sleep_time</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/time.html#time.perf_counter" title="time.perf_counter"><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span></a><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="sa">f</span><span class="s2">"醒来后感觉精神抖擞！一共睡了 </span><span class="si">{</span><span class="n">sleep_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> 秒。"</span><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">broken_double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>您可能认为 Python 会在这里引发错误，就像我们有时调用函数时犯下的其他错误一样。例如，如果我们忘记给 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 提供所需的参数，那么我们会收到一个友好的 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，提示我们。但是不幸的是，如果忘记 <code class="docutils literal notranslate"><span class="pre">await</span></code>，并不会出现这样的错误。您实际得到的结果是：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">broken_double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">*打哈欠* 准备入睡</span>
<span class="go">醒来后感觉精神抖擞！一共睡了 0.00 秒。</span>
<span class="go">__main__:4: RuntimeWarning: coroutine 'sleep' was never awaited</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>显然这段代码是有问题的——0.00 秒根本不够让人休息好！但是代码看起来却像是成功执行了——没有引发任何异常。唯一的提示是它打印出 <code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">coroutine</span> <span class="pre">'sleep'</span> <span class="pre">was</span> <span class="pre">never</span> <span class="pre">awaited</span></code> 。另外，警告的确切显示位置可能会有所不同，因为这取决于垃圾收集器的运行方式。如果您使用的是 PyPy，可能在下一次垃圾回收运行之前根本不会看到警告：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># 在 PyPy 中：</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">broken_double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">*打哈欠* 准备入睡</span>
<span class="go">醒来后感觉精神抖擞！一共睡了 0.00 秒！</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 什么……？？？没有任何警告！</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 强制执行一次垃圾回收后则会看到警告：</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc" title="gc"><span class="nn">gc</span></a>
<span class="gp">&gt;&gt;&gt; </span><a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/gc.html#gc.collect" title="gc.collect"><span class="n">gc</span><span class="o">.</span><span class="n">collect</span></a><span class="p">()</span>
<span class="go">/home/njs/pypy-3.8-nightly/lib-python/3/importlib/_bootstrap.py:191: RuntimeWarning: coroutine 'sleep' was never awaited</span>
<span class="go">if _module_locks.get(name) is wr:    # XXX PyPy 修复？</span>
<span class="go">0</span>
</pre></div>
</div>
<p>（如果您看不到上面的警告，可以尝试向右滚动查看。）</p>
<p>遗漏 <code class="docutils literal notranslate"><span class="pre">await</span></code> 是 <em>极为常见的错误</em>。每个人都会犯这个错误。而 Python 并不会像您希望的那样提供足够的帮助 😞。关键点在于：如果您看到 <code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">coroutine</span> <span class="pre">'...'</span> <span class="pre">was</span> <span class="pre">never</span> <span class="pre">awaited</span></code> 这句魔法般的提示，那么这 <em>总是</em> 意味着您遗漏了某处的 <code class="docutils literal notranslate"><span class="pre">await</span></code>，应忽略其他错误信息，先修复这个问题，因为很可能其他问题只是由此引发的附带损害。我甚至不确定 PyPy 输出的那些其他信息到底是什么。但幸运的是，我不需要知道这些细节，只需要修复我的函数！</p>
<p>（“我以为你说过不会提到协程！” 是的，但是 <em>我</em> 没有提到协程，是 Python 提到的。这个问题可以去找 Guido！不过说正经的，这确实是内部实现细节泄露的一个地方。）</p>
<p>为什么会出现这种情况？在 Trio 中，每次我们使用 <code class="docutils literal notranslate"><span class="pre">await</span></code>，都是在调用一个异步函数，而每次调用异步函数都需要使用 <code class="docutils literal notranslate"><span class="pre">await</span></code>。但 Python 希望保留一些灵活性，以适应其他 <em>稍微</em> 不那么有组织的库。因此，虽然我们可以将 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(...)</span></code> 看作一个完整的语法单元，但在 Python 看来它是两部分：首先是一个函数调用，返回一个奇怪的“协程”对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;coroutine object sleep at 0x7f5ac77be6d0&gt;</span>
</pre></div>
</div>
<p>然后这个对象会被传递给 <code class="docutils literal notranslate"><span class="pre">await</span></code>，实际执行该函数。所以如果您忘记了 <code class="docutils literal notranslate"><span class="pre">await</span></code>，会发生两件坏事：函数实际上没有被调用，您得到的“协程”对象可能并不是您期望的结果，比如数字：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">async_double</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">TypeError: unsupported operand type(s) for +: 'coroutine' and 'int'</span>
</pre></div>
</div>
<p>如果您还没有自然地犯下这个错误，可以故意尝试一下：写一些缺少 <code class="docutils literal notranslate"><span class="pre">await</span></code> 或多余 <code class="docutils literal notranslate"><span class="pre">await</span></code> 的代码，看看会发生什么。这样，当真正遇到这种情况时，您就做好了准备。</p>
<p>记住：小心 <code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">coroutine</span> <span class="pre">'...'</span> <span class="pre">was</span> <span class="pre">never</span> <span class="pre">awaited</span></code>；它意味着您需要找到并修复遗漏的 <code class="docutils literal notranslate"><span class="pre">await</span></code>。</p>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"/><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>Now would be a good time to open up a Python prompt and experiment a
little with writing simple async functions and running them with
<code class="docutils literal notranslate"><span class="pre">trio.run</span></code>.</p>
<p>At some point in this process, you'll probably write some code like
this, that tries to call an async function but leaves out the
<code class="docutils literal notranslate"><span class="pre">await</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/time.html#module-time" title="time"><span class="nn">time</span></a>
<span class="kn">import</span> <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#module-trio" title="trio"><span class="nn">trio</span></a>

<span class="k">async</span> <span class="k">def</span> <span class="nf">broken_double_sleep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="s2">"*yawn* Going to sleep"</span><span class="p">)</span>
   <span class="n">start_time</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/time.html#time.perf_counter" title="time.perf_counter"><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span></a><span class="p">()</span>

   <span class="c1"># Whoops, we forgot the 'await'!</span>
   <a class="sphinx-codeautolink-a" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

   <span class="n">sleep_time</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/time.html#time.perf_counter" title="time.perf_counter"><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span></a><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
   <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#print" title="print"><span class="nb">print</span></a><span class="p">(</span><span class="sa">f</span><span class="s2">"Woke up after </span><span class="si">{</span><span class="n">sleep_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds, feeling well rested!"</span><span class="p">)</span>

<a class="sphinx-codeautolink-a" href="ref-core/run.html#trio.run" title="trio.run"><span class="n">trio</span><span class="o">.</span><span class="n">run</span></a><span class="p">(</span><span class="n">broken_double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>You might think that Python would raise an error here, like it does
for other kinds of mistakes we sometimes make when calling a
function. Like, if we forgot to pass <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> its required
argument, then we would get a nice <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> saying so. But
unfortunately, if you forget an <code class="docutils literal notranslate"><span class="pre">await</span></code>, you don't get that. What
you actually get is:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">broken_double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">*yawn* Going to sleep</span>
<span class="go">Woke up after 0.00 seconds, feeling well rested!</span>
<span class="go">__main__:4: RuntimeWarning: coroutine 'sleep' was never awaited</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>This is clearly broken – 0.00 seconds is not long enough to feel well
rested! Yet the code acts like it succeeded – no exception was
raised. The only clue that something went wrong is that it prints
<code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">coroutine</span> <span class="pre">'sleep'</span> <span class="pre">was</span> <span class="pre">never</span> <span class="pre">awaited</span></code>. Also, the
exact place where the warning is printed might vary, because it
depends on the whims of the garbage collector. If you're using PyPy,
you might not even get a warning at all until the next GC collection
runs:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># On PyPy:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">broken_double_sleep</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">*yawn* Going to sleep</span>
<span class="go">Woke up after 0.00 seconds, feeling well rested!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># what the ... ?? not even a warning!</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but forcing a garbage collection gives us a warning:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc" title="gc"><span class="nn">gc</span></a>
<span class="gp">&gt;&gt;&gt; </span><a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/gc.html#gc.collect" title="gc.collect"><span class="n">gc</span><span class="o">.</span><span class="n">collect</span></a><span class="p">()</span>
<span class="go">/home/njs/pypy-3.8-nightly/lib-python/3/importlib/_bootstrap.py:191: RuntimeWarning: coroutine 'sleep' was never awaited</span>
<span class="go">if _module_locks.get(name) is wr:    # XXX PyPy fix?</span>
<span class="go">0</span>
</pre></div>
</div>
<p>(If you can't see the warning above, try scrolling right.)</p>
<p>Forgetting an <code class="docutils literal notranslate"><span class="pre">await</span></code> like this is an <em>incredibly common
mistake</em>. You will mess this up. Everyone does. And Python will not
help you as much as you'd hope 😞. The key thing to remember is: if
you see the magic words <code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">coroutine</span> <span class="pre">'...'</span> <span class="pre">was</span> <span class="pre">never</span>
<span class="pre">awaited</span></code>, then this <em>always</em> means that you made the mistake of
leaving out an <code class="docutils literal notranslate"><span class="pre">await</span></code> somewhere, and you should ignore all the
other error messages you see and go fix that first, because there's a
good chance the other stuff is just collateral damage. I'm not even
sure what all that other junk in the PyPy output is. Fortunately I
don't need to know, I just need to fix my function!</p>
<p>("I thought you said you weren't going to mention coroutines!" Yes,
well, <em>I</em> didn't mention coroutines, Python did. Take it up with
Guido! But seriously, this is unfortunately a place where the internal
implementation details do leak out a bit.)</p>
<p>Why does this happen? In Trio, every time we use <code class="docutils literal notranslate"><span class="pre">await</span></code> it's to
call an async function, and every time we call an async function we
use <code class="docutils literal notranslate"><span class="pre">await</span></code>. But Python's trying to keep its options open for other
libraries that are <em>ahem</em> a little less organized about things. So
while for our purposes we can think of <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(...)</span></code> as a
single piece of syntax, Python thinks of it as two things: first a
function call that returns this weird "coroutine" object:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;coroutine object sleep at 0x7f5ac77be6d0&gt;</span>
</pre></div>
</div>
<p>and then that object gets passed to <code class="docutils literal notranslate"><span class="pre">await</span></code>, which actually runs the
function. So if you forget <code class="docutils literal notranslate"><span class="pre">await</span></code>, then two bad things happen: your
function doesn't actually get called, and you get a "coroutine" object
where you might have been expecting something else, like a number:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">async_double</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">TypeError: unsupported operand type(s) for +: 'coroutine' and 'int'</span>
</pre></div>
</div>
<p>If you didn't already mess this up naturally, then give it a try on
purpose: try writing some code with a missing <code class="docutils literal notranslate"><span class="pre">await</span></code>, or an extra
<code class="docutils literal notranslate"><span class="pre">await</span></code>, and see what you get. This way you'll be prepared for when
it happens to you for real.</p>
<p>And remember: watch out for <code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">coroutine</span> <span class="pre">'...'</span> <span class="pre">was</span>
<span class="pre">never</span> <span class="pre">awaited</span></code>; it means you need to find and fix your missing
<code class="docutils literal notranslate"><span class="pre">await</span></code>.</p>
</div>
</div>
</section>
<section id="id5">
<h3>好的，让我们看一些很酷的东西<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<p><strong>Okay, let's see something cool already</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--5-input--1" name="tab-set--5" type="radio"/><label class="tab-label" for="tab-set--5-input--1">中文</label><div class="tab-content docutils container">
<p>现在我们开始使用 Trio 了，但到目前为止我们所做的只是编写打印内容和等待不同时间长度的函数。这固然有趣，但我们也可以用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/time.html#time.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a> 来实现这些功能。 <code class="docutils literal notranslate"><span class="pre">async/await</span></code> 看起来似乎没什么用！</p>
<p>当然，事实并非如此。Trio 还有一个隐藏的技巧，它使得异步函数比普通函数更强大：它可以*同时*运行多个异步函数。以下是一个示例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># tasks-intro.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">trio</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child1</span><span class="p">():</span>
<span class="linenos"> 7</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos"> 8</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos"> 9</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: exiting!"</span><span class="p">)</span>
<span class="linenos">10</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child2</span><span class="p">():</span>
<span class="linenos">13</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: exiting!"</span><span class="p">)</span>
<span class="linenos">16</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: started!"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child1..."</span><span class="p">)</span>
<span class="linenos">22</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child2..."</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: waiting for children to finish..."</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="c1"># -- we exit the nursery block here --</span>
<span class="linenos">29</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: all done!"</span><span class="p">)</span>
<span class="linenos">30</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</div>
<p>这里有很多内容，所以我们将逐步解释。首先，我们定义了两个异步函数 <code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code>。这些内容您应该在上一节中看到过：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 6</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child1</span><span class="p">():</span>
<span class="linenos"> 7</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos"> 8</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos"> 9</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: exiting!"</span><span class="p">)</span>
<span class="linenos">10</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child2</span><span class="p">():</span>
<span class="linenos">13</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: exiting!"</span><span class="p">)</span>
</pre></div>
</div>
<p>接下来，我们定义了 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 作为一个异步函数，它将同时调用 <code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: started!"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child1..."</span><span class="p">)</span>
<span class="linenos">22</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child2..."</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: waiting for children to finish..."</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="c1"># -- we exit the nursery block here --</span>
<span class="linenos">29</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: all done!"</span><span class="p">)</span>
</pre></div>
</div>
<p>实现这一点的方法是使用一个神秘的 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 语句来创建一个“nursery”，然后将 <code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code> 启动在该 nursery 中。</p>
<p>让我们先从 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 说起。其实这非常简单。在普通的 Python 中，类似 <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">someobj:</span> <span class="pre">...</span></code> 的语句会指示解释器在代码块的开始调用 <code class="docutils literal notranslate"><span class="pre">someobj.__enter__()</span></code>，在代码块的结束时调用 <code class="docutils literal notranslate"><span class="pre">someobj.__exit__()</span></code>。我们称 <code class="docutils literal notranslate"><span class="pre">someobj</span></code> 为“上下文管理器”。而 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 做的完全相同，只不过普通的 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句调用的是普通方法，而 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 语句则调用异步方法：在代码块的开始，它会执行 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">someobj.__aenter__()</span></code>，在代码块的结束则会执行 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">someobj.__aexit__()</span></code>。在这种情况下，我们称 <code class="docutils literal notranslate"><span class="pre">someobj</span></code> 为“异步上下文管理器”。简单来说：<code class="docutils literal notranslate"><span class="pre">with</span></code> 语句只是调用一些函数的简写，由于 Python 引入了 async/await 使得有了两种不同的函数，因此也需要两种不同的 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句。就是这么简单！如果您理解异步函数，那么您也就理解了 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>虽然这个例子中没有使用到，但我们还是顺便提一下 async/await 新增的另一个语法：<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>。这与 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 和 <code class="docutils literal notranslate"><span class="pre">with</span></code> 的对比类似：一个 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 循环和普通的 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环几乎一样，区别在于普通的 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环通过 <code class="docutils literal notranslate"><span class="pre">iterator.__next__()</span></code> 来获取下一个项，而 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 循环则通过 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_iterator.__anext__()</span></code> 来获取。现在您已经了解了所有关于 async/await 的内容了。记住，这基本就是在创建 sandwich（嵌套结构）时在所有内容前面加上 "async"，您会发现这样就能轻松驾驭它。</p>
</div>
<p>既然我们了解了 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>，让我们再回到 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 的实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: started!"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child1..."</span><span class="p">)</span>
<span class="linenos">22</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child2..."</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: waiting for children to finish..."</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="c1"># -- we exit the nursery block here --</span>
<span class="linenos">29</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: all done!"</span><span class="p">)</span>
</pre></div>
</div>
<p>这里只有 4 行代码是实际操作的。第 20 行中，我们使用 <a class="reference internal" href="ref-core/tasks.html#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_nursery()</span></code></a> 获取一个“nursery”对象，然后在 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 代码块中分别在第 22 行和第 25 行调用 <code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code>。调用异步函数其实有两种方式：一种是我们之前见到的 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn()</span></code>，新的方式是 <code class="docutils literal notranslate"><span class="pre">nursery.start_soon(async_fn)</span></code>：它请求 Trio 启动该异步函数，<em>但会立即返回而不等待函数完成</em>。因此，在两次调用 <code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code> 之后，<code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code> 已经在后台运行了。然后在第 28 行（带注释的那一行），我们到了 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 代码块的末尾，触发 nursery 的 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 方法。这会强制 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 在此停下，并等待 nursery 中所有的子任务结束。这就是为什么使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 来获取 nursery 的原因：它确保子任务不会自行运行而被遗弃。这样做的一个重要原因是，如果子任务中有一个出现了错误或其他问题并引发异常，那么该异常可以被传递到父任务中；而在许多其他框架中，这样的异常通常会被忽略。Trio 永远不会忽略异常。</p>
<p>好了！让我们运行一下，看看会得到什么输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parent: started!
parent: spawning child1...
parent: spawning child2...
parent: waiting for children to finish...
child2: started! sleeping now...
child1: started! sleeping now...
   [... 1 秒后 ...]
child1: exiting!
child2: exiting!
parent: all done!
</pre></div>
</div>
<p>（您的输出中“started”和/或“exiting”行的顺序可能会有所不同。）</p>
<p>请注意，<code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code> 都几乎同时启动并一起退出。而且，尽管我们调用了两次 <code class="docutils literal notranslate"><span class="pre">trio.sleep(1)</span></code>，程序却在总共一秒内完成了。所以看起来 <code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code> 真的是同时运行的！</p>
<p>如果您对线程编程比较熟悉，这可能会让您感到熟悉——这是有意的。但需要注意的是 <em>这里没有任何线程</em> 。所有这些操作都在一个线程中完成。为提醒我们这一点，我们使用了不同的术语：我们不是生成两个“线程”，而是生成两个“任务”。任务和线程之间有两个不同点：(1) 单个线程可以轮流运行多个任务；(2) 在线程中，Python 解释器/操作系统可以随意切换正在运行的线程，而在任务中，我们只能在某些特定的地方（我们称之为 <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">"checkpoints"</span></a>）切换任务。在下一节中，我们将深入探讨这意味着什么。</p>
</div>
<input class="tab-input" id="tab-set--5-input--2" name="tab-set--5" type="radio"/><label class="tab-label" for="tab-set--5-input--2">英文</label><div class="tab-content docutils container">
<p>So now we've started using Trio, but so far all we've learned to do is
write functions that print things and sleep for various lengths of
time. Interesting enough, but we could just as easily have done that
with <a class="reference external" href="https://docs.python.org/zh-cn/3/library/time.html#time.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">async/await</span></code> is useless!</p>
<p>Well, not really. Trio has one more trick up its sleeve, that makes
async functions more powerful than regular functions: it can run
multiple async functions <em>at the same time</em>. Here's an example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># tasks-intro.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">trio</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child1</span><span class="p">():</span>
<span class="linenos"> 7</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos"> 8</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos"> 9</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: exiting!"</span><span class="p">)</span>
<span class="linenos">10</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child2</span><span class="p">():</span>
<span class="linenos">13</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: exiting!"</span><span class="p">)</span>
<span class="linenos">16</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: started!"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child1..."</span><span class="p">)</span>
<span class="linenos">22</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child2..."</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: waiting for children to finish..."</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="c1"># -- we exit the nursery block here --</span>
<span class="linenos">29</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: all done!"</span><span class="p">)</span>
<span class="linenos">30</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</div>
<p>There's a lot going on in here, so we'll take it one step at a
time. In the first part, we define two async functions <code class="docutils literal notranslate"><span class="pre">child1</span></code> and
<code class="docutils literal notranslate"><span class="pre">child2</span></code>. These should look familiar from the last section:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 6</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child1</span><span class="p">():</span>
<span class="linenos"> 7</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos"> 8</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos"> 9</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child1: exiting!"</span><span class="p">)</span>
<span class="linenos">10</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="k">async</span> <span class="k">def</span> <span class="nf">child2</span><span class="p">():</span>
<span class="linenos">13</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: started! sleeping now..."</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"  child2: exiting!"</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we define <code class="docutils literal notranslate"><span class="pre">parent</span></code> as an async function that's going to call
<code class="docutils literal notranslate"><span class="pre">child1</span></code> and <code class="docutils literal notranslate"><span class="pre">child2</span></code> concurrently:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: started!"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child1..."</span><span class="p">)</span>
<span class="linenos">22</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child2..."</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: waiting for children to finish..."</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="c1"># -- we exit the nursery block here --</span>
<span class="linenos">29</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: all done!"</span><span class="p">)</span>
</pre></div>
</div>
<p>It does this by using a mysterious <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement to create
a "nursery", and then "spawns" <code class="docutils literal notranslate"><span class="pre">child1</span></code> and <code class="docutils literal notranslate"><span class="pre">child2</span></code> into the
nursery.</p>
<p>Let's start with this <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> thing. It's actually pretty
simple. In regular Python, a statement like <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">someobj:</span> <span class="pre">...</span></code>
instructs the interpreter to call <code class="docutils literal notranslate"><span class="pre">someobj.__enter__()</span></code> at the
beginning of the block, and to call <code class="docutils literal notranslate"><span class="pre">someobj.__exit__()</span></code> at the end
of the block. We call <code class="docutils literal notranslate"><span class="pre">someobj</span></code> a "context manager". An <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> does exactly the same thing, except that where a regular
<code class="docutils literal notranslate"><span class="pre">with</span></code> statement calls regular methods, an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement
calls async methods: at the start of the block it does <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">someobj.__aenter__()</span></code> and at that end of the block it does <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">someobj.__aexit__()</span></code>. In this case we call <code class="docutils literal notranslate"><span class="pre">someobj</span></code> an "async
context manager". So in short: <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks are a shorthand for
calling some functions, and since with async/await Python now has two
kinds of functions, it also needs two kinds of <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks. That's
all there is to it! If you understand async functions, then you
understand <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>This example doesn't use them, but while we're here we might as
well mention the one other piece of new syntax that async/await
added: <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>. It's basically the same idea as <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> versus <code class="docutils literal notranslate"><span class="pre">with</span></code>: An <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop is just like a
<code class="docutils literal notranslate"><span class="pre">for</span></code> loop, except that where a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop does
<code class="docutils literal notranslate"><span class="pre">iterator.__next__()</span></code> to fetch the next item, an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>
does <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_iterator.__anext__()</span></code>. Now you understand all
of async/await. Basically just remember that it involves making
sandwiches and sticking the word "async" in front of everything,
and you'll do fine.</p>
</div>
<p>Now that we understand <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>, let's look at <code class="docutils literal notranslate"><span class="pre">parent</span></code> again:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: started!"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child1..."</span><span class="p">)</span>
<span class="linenos">22</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child1</span><span class="p">)</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning child2..."</span><span class="p">)</span>
<span class="linenos">25</span>        <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">child2</span><span class="p">)</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: waiting for children to finish..."</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="c1"># -- we exit the nursery block here --</span>
<span class="linenos">29</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: all done!"</span><span class="p">)</span>
</pre></div>
</div>
<p>There are only 4 lines of code that really do anything here. On line
20, we use <a class="reference internal" href="ref-core/tasks.html#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_nursery()</span></code></a> to get a "nursery" object, and
then inside the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block we call <code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code> twice,
on lines 22 and 25. There are actually two ways to call an async
function: the first one is the one we already saw, using <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">async_fn()</span></code>; the new one is <code class="docutils literal notranslate"><span class="pre">nursery.start_soon(async_fn)</span></code>: it asks Trio
to start running this async function, <em>but then returns immediately
without waiting for the function to finish</em>. So after our two calls to
<code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code>, <code class="docutils literal notranslate"><span class="pre">child1</span></code> and <code class="docutils literal notranslate"><span class="pre">child2</span></code> are now running in the
background. And then at line 28, the commented line, we hit the end of
the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block, and the nursery's <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> function
runs. What this does is force <code class="docutils literal notranslate"><span class="pre">parent</span></code> to stop here and wait for all
the children in the nursery to exit. This is why you have to use
<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> to get a nursery: it gives us a way to make sure that
the child calls can't run away and get lost. One reason this is
important is that if there's a bug or other problem in one of the
children, and it raises an exception, then it lets us propagate that
exception into the parent; in many other frameworks, exceptions like
this are just discarded. Trio never discards exceptions.</p>
<p>Ok! Let's try running it and see what we get:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parent: started!
parent: spawning child1...
parent: spawning child2...
parent: waiting for children to finish...
child2: started! sleeping now...
child1: started! sleeping now...
   [... 1 second passes ...]
child1: exiting!
child2: exiting!
parent: all done!
</pre></div>
</div>
<p>(Your output might have the order of the "started" and/or "exiting"
lines swapped compared to mine.)</p>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">child1</span></code> and <code class="docutils literal notranslate"><span class="pre">child2</span></code> both start together and then
both exit together. And, even though we made two calls to
<code class="docutils literal notranslate"><span class="pre">trio.sleep(1)</span></code>, the program finished in just one second total.
So it looks like <code class="docutils literal notranslate"><span class="pre">child1</span></code> and <code class="docutils literal notranslate"><span class="pre">child2</span></code> really are running at the
same time!</p>
<p>Now, if you're familiar with programming using threads, this might
look familiar – and that's intentional. But it's important to realize
that <em>there are no threads here</em>. All of this is happening in a single
thread. To remind ourselves of this, we use slightly different
terminology: instead of spawning two "threads", we say that we spawned
two "tasks". There are two differences between tasks and threads: (1)
many tasks can take turns running on a single thread, and (2) with
threads, the Python interpreter/operating system can switch which
thread is running whenever they feel like it; with tasks, we can only
switch at certain designated places we call <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">"checkpoints"</span></a>. In the next section, we'll dig into what this means.</p>
</div>
</div>
</section>
<section id="tutorial-instrument-example">
<span id="id6"></span><h3>任务切换说明<a class="headerlink" href="#tutorial-instrument-example" title="Link to this heading">¶</a></h3>
<p><strong>Task switching illustrated</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--6-input--1" name="tab-set--6" type="radio"/><label class="tab-label" for="tab-set--6-input--1">中文</label><div class="tab-content docutils container">
<p>基于 async/await 的库（如 Trio）背后的核心思想是通过在适当的地方切换任务，使得在单线程上同时运行多个任务——例如，如果我们在实现一个 Web 服务器，那么一个任务可以在另一个任务等待新连接时发送 HTTP 响应。如果您只想使用 Trio，那么您不需要理解这些切换是如何工作的所有细节——但至少对 Trio 在执行代码时“幕后”做了什么有一个大致的直觉是很有用的。为了帮助建立这种直觉，让我们仔细看看 Trio 是如何运行我们上一节中的示例的。</p>
<p>幸运的是，Trio 提供了一套 <a class="reference internal" href="reference-lowlevel.html#instrumentation"><span class="std std-ref">丰富的工具集用于检查和调试程序</span></a>。在这里，我们想要观察 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 的工作过程，可以通过编写一个名为 <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> 的类来实现，它实现了 Trio 的 <a class="reference internal" href="reference-lowlevel.html#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></a> 接口。它的任务是记录各种事件的发生：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tracer</span><span class="p">(</span><span class="n">trio</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Instrument</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">before_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"!!! run started"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_print_with_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="c1"># repr(task) is perhaps more useful than task.name in general,</span>
        <span class="c1"># but in context of a tutorial the extra noise is unhelpful.</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_spawned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"### new task spawned"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_scheduled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"### task scheduled"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">before_task_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"&gt;&gt;&gt; about to run one step of task"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">after_task_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"&lt;&lt;&lt; task step finished"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_exited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"### task exited"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">before_io_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">timeout</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"### waiting for I/O for up to </span><span class="si">{</span><span class="n">timeout</span><span class="si">}</span><span class="s2"> seconds"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"### doing a quick check for I/O"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">current_time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">after_io_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">current_time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"### finished I/O check (took </span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2"> seconds)"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">after_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"!!! run finished"</span><span class="p">)</span>
</pre></div>
</div>
<p>然后我们重新运行上一节中的示例程序，但这次我们将一个 <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> 对象传递给 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">instruments</span><span class="o">=</span><span class="p">[</span><span class="n">Tracer</span><span class="p">()])</span>
</pre></div>
</div>
<p>这将产生 <em>大量</em> 的输出，因此我们将逐步进行分析。</p>
<p>首先，在 Trio 准备好运行代码时，会有一些初步的输出。大部分内容目前对我们来说并不重要，但在其中我们可以看到，Trio 为 <code class="docutils literal notranslate"><span class="pre">__main__.parent</span></code> 函数创建了一个任务，并“调度”了它（即，记录了应该尽快运行它）：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 tutorial/tasks-with-trace.py
!!! run started
### new task spawned: &lt;init&gt;
### task scheduled: &lt;init&gt;
### doing a quick check for I/O
### finished I/O check (took 1.1122087016701698e-05 seconds)
&gt;&gt;&gt; about to run one step of task: &lt;init&gt;
### new task spawned: &lt;call soon task&gt;
### task scheduled: &lt;call soon task&gt;
### new task spawned: __main__.parent
### task scheduled: __main__.parent
&lt;&lt;&lt; task step finished: &lt;init&gt;
### doing a quick check for I/O
### finished I/O check (took 6.4980704337358475e-06 seconds)
</pre></div>
</div>
<p>一旦初步的准备工作完成，Trio 就开始运行 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 函数，并且您可以看到 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 创建了两个子任务。然后它遇到 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 代码块的末尾并暂停：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: __main__.parent
parent: started!
parent: spawning child1...
### new task spawned: __main__.child1
### task scheduled: __main__.child1
parent: spawning child2...
### new task spawned: __main__.child2
### task scheduled: __main__.child2
parent: waiting for children to finish...
&lt;&lt;&lt; task step finished: __main__.parent
</pre></div>
</div>
<p>接下来控制返回给 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>，它记录了一些内部的额外输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: &lt;call soon task&gt;
&lt;&lt;&lt; task step finished: &lt;call soon task&gt;
### doing a quick check for I/O
### finished I/O check (took 5.476875230669975e-06 seconds)
</pre></div>
</div>
<p>然后给两个子任务一个运行的机会：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: __main__.child2
child2 started! sleeping now...
&lt;&lt;&lt; task step finished: __main__.child2

&gt;&gt;&gt; about to run one step of task: __main__.child1
child1: started! sleeping now...
&lt;&lt;&lt; task step finished: __main__.child1
</pre></div>
</div>
<p>每个任务运行直到遇到 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 的调用，然后我们就会回到 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 来决定接下来要运行什么。这个过程是如何发生的呢？秘密在于 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 和 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 的协同工作： <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 具有一些特殊的魔法，允许它暂停自己，因此它会发送一个通知给 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>，请求在 1 秒后再次唤醒它，然后暂停任务。一旦任务被暂停，Python 就会将控制权交回给 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>，后者决定接下来要做什么。（如果这听起来类似于生成器通过执行 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 来暂停执行，那不是巧合：在 Python 解释器内部，生成器和异步函数的实现有很多重叠。）</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>您可能会想知道是否可以将不同异步库的原语混合使用。例如，我们能不能将 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 和 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a> 一起使用？答案是否定的，我们不能这样做，上面的一段解释了原因：我们的异步三明治的两侧使用了不同的私有语言来互相通信，而不同的库使用不同的语言。因此，如果您试图在 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 中调用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>，Trio 会变得非常混乱，可能会以某种戏剧性的方式崩溃。</p>
</div>
<p>只有异步函数才能访问暂停任务的特殊魔法，因此只有异步函数才能导致程序切换到不同的任务。这意味着，如果一个调用 <em>没有</em> 加上 <code class="docutils literal notranslate"><span class="pre">await</span></code>，那么你就知道它 <em>不能</em> 成为任务被暂停的地方。这使得任务比线程更容易推理，因为任务之间可以交替执行并互相干扰状态的方式少得多。（例如，在 Trio 中，像 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">1</span></code> 这样的语句总是原子的——即使 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是某个任意复杂的自定义对象！）Trio 还提供了一些 <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">额外的保证</span></a>，但这是其中最重要的一条。</p>
<p>现在你也知道为什么 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 必须使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 来打开育儿所：如果我们使用常规的 <code class="docutils literal notranslate"><span class="pre">with</span></code> 块，它就不能在结束时暂停并等待子任务完成；我们需要清理函数是异步的，这正是 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 为我们提供的。</p>
<p>现在，回到我们的执行点。总结一下：此时 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 正在等待 <code class="docutils literal notranslate"><span class="pre">child1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">child2</span></code>, 而这两个子任务都在睡眠。所以 <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 检查它的记录，发现直到这些睡眠完成之前没有什么可以做的——除非可能发生一些外部的 I/O 事件。如果发生了这种情况，它可能会给我们一些事情去做。当然，我们这里没有进行 I/O 操作，所以不会发生，但在其他情况下是可能的。所以接下来它调用操作系统的原语让整个进程进入睡眠状态：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### waiting for I/O for up to 0.9999009938910604 seconds
</pre></div>
</div>
<p>事实上，I/O 并没有到来，所以一秒钟后我们再次醒来，Trio 再次检查它的记录。此时它检查当前时间，将其与 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 发送的记录进行比较，记录中指出两个子任务应该在何时再次被唤醒，Trio 意识到它们已经睡了足够长的时间，因此它将它们调度尽快运行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### finished I/O check (took 1.0006483688484877 seconds)
### task scheduled: __main__.child1
### task scheduled: __main__.child2
</pre></div>
</div>
<p>然后，子任务开始运行，这一次它们运行到完成。记得 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 正在等待它们完成吗？注意当第一个子任务退出时， <code class="docutils literal notranslate"><span class="pre">parent</span></code> 是如何被调度的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: __main__.child1
child1: exiting!
### task scheduled: __main__.parent
### task exited: __main__.child1
&lt;&lt;&lt; task step finished: __main__.child1

&gt;&gt;&gt; about to run one step of task: __main__.child2
child2 exiting!
### task exited: __main__.child2
&lt;&lt;&lt; task step finished: __main__.child2
</pre></div>
</div>
<p>然后，在再次检查 I/O 后， <code class="docutils literal notranslate"><span class="pre">parent</span></code> 醒来。育儿所清理代码注意到它的所有子任务都已退出，并允许育儿所块完成。接着， <code class="docutils literal notranslate"><span class="pre">parent</span></code> 打印最终结果并退出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### doing a quick check for I/O
### finished I/O check (took 9.045004844665527e-06 seconds)

&gt;&gt;&gt; about to run one step of task: __main__.parent
parent: all done!
### task scheduled: &lt;init&gt;
### task exited: __main__.parent
&lt;&lt;&lt; task step finished: __main__.parent
</pre></div>
</div>
<p>最后，经过一些内部的账务处理，<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> 也退出了：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### doing a quick check for I/O
### finished I/O check (took 5.996786057949066e-06 seconds)
&gt;&gt;&gt; about to run one step of task: &lt;init&gt;
### task scheduled: &lt;call soon task&gt;
### task scheduled: &lt;init&gt;
&lt;&lt;&lt; task step finished: &lt;init&gt;
### doing a quick check for I/O
### finished I/O check (took 6.258022040128708e-06 seconds)
&gt;&gt;&gt; about to run one step of task: &lt;call soon task&gt;
### task exited: &lt;call soon task&gt;
&lt;&lt;&lt; task step finished: &lt;call soon task&gt;
&gt;&gt;&gt; about to run one step of task: &lt;init&gt;
### task exited: &lt;init&gt;
&lt;&lt;&lt; task step finished: &lt;init&gt;
!!! run finished
</pre></div>
</div>
<p>你完成了！</p>
<p>这段文本有点长，但再次强调，你不需要理解所有内容就能使用 Trio——事实上，Trio 竭尽全力使每个任务看起来像是以简单、线性的方式执行的。（就像你的操作系统竭尽全力让你感觉单线程的代码是以简单线性的方式执行的，尽管在背后操作系统像 Trio 一样在不同的线程和进程之间进行切换。）但了解你编写的代码是如何实际执行的，以及最重要的——它对并行性的影响——是有帮助的。</p>
<p>另外，如果这段内容激起了你进一步了解 <code class="docutils literal notranslate"><span class="pre">async/await</span></code> 内部工作原理的兴趣，那么 <a class="reference external" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">这篇博客文章</a> 是一个很好的深入探讨，或者可以查看 <a class="reference external" href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">这个很棒的教程</a>，了解如何从零开始构建一个简单的异步 I/O 框架。</p>
</div>
<input class="tab-input" id="tab-set--6-input--2" name="tab-set--6" type="radio"/><label class="tab-label" for="tab-set--6-input--2">英文</label><div class="tab-content docutils container">
<p>The big idea behind async/await-based libraries like Trio is to run
lots of tasks simultaneously on a single thread by switching between
them at appropriate places – so for example, if we're implementing a
web server, then one task could be sending an HTTP response at the
same time as another task is waiting for new connections. If all you
want to do is use Trio, then you don't need to understand all the
nitty-gritty detail of how this switching works – but it's very useful
to have at least a general intuition about what Trio is doing "under
the hood" when your code is executing. To help build that intuition,
let's look more closely at how Trio ran our example from the last
section.</p>
<p>Fortunately, Trio provides a <a class="reference internal" href="reference-lowlevel.html#instrumentation"><span class="std std-ref">rich set of tools for inspecting
and debugging your programs</span></a>. Here we want to watch
<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> at work, which we can do by writing a class we'll
call <code class="docutils literal notranslate"><span class="pre">Tracer</span></code>, which implements Trio's <a class="reference internal" href="reference-lowlevel.html#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></a>
interface. Its job is to log various events as they happen:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tracer</span><span class="p">(</span><span class="n">trio</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Instrument</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">before_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"!!! run started"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_print_with_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="c1"># repr(task) is perhaps more useful than task.name in general,</span>
        <span class="c1"># but in context of a tutorial the extra noise is unhelpful.</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_spawned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"### new task spawned"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_scheduled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"### task scheduled"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">before_task_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"&gt;&gt;&gt; about to run one step of task"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">after_task_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"&lt;&lt;&lt; task step finished"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">task_exited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_with_task</span><span class="p">(</span><span class="s2">"### task exited"</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">before_io_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">timeout</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"### waiting for I/O for up to </span><span class="si">{</span><span class="n">timeout</span><span class="si">}</span><span class="s2"> seconds"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"### doing a quick check for I/O"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">current_time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">after_io_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">trio</span><span class="o">.</span><span class="n">current_time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"### finished I/O check (took </span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2"> seconds)"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">after_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"!!! run finished"</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we re-run our example program from the previous section, but this
time we pass <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> a <code class="docutils literal notranslate"><span class="pre">Tracer</span></code> object:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">instruments</span><span class="o">=</span><span class="p">[</span><span class="n">Tracer</span><span class="p">()])</span>
</pre></div>
</div>
<p>This generates a <em>lot</em> of output, so we'll go through it one step at a
time.</p>
<p>First, there's a bit of chatter while Trio gets ready to run our
code. Most of this is irrelevant to us for now, but in the middle you
can see that Trio has created a task for the <code class="docutils literal notranslate"><span class="pre">__main__.parent</span></code>
function, and "scheduled" it (i.e., made a note that it should be run
soon):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 tutorial/tasks-with-trace.py
!!! run started
### new task spawned: &lt;init&gt;
### task scheduled: &lt;init&gt;
### doing a quick check for I/O
### finished I/O check (took 1.1122087016701698e-05 seconds)
&gt;&gt;&gt; about to run one step of task: &lt;init&gt;
### new task spawned: &lt;call soon task&gt;
### task scheduled: &lt;call soon task&gt;
### new task spawned: __main__.parent
### task scheduled: __main__.parent
&lt;&lt;&lt; task step finished: &lt;init&gt;
### doing a quick check for I/O
### finished I/O check (took 6.4980704337358475e-06 seconds)
</pre></div>
</div>
<p>Once the initial housekeeping is done, Trio starts running the
<code class="docutils literal notranslate"><span class="pre">parent</span></code> function, and you can see <code class="docutils literal notranslate"><span class="pre">parent</span></code> creating the two child
tasks. Then it hits the end of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block, and pauses:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: __main__.parent
parent: started!
parent: spawning child1...
### new task spawned: __main__.child1
### task scheduled: __main__.child1
parent: spawning child2...
### new task spawned: __main__.child2
### task scheduled: __main__.child2
parent: waiting for children to finish...
&lt;&lt;&lt; task step finished: __main__.parent
</pre></div>
</div>
<p>Control then goes back to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, which logs a bit more
internal chatter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: &lt;call soon task&gt;
&lt;&lt;&lt; task step finished: &lt;call soon task&gt;
### doing a quick check for I/O
### finished I/O check (took 5.476875230669975e-06 seconds)
</pre></div>
</div>
<p>And then gives the two child tasks a chance to run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: __main__.child2
child2 started! sleeping now...
&lt;&lt;&lt; task step finished: __main__.child2

&gt;&gt;&gt; about to run one step of task: __main__.child1
child1: started! sleeping now...
&lt;&lt;&lt; task step finished: __main__.child1
</pre></div>
</div>
<p>Each task runs until it hits the call to <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a>, and then
suddenly we're back in <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> deciding what to run next. How
does this happen? The secret is that <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> and
<a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> work together to make it happen: <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a>
has access to some special magic that lets it pause itself,
so it sends a note to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> requesting to be
woken again after 1 second, and then suspends the task. And once the
task is suspended, Python gives control back to <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>,
which decides what to do next. (If this sounds similar to the way that
generators can suspend execution by doing a <code class="docutils literal notranslate"><span class="pre">yield</span></code>, then that's not
a coincidence: inside the Python interpreter, there's a lot of overlap
between the implementation of generators and async functions.)</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>You might wonder whether you can mix-and-match primitives from
different async libraries. For example, could we use
<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> together with <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>? The answer is
no, we can't, and the paragraph above explains why: the two sides
of our async sandwich have a private language they use to talk to
each other, and different libraries use different languages. So if
you try to call <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a> from inside a
<a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, then Trio will get very confused indeed and
probably blow up in some dramatic way.</p>
</div>
<p>Only async functions have access to the special magic for suspending a
task, so only async functions can cause the program to switch to a
different task. What this means is that if a call <em>doesn't</em> have an <code class="docutils literal notranslate"><span class="pre">await</span></code>
on it, then you know that it <em>can't</em> be a place where your task will
be suspended. This makes tasks much <a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">easier to reason about</a> than
threads, because there are far fewer ways that tasks can be
interleaved with each other and stomp on each others' state. (For
example, in Trio a statement like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">1</span></code> is always atomic – even
if <code class="docutils literal notranslate"><span class="pre">a</span></code> is some arbitrarily complicated custom object!) Trio also
makes some <a class="reference internal" href="ref-core/general_principles.html#checkpoints"><span class="std std-ref">further guarantees beyond that</span></a>, but
that's the big one.</p>
<p>And now you also know why <code class="docutils literal notranslate"><span class="pre">parent</span></code> had to use an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> to
open the nursery: if we had used a regular <code class="docutils literal notranslate"><span class="pre">with</span></code> block, then it
wouldn't have been able to pause at the end and wait for the children
to finish; we need our cleanup function to be async, which is exactly
what <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> gives us.</p>
<p>Now, back to our execution point. To recap: at this point <code class="docutils literal notranslate"><span class="pre">parent</span></code>
is waiting on <code class="docutils literal notranslate"><span class="pre">child1</span></code> and <code class="docutils literal notranslate"><span class="pre">child2</span></code>, and both children are
sleeping. So <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> checks its notes, and sees that there's
nothing to be done until those sleeps finish – unless possibly some
external I/O event comes in. If that happened, then it might give us
something to do. Of course we aren't doing any I/O here so it won't
happen, but in other situations it could. So next it calls an
operating system primitive to put the whole process to sleep:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### waiting for I/O for up to 0.9999009938910604 seconds
</pre></div>
</div>
<p>And in fact no I/O does arrive, so one second later we wake up again,
and Trio checks its notes again. At this point it checks the current
time, compares it to the notes that <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> sent saying
when the two child tasks should be woken up again, and realizes
that they've slept for long enough, so it schedules them to run soon:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### finished I/O check (took 1.0006483688484877 seconds)
### task scheduled: __main__.child1
### task scheduled: __main__.child2
</pre></div>
</div>
<p>And then the children get to run, and this time they run to
completion. Remember how <code class="docutils literal notranslate"><span class="pre">parent</span></code> is waiting for them to finish?
Notice how <code class="docutils literal notranslate"><span class="pre">parent</span></code> gets scheduled when the first child exits:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; about to run one step of task: __main__.child1
child1: exiting!
### task scheduled: __main__.parent
### task exited: __main__.child1
&lt;&lt;&lt; task step finished: __main__.child1

&gt;&gt;&gt; about to run one step of task: __main__.child2
child2 exiting!
### task exited: __main__.child2
&lt;&lt;&lt; task step finished: __main__.child2
</pre></div>
</div>
<p>Then, after another check for I/O, <code class="docutils literal notranslate"><span class="pre">parent</span></code> wakes up. The nursery
cleanup code notices that all its children have exited, and lets the
nursery block finish. And then <code class="docutils literal notranslate"><span class="pre">parent</span></code> makes a final print and
exits:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### doing a quick check for I/O
### finished I/O check (took 9.045004844665527e-06 seconds)

&gt;&gt;&gt; about to run one step of task: __main__.parent
parent: all done!
### task scheduled: &lt;init&gt;
### task exited: __main__.parent
&lt;&lt;&lt; task step finished: __main__.parent
</pre></div>
</div>
<p>And finally, after a bit more internal bookkeeping, <a class="reference internal" href="ref-core/run.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>
exits too:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### doing a quick check for I/O
### finished I/O check (took 5.996786057949066e-06 seconds)
&gt;&gt;&gt; about to run one step of task: &lt;init&gt;
### task scheduled: &lt;call soon task&gt;
### task scheduled: &lt;init&gt;
&lt;&lt;&lt; task step finished: &lt;init&gt;
### doing a quick check for I/O
### finished I/O check (took 6.258022040128708e-06 seconds)
&gt;&gt;&gt; about to run one step of task: &lt;call soon task&gt;
### task exited: &lt;call soon task&gt;
&lt;&lt;&lt; task step finished: &lt;call soon task&gt;
&gt;&gt;&gt; about to run one step of task: &lt;init&gt;
### task exited: &lt;init&gt;
&lt;&lt;&lt; task step finished: &lt;init&gt;
!!! run finished
</pre></div>
</div>
<p>You made it!</p>
<p>That was a lot of text, but again, you don't need to understand
everything here to use Trio – in fact, Trio goes to great lengths to
make each task feel like it executes in a simple, linear way. (Just
like your operating system goes to great lengths to make it feel like
your single-threaded code executes in a simple linear way, even though
under the covers the operating system juggles between different
threads and processes in essentially the same way Trio does.) But it
is useful to have a rough model in your head of how the code you write
is actually executed, and – most importantly – the consequences of
that for parallelism.</p>
<p>Alternatively, if this has just whetted your appetite and you want to
know more about how <code class="docutils literal notranslate"><span class="pre">async/await</span></code> works internally, then <a class="reference external" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">this blog
post</a>
is a good deep dive, or check out <a class="reference external" href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">this great walkthrough</a> to see
how to build a simple async I/O framework from the ground up.</p>
</div>
</div>
</section>
</section>
<section id="gil">
<h2>更友好、更温和的 GIL<a class="headerlink" href="#gil" title="Link to this heading">¶</a></h2>
<p><strong>A kinder, gentler GIL</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--7-input--1" name="tab-set--7" type="radio"/><label class="tab-label" for="tab-set--7-input--1">中文</label><div class="tab-content docutils container">
<p>说到并行性——让我们稍微拉远一点，讨论一下 <cite>async/await</cite> 与 Python 中处理并发的其他方式的比较。</p>
<p>正如我们已经提到的，Trio 任务在概念上与 Python 内建的线程非常相似，这些线程是通过 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块提供的。在所有常见的 Python 实现中，线程有一个著名的限制: 全局解释器锁（Global Interpreter Lock，简称 GIL）。GIL 意味着即使你使用多个线程，你的代码仍然（大多数情况下）会在单核上运行。人们往往会觉得这很让人沮丧。</p>
<p>但从 Trio 的角度来看，GIL 的问题不是它限制了并行性。当然，如果 Python 有更好的方法来利用多个核心那会很好，但这是一个极其困难的问题，而在此期间，很多时候单核就足够用了——或者如果单核不够用，进程级或机器级的并行性也可以很好地解决问题。</p>
<p>不，GIL 的问题在于它是一个 <em>糟糕的交易</em>：我们放弃了使用多个核心，而得到的却是……几乎所有真正并行编程带来的挑战和令人困惑的 bug，而且——雪上加霜的是，<a class="reference external" href="https://twitter.com/hynek/status/771790449057132544">相当差的可扩展性</a>。Python 中的线程实在没有什么吸引力。</p>
<p>Trio 并不会让你的代码在多个核心上运行；实际上，正如我们上面所看到的，Trio 的设计本身就规定了当它有多个任务时，这些任务会轮流执行，因此在任何时刻，只有一个任务在积极运行。我们并不是在克服 GIL，而是在接受它。但是，如果你愿意接受这一点，并且额外花点时间把新的 <code class="docutils literal notranslate"><span class="pre">async</span></code> 和 <code class="docutils literal notranslate"><span class="pre">await</span></code> 关键字放在正确的位置，那么作为回报，你将获得：</p>
<ul class="simple">
<li><p>极好的可扩展性：只要它们的总 CPU 需求不超过单个核心的处理能力，Trio 可以同时运行 10,000 个以上的任务，而不感到吃力。（例如，这在网络服务器中很常见，服务器可能有大量的客户端连接，但在任何时刻只有少数几个客户端是活跃的。）</p></li>
<li><p>强大的功能：大多数线程系统都是用 C 实现的，并且受限于操作系统提供的功能。在 Trio 中，我们的逻辑完全用 Python 实现，这使得可以实现强大且符合人体工学的功能，例如 <a class="reference internal" href="ref-core/cancel_timeout.html#cancellation"><span class="std std-ref">Trio 的取消系统</span></a>。</p></li>
<li><p>更容易推理的代码：<code class="docutils literal notranslate"><span class="pre">await</span></code> 关键字意味着每个函数中潜在的任务切换点是显式标记的。这使得 Trio 代码比使用线程的等效程序更容易推理，<a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">可以大大简化推理过程</a>。</p></li>
</ul>
<p>当然，这并不适用于每个应用程序……但在很多情况下，这里的权衡看起来相当有吸引力。</p>
<p>然而，有一个缺点需要特别注意。使检查点显式化让你可以更好地控制任务如何交替执行——但强大的控制力带来了巨大的责任。对于线程，运行时环境负责确保每个线程得到公平的运行时间。而在 Trio 中，如果某个任务运行几秒钟而没有执行检查点，那么……你所有的其他任务就得等着了。</p>
<p>以下是一个如何出错的示例。以我们之前的 <a class="reference internal" href="#tutorial-example-tasks-intro"><span class="std std-ref">示例</span></a> 为例，替换掉调用 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> 的地方，改为调用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/time.html#time.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a>。如果我们运行修改后的程序，我们会看到类似这样的输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parent: started!
parent: spawning child1...
parent: spawning child2...
parent: waiting for children to finish...
child2 started! sleeping now...
   [... 暂停 1 秒 ...]
child2 exiting!
child1: started! sleeping now...
   [... 暂停 1 秒 ...]
child1: exiting!
parent: all done!
</pre></div>
</div>
<p>Trio 之所以拥有如此丰富的 <a class="reference internal" href="#tutorial-instrument-example"><span class="std std-ref">工具 API</span></a>，主要是为了使编写调试工具成为可能，帮助捕捉到像这样的潜在问题。</p>
</div>
<input class="tab-input" id="tab-set--7-input--2" name="tab-set--7" type="radio"/><label class="tab-label" for="tab-set--7-input--2">英文</label><div class="tab-content docutils container">
<p>Speaking of parallelism – let's zoom out for a moment and talk about
how async/await compares to other ways of handling concurrency in
Python.</p>
<p>As we've already noted, Trio tasks are conceptually rather similar to
Python's built-in threads, as provided by the <a class="reference external" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>
module. And in all common Python implementations, threads have a
famous limitation: the Global Interpreter Lock, or "GIL" for
short. The GIL means that even if you use multiple threads, your code
still (mostly) ends up running on a single core. People tend to find
this frustrating.</p>
<p>But from Trio's point of view, the problem with the GIL isn't that it
restricts parallelism. Of course it would be nice if Python had better
options for taking advantage of multiple cores, but that's an
extremely difficult problem to solve, and in the meantime there are
lots of problems where a single core is totally adequate – or where if
it isn't, then process-level or machine-level parallelism works fine.</p>
<p>No, the problem with the GIL is that it's a <em>lousy deal</em>: we give up
on using multiple cores, and in exchange we get... almost all the same
challenges and mind-bending bugs that come with real parallel
programming, and – to add insult to injury – <a class="reference external" href="https://twitter.com/hynek/status/771790449057132544">pretty poor scalability</a>. Threads in
Python just aren't that appealing.</p>
<p>Trio doesn't make your code run on multiple cores; in fact, as we saw
above, it's baked into Trio's design that when it has multiple tasks,
they take turns, so at each moment only one of them is actively running.
We're not so much overcoming the GIL as embracing it. But if you're
willing to accept that, plus a bit of extra work to put these new
<code class="docutils literal notranslate"><span class="pre">async</span></code> and <code class="docutils literal notranslate"><span class="pre">await</span></code> keywords in the right places, then in exchange
you get:</p>
<ul class="simple">
<li><p>Excellent scalability: Trio can run 10,000+ tasks simultaneously
without breaking a sweat, so long as their total CPU demands don't
exceed what a single core can provide. (This is common in, for
example, network servers that have lots of clients connected, but
only a few active at any given time.)</p></li>
<li><p>Fancy features: most threading systems are implemented in C and
restricted to whatever features the operating system provides. In
Trio our logic is all in Python, which makes it possible to
implement powerful and ergonomic features like <a class="reference internal" href="ref-core/cancel_timeout.html#cancellation"><span class="std std-ref">Trio's
cancellation system</span></a>.</p></li>
<li><p>Code that's easier to reason about: the <code class="docutils literal notranslate"><span class="pre">await</span></code> keyword means that
potential task-switching points are explicitly marked within each
function. This can make Trio code <a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">dramatically easier to reason
about</a>
than the equivalent program using threads.</p></li>
</ul>
<p>Certainly it's not appropriate for every app... but there are a lot of
situations where the trade-offs here look pretty appealing.</p>
<p>There is one downside that's important to keep in mind, though. Making
checkpoints explicit gives you more control over how your tasks can be
interleaved – but with great power comes great responsibility. With
threads, the runtime environment is responsible for making sure that
each thread gets its fair share of running time. With Trio, if some
task runs off and does stuff for seconds on end without executing a
checkpoint, then... all your other tasks will just have to wait.</p>
<p>Here's an example of how this can go wrong. Take our <a class="reference internal" href="#tutorial-example-tasks-intro"><span class="std std-ref">example
from above</span></a>, and replace the calls to
<a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> with calls to <a class="reference external" href="https://docs.python.org/zh-cn/3/library/time.html#time.sleep" title="（在 Python v3.13）"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a>. If we run our
modified program, we'll see something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parent: started!
parent: spawning child1...
parent: spawning child2...
parent: waiting for children to finish...
child2 started! sleeping now...
   [... pauses for 1 second ...]
child2 exiting!
child1: started! sleeping now...
   [... pauses for 1 second ...]
child1: exiting!
parent: all done!
</pre></div>
</div>
<p>One of the major reasons why Trio has such a rich
<a class="reference internal" href="#tutorial-instrument-example"><span class="std std-ref">instrumentation API</span></a> is to make it
possible to write debugging tools to catch issues like this.</p>
</div>
</div>
</section>
<section id="trio">
<h2>使用 Trio 进行网络编程<a class="headerlink" href="#trio" title="Link to this heading">¶</a></h2>
<p><strong>Networking with Trio</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--8-input--1" name="tab-set--8" type="radio"/><label class="tab-label" for="tab-set--8-input--1">中文</label><div class="tab-content docutils container">
<p>现在让我们利用所学的知识来进行一些 I/O 操作，这正是 <cite>async/await</cite> 真正展现优势的地方。</p>
<p>传统的用于演示网络 API 的小型应用程序是“回显服务器”：一个程序，它等待来自远程客户端的任意数据，然后将相同的数据原封不动地发送回去。（也许现在一个更相关的例子是一个执行大量并发 HTTP 请求的应用程序，但对于那个你需要一个 <a class="reference external" href="https://github.com/python-trio/trio/issues/236#issuecomment-310784001">HTTP 库</a> ，比如 <a class="reference external" href="https://asks.readthedocs.io">asks</a>，所以我们还是沿用回显服务器的传统。）</p>
<p>在本教程中，我们展示了管道的两端：客户端和服务器。客户端定期向服务器发送数据，并显示其响应。服务器等待连接；当一个客户端连接时，它会将接收到的数据重新发送回管道。</p>
</div>
<input class="tab-input" id="tab-set--8-input--2" name="tab-set--8" type="radio"/><label class="tab-label" for="tab-set--8-input--2">英文</label><div class="tab-content docutils container">
<p>Now let's take what we've learned and use it to do some I/O, which is
where async/await really shines.</p>
<p>The traditional toy application for demonstrating network APIs is an
"echo server": a program that awaits arbitrary data from  remote clients,
and then sends that same data right back. (Probably a more relevant example
these days would be an application that does lots of concurrent HTTP
requests, but for that <a class="reference external" href="https://github.com/python-trio/trio/issues/236#issuecomment-310784001">you need an HTTP library</a>
such as <a class="reference external" href="https://asks.readthedocs.io">asks</a>, so we'll stick
with the echo server tradition.)</p>
<p>In this tutorial, we present both ends of the pipe: the client, and the
server. The client periodically sends data to the server, and displays its
answers. The server awaits connections; when a client connects, it recopies
the received data back on the pipe.</p>
</div>
</div>
<section id="id7">
<h3>回显客户端<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<p><strong>An echo client</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--9-input--1" name="tab-set--9" type="radio"/><label class="tab-label" for="tab-set--9-input--1">中文</label><div class="tab-content docutils container">
<p>首先，这是一个回显 <em>客户端</em> 的示例，也就是一个将数据发送到我们的回显服务器并接收响应的程序：</p>
<div class="highlight-python3 notranslate" id="tutorial-echo-client-example"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># echo-client.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">sys</span>
<span class="linenos"> 4</span><span class="kn">import</span> <span class="nn">trio</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="c1"># arbitrary, but:</span>
<span class="linenos"> 7</span><span class="c1"># - must be in between 1024 and 65535</span>
<span class="linenos"> 8</span><span class="c1"># - can't be in use by some other program on your computer</span>
<span class="linenos"> 9</span><span class="c1"># - must match what we set in our echo server</span>
<span class="linenos">10</span><span class="n">PORT</span> <span class="o">=</span> <span class="mi">12345</span>
<span class="linenos">11</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="k">async</span> <span class="k">def</span> <span class="nf">sender</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">14</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"sender: started!"</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="linenos">16</span>        <span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"async can sometimes be confusing, but I believe in you!"</span>
<span class="linenos">17</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"sender: sending </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">18</span>        <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">19</span>        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">20</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="k">async</span> <span class="k">def</span> <span class="nf">receiver</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">23</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: started!"</span><span class="p">)</span>
<span class="linenos">24</span>    <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">25</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"receiver: got data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">26</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: connection closed"</span><span class="p">)</span>
<span class="linenos">27</span>    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
<span class="linenos">28</span>
<span class="linenos">29</span>
<span class="linenos">30</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">31</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"parent: connecting to 127.0.0.1:</span><span class="si">{</span><span class="n">PORT</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">32</span>    <span class="n">client_stream</span> <span class="o">=</span> <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_tcp_stream</span><span class="p">(</span><span class="s2">"127.0.0.1"</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="linenos">33</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">34</span>        <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">35</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning sender..."</span><span class="p">)</span>
<span class="linenos">36</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning receiver..."</span><span class="p">)</span>
<span class="linenos">39</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
<span class="linenos">40</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意，这段代码如果没有我们下面实现的 TCP 服务器将无法正常工作。</p>
<p>这里的整体结构应该是熟悉的，因为它就像我们之前的 <a class="reference internal" href="#tutorial-example-tasks-intro"><span class="std std-ref">示例</span></a>：我们有一个父任务，它生成两个子任务来执行实际工作，然后在 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 块的末尾，它切换到全职的父任务模式，等待子任务完成。但现在，子任务不仅仅调用 <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a>，它们使用了 Trio 的一些网络 API。</p>
<p>我们先来看一下父任务：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">30</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">31</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"parent: connecting to 127.0.0.1:</span><span class="si">{</span><span class="n">PORT</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">32</span>    <span class="n">client_stream</span> <span class="o">=</span> <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_tcp_stream</span><span class="p">(</span><span class="s2">"127.0.0.1"</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="linenos">33</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">34</span>        <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">35</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning sender..."</span><span class="p">)</span>
<span class="linenos">36</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning receiver..."</span><span class="p">)</span>
<span class="linenos">39</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
</pre></div>
</div>
<p>首先，我们调用 <a class="reference internal" href="ref-io/abs_api.html#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_tcp_stream()</span></code></a> 来与服务器建立 TCP 连接。<code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> 是一个特殊的 <a class="reference external" href="https://en.wikipedia.org/wiki/IP_address">IP 地址</a>，表示“我正在运行的计算机”，所以这将连接到本地计算机上使用 <code class="docutils literal notranslate"><span class="pre">PORT</span></code> 作为其联系点的程序。该函数返回一个实现了 Trio 的 <a class="reference internal" href="ref-io/abs_api.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> 接口的对象，该接口提供了发送和接收字节的方法，以及在完成时关闭连接的方法。我们使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 块来确保我们关闭连接 —— 在像这样的玩具示例中，这并不是什么大问题，但这是一个很好的习惯，而且 Trio 被设计成使得 <code class="docutils literal notranslate"><span class="pre">with</span></code> 和 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 块易于使用。</p>
<p>最后，我们启动两个子任务，并将流的引用传递给它们每一个。（这也是一个很好的示例，展示了 <code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code> 如何让你传递位置参数给生成的函数。）</p>
<p>第一个任务的工作是向服务器发送数据：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">13</span><span class="k">async</span> <span class="k">def</span> <span class="nf">sender</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">14</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"sender: started!"</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="linenos">16</span>        <span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"async can sometimes be confusing, but I believe in you!"</span>
<span class="linenos">17</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"sender: sending </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">18</span>        <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">19</span>        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>它使用一个循环，在调用 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">client_stream.send_all(...)</span></code> 发送一些数据（这是你在任何类型的 Trio 流上发送数据时使用的方法）和休眠一秒钟之间交替进行，以避免在终端上输出滚动得太快。</p>
<p>第二个任务的工作是处理服务器返回的数据：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">22</span><span class="k">async</span> <span class="k">def</span> <span class="nf">receiver</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">23</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: started!"</span><span class="p">)</span>
<span class="linenos">24</span>    <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">25</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"receiver: got data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">26</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: connection closed"</span><span class="p">)</span>
<span class="linenos">27</span>    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</pre></div>
</div>
<p>它使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 循环从服务器获取数据。或者，它可以使用 <cite>~trio.abc.ReceiveStream.receive_some</cite>，这是 <cite>~trio.abc.SendStream.send_all</cite> 的反向操作，但使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 可以节省一些样板代码。</p>
<p>现在我们准备来看服务器部分。</p>
</div>
<input class="tab-input" id="tab-set--9-input--2" name="tab-set--9" type="radio"/><label class="tab-label" for="tab-set--9-input--2">英文</label><div class="tab-content docutils container">
<p>To start with, here's an example echo <em>client</em>, i.e., the program that
will send some data at our echo server and get responses back:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># echo-client.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">sys</span>
<span class="linenos"> 4</span><span class="kn">import</span> <span class="nn">trio</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="c1"># arbitrary, but:</span>
<span class="linenos"> 7</span><span class="c1"># - must be in between 1024 and 65535</span>
<span class="linenos"> 8</span><span class="c1"># - can't be in use by some other program on your computer</span>
<span class="linenos"> 9</span><span class="c1"># - must match what we set in our echo server</span>
<span class="linenos">10</span><span class="n">PORT</span> <span class="o">=</span> <span class="mi">12345</span>
<span class="linenos">11</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="k">async</span> <span class="k">def</span> <span class="nf">sender</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">14</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"sender: started!"</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="linenos">16</span>        <span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"async can sometimes be confusing, but I believe in you!"</span>
<span class="linenos">17</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"sender: sending </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">18</span>        <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">19</span>        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">20</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="k">async</span> <span class="k">def</span> <span class="nf">receiver</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">23</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: started!"</span><span class="p">)</span>
<span class="linenos">24</span>    <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">25</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"receiver: got data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">26</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: connection closed"</span><span class="p">)</span>
<span class="linenos">27</span>    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
<span class="linenos">28</span>
<span class="linenos">29</span>
<span class="linenos">30</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">31</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"parent: connecting to 127.0.0.1:</span><span class="si">{</span><span class="n">PORT</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">32</span>    <span class="n">client_stream</span> <span class="o">=</span> <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_tcp_stream</span><span class="p">(</span><span class="s2">"127.0.0.1"</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="linenos">33</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">34</span>        <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">35</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning sender..."</span><span class="p">)</span>
<span class="linenos">36</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning receiver..."</span><span class="p">)</span>
<span class="linenos">39</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
<span class="linenos">40</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that this code will not work without a TCP server such as the one
we'll implement below.</p>
<p>The overall structure here should be familiar, because it's just like
our <a class="reference internal" href="#tutorial-example-tasks-intro"><span class="std std-ref">last example</span></a>: we have a
parent task, which spawns two child tasks to do the actual work, and
then at the end of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block it switches into full-time
parenting mode while waiting for them to finish. But now instead of
just calling <a class="reference internal" href="ref-core/time_clock.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a>, the children use some of Trio's
networking APIs.</p>
<p>Let's look at the parent first:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">30</span><span class="k">async</span> <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
<span class="linenos">31</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"parent: connecting to 127.0.0.1:</span><span class="si">{</span><span class="n">PORT</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">32</span>    <span class="n">client_stream</span> <span class="o">=</span> <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_tcp_stream</span><span class="p">(</span><span class="s2">"127.0.0.1"</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="linenos">33</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">34</span>        <span class="k">async</span> <span class="k">with</span> <span class="n">trio</span><span class="o">.</span><span class="n">open_nursery</span><span class="p">()</span> <span class="k">as</span> <span class="n">nursery</span><span class="p">:</span>
<span class="linenos">35</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning sender..."</span><span class="p">)</span>
<span class="linenos">36</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">"parent: spawning receiver..."</span><span class="p">)</span>
<span class="linenos">39</span>            <span class="n">nursery</span><span class="o">.</span><span class="n">start_soon</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">client_stream</span><span class="p">)</span>
</pre></div>
</div>
<p>First we call <a class="reference internal" href="ref-io/abs_api.html#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_tcp_stream()</span></code></a> to make a TCP connection to
the server. <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> is a magic <a class="reference external" href="https://en.wikipedia.org/wiki/IP_address">IP address</a> meaning "the computer
I'm running on", so this connects us to whatever program on the local
computer is using <code class="docutils literal notranslate"><span class="pre">PORT</span></code> as its contact point. This function returns
an object implementing Trio's <a class="reference internal" href="ref-io/abs_api.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> interface,
which gives us methods to send and receive bytes, and to close the
connection when we're done. We use an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block to make
sure that we do close the connection – not a big deal in a toy example
like this, but it's a good habit to get into, and Trio is designed to
make <code class="docutils literal notranslate"><span class="pre">with</span></code> and <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> blocks easy to use.</p>
<p>Finally, we start up two child tasks, and pass each of them a
reference to the stream. (This is also a good example of how
<code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code> lets you pass positional arguments to the
spawned function.)</p>
<p>Our first task's job is to send data to the server:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">13</span><span class="k">async</span> <span class="k">def</span> <span class="nf">sender</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">14</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"sender: started!"</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="linenos">16</span>        <span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"async can sometimes be confusing, but I believe in you!"</span>
<span class="linenos">17</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"sender: sending </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">18</span>        <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">19</span>        <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>It uses a loop that alternates between calling <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">client_stream.send_all(...)</span></code> to send some data (this is the method
you use for sending data on any kind of Trio stream), and then
sleeping for a second to avoid making the output scroll by too fast on
your terminal.</p>
<p>And the second task's job is to process the data the server sends back:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">22</span><span class="k">async</span> <span class="k">def</span> <span class="nf">receiver</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
<span class="linenos">23</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: started!"</span><span class="p">)</span>
<span class="linenos">24</span>    <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">client_stream</span><span class="p">:</span>
<span class="linenos">25</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"receiver: got data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">26</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">"receiver: connection closed"</span><span class="p">)</span>
<span class="linenos">27</span>    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</pre></div>
</div>
<p>It uses an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop to fetch data from the server.
Alternatively, it could use <cite>~trio.abc.ReceiveStream.receive_some</cite>,
which is the opposite of <cite>~trio.abc.SendStream.send_all</cite>, but using
<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> saves some boilerplate.</p>
<p>And now we're ready to look at the server.</p>
</div>
</div>
</section>
<section id="tutorial-echo-server-example">
<span id="id8"></span><h3>回显服务器<a class="headerlink" href="#tutorial-echo-server-example" title="Link to this heading">¶</a></h3>
<p><strong>An echo server</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--10-input--1" name="tab-set--10" type="radio"/><label class="tab-label" for="tab-set--10-input--1">中文</label><div class="tab-content docutils container">
<p>像往常一样，让我们先看一下完整的代码，然后再逐个讨论各个部分：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># echo-server.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">trio</span>
<span class="linenos"> 4</span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="c1"># Port is arbitrary, but:</span>
<span class="linenos"> 7</span><span class="c1"># - must be in between 1024 and 65535</span>
<span class="linenos"> 8</span><span class="c1"># - can't be in use by some other program on your computer</span>
<span class="linenos"> 9</span><span class="c1"># - must match what we set in our echo client</span>
<span class="linenos">10</span><span class="n">PORT</span> <span class="o">=</span> <span class="mi">12345</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="n">CONNECTION_COUNTER</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="linenos">13</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">server_stream</span><span class="p">):</span>
<span class="linenos">16</span>    <span class="c1"># Assign each connection a unique number to make our debug prints easier</span>
<span class="linenos">17</span>    <span class="c1"># to understand when there are multiple simultaneous connections.</span>
<span class="linenos">18</span>    <span class="n">ident</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">CONNECTION_COUNTER</span><span class="p">)</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: started"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">server_stream</span><span class="p">:</span>
<span class="linenos">22</span>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: received data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">23</span>            <span class="k">await</span> <span class="n">server_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: connection closed"</span><span class="p">)</span>
<span class="linenos">25</span>    <span class="c1"># FIXME: add discussion of (Base)ExceptionGroup to the tutorial, and use</span>
<span class="linenos">26</span>    <span class="c1"># exceptiongroup.catch() here. (Not important in this case, but important</span>
<span class="linenos">27</span>    <span class="c1"># if the server code uses nurseries internally.)</span>
<span class="linenos">28</span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="linenos">29</span>        <span class="c1"># Unhandled exceptions will propagate into our parent and take</span>
<span class="linenos">30</span>        <span class="c1"># down the whole program. If the exception is KeyboardInterrupt,</span>
<span class="linenos">31</span>        <span class="c1"># that's what we want, but otherwise maybe not...</span>
<span class="linenos">32</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: crashed: </span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">33</span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="linenos">36</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">serve_tcp</span><span class="p">(</span><span class="n">echo_server</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span>
<span class="linenos">39</span><span class="c1"># We could also just write 'trio.run(trio.serve_tcp, echo_server, PORT)', but real</span>
<span class="linenos">40</span><span class="c1"># programs almost always end up doing other stuff too and then we'd have to go</span>
<span class="linenos">41</span><span class="c1"># back and factor it out into a separate function anyway. So it's simplest to</span>
<span class="linenos">42</span><span class="c1"># just make it a standalone function from the beginning.</span>
<span class="linenos">43</span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>我们从 <code class="docutils literal notranslate"><span class="pre">main</span></code> 开始，它只有一行：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="linenos">36</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">serve_tcp</span><span class="p">(</span><span class="n">echo_server</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
</pre></div>
</div>
<p>这段代码调用了 <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a>，这是 Trio 提供的一个便捷函数，它会一直运行下去（或者至少直到你按下 Ctrl-C 或者以其他方式取消它）。这个函数执行了几件有用的事情：</p>
<ul class="simple">
<li><p>它在内部创建了一个 <cite>nursery</cite>，以便我们的服务器能够同时处理多个连接。</p></li>
<li><p>它监听指定的 <code class="docutils literal notranslate"><span class="pre">PORT</span></code> 上的传入 TCP 连接。</p></li>
<li><p>每当一个连接到来时，它就会启动一个新的任务，运行我们传递的函数（在这个示例中是 <code class="docutils literal notranslate"><span class="pre">echo_server</span></code>），并将表示该连接的流传递给它。</p></li>
<li><p>每当一个任务退出时，它会确保关闭相应的连接。（这就是为什么你在服务器端看不到任何 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span> <span class="pre">server_stream</span></code> 的原因 —— <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> 为我们处理了这个问题。）</p></li>
</ul>
<p>因此，<a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> 非常方便！这一部分几乎适用于任何服务器，无论是回显服务器、HTTP 服务器、SSH 服务器，还是其他类型的服务器，因此将这些功能封装成像这样的帮助函数是很有意义的。</p>
<p>接下来我们来看一下 <code class="docutils literal notranslate"><span class="pre">echo_server</span></code>，它处理每个客户端连接——因此如果有多个客户端，可能会有多个 <code class="docutils literal notranslate"><span class="pre">echo_server</span></code> 调用同时运行。这是我们实现服务器“回显”行为的地方。理解起来应该相当简单，因为它使用了我们在上一节中看到的相同流函数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">15</span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">server_stream</span><span class="p">):</span>
<span class="linenos">16</span>    <span class="c1"># Assign each connection a unique number to make our debug prints easier</span>
<span class="linenos">17</span>    <span class="c1"># to understand when there are multiple simultaneous connections.</span>
<span class="linenos">18</span>    <span class="n">ident</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">CONNECTION_COUNTER</span><span class="p">)</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: started"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">server_stream</span><span class="p">:</span>
<span class="linenos">22</span>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: received data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">23</span>            <span class="k">await</span> <span class="n">server_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: connection closed"</span><span class="p">)</span>
<span class="linenos">25</span>    <span class="c1"># FIXME: add discussion of (Base)ExceptionGroup to the tutorial, and use</span>
<span class="linenos">26</span>    <span class="c1"># exceptiongroup.catch() here. (Not important in this case, but important</span>
<span class="linenos">27</span>    <span class="c1"># if the server code uses nurseries internally.)</span>
<span class="linenos">28</span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="linenos">29</span>        <span class="c1"># Unhandled exceptions will propagate into our parent and take</span>
<span class="linenos">30</span>        <span class="c1"># down the whole program. If the exception is KeyboardInterrupt,</span>
<span class="linenos">31</span>        <span class="c1"># that's what we want, but otherwise maybe not...</span>
<span class="linenos">32</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: crashed: </span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
<p>参数 <code class="docutils literal notranslate"><span class="pre">server_stream</span></code> 是由 <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> 提供的，它是我们在客户端创建的连接的另一端：因此客户端传递给 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 的数据会从这里传出。然后我们有一个 <code class="docutils literal notranslate"><span class="pre">try</span></code> 块，稍后讨论，最后是服务器循环，循环在从套接字读取一些数据和将数据发送回去之间交替进行（除非套接字已关闭，这时我们会退出）。</p>
<p>那么这个 <code class="docutils literal notranslate"><span class="pre">try</span></code> 块是干什么的呢？记住，在 Trio 中，像 Python 一样，异常会一直传播，直到被捕获。这里我们认为可能会有一些意外的异常发生，因此我们希望将它们局限于让这一任务崩溃，而不影响整个程序的运行。例如，如果客户端在错误的时刻关闭连接，那么可能会导致这段代码在已关闭的连接上调用 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 并引发 <a class="reference internal" href="ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>；这虽然不太理想，在更复杂的程序中我们可能希望更明确地处理它，但它并不表示 <em>其他</em> 连接有问题。另一方面，如果异常是像 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 这样的，我们确实希望它传播到父任务并导致整个程序退出。为了表达这一点，我们使用了一个带有 <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception:</span></code> 处理程序的 <code class="docutils literal notranslate"><span class="pre">try</span></code> 块。</p>
<p>通常，Trio 和 Python 一样，允许你自己决定是否以及如何处理异常。</p>
</div>
<input class="tab-input" id="tab-set--10-input--2" name="tab-set--10" type="radio"/><label class="tab-label" for="tab-set--10-input--2">英文</label><div class="tab-content docutils container">
<p>As usual, let's look at the whole thing first, and then we'll discuss
the pieces:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># echo-server.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">trio</span>
<span class="linenos"> 4</span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="c1"># Port is arbitrary, but:</span>
<span class="linenos"> 7</span><span class="c1"># - must be in between 1024 and 65535</span>
<span class="linenos"> 8</span><span class="c1"># - can't be in use by some other program on your computer</span>
<span class="linenos"> 9</span><span class="c1"># - must match what we set in our echo client</span>
<span class="linenos">10</span><span class="n">PORT</span> <span class="o">=</span> <span class="mi">12345</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="n">CONNECTION_COUNTER</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="linenos">13</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">server_stream</span><span class="p">):</span>
<span class="linenos">16</span>    <span class="c1"># Assign each connection a unique number to make our debug prints easier</span>
<span class="linenos">17</span>    <span class="c1"># to understand when there are multiple simultaneous connections.</span>
<span class="linenos">18</span>    <span class="n">ident</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">CONNECTION_COUNTER</span><span class="p">)</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: started"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">server_stream</span><span class="p">:</span>
<span class="linenos">22</span>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: received data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">23</span>            <span class="k">await</span> <span class="n">server_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: connection closed"</span><span class="p">)</span>
<span class="linenos">25</span>    <span class="c1"># FIXME: add discussion of (Base)ExceptionGroup to the tutorial, and use</span>
<span class="linenos">26</span>    <span class="c1"># exceptiongroup.catch() here. (Not important in this case, but important</span>
<span class="linenos">27</span>    <span class="c1"># if the server code uses nurseries internally.)</span>
<span class="linenos">28</span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="linenos">29</span>        <span class="c1"># Unhandled exceptions will propagate into our parent and take</span>
<span class="linenos">30</span>        <span class="c1"># down the whole program. If the exception is KeyboardInterrupt,</span>
<span class="linenos">31</span>        <span class="c1"># that's what we want, but otherwise maybe not...</span>
<span class="linenos">32</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: crashed: </span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">33</span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="linenos">36</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">serve_tcp</span><span class="p">(</span><span class="n">echo_server</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span>
<span class="linenos">39</span><span class="c1"># We could also just write 'trio.run(trio.serve_tcp, echo_server, PORT)', but real</span>
<span class="linenos">40</span><span class="c1"># programs almost always end up doing other stuff too and then we'd have to go</span>
<span class="linenos">41</span><span class="c1"># back and factor it out into a separate function anyway. So it's simplest to</span>
<span class="linenos">42</span><span class="c1"># just make it a standalone function from the beginning.</span>
<span class="linenos">43</span><span class="n">trio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>Let's start with <code class="docutils literal notranslate"><span class="pre">main</span></code>, which is just one line long:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="linenos">36</span>    <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">serve_tcp</span><span class="p">(</span><span class="n">echo_server</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
</pre></div>
</div>
<p>What this does is call <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a>, which is a convenience
function Trio provides that runs forever (or at least until you hit
control-C or otherwise cancel it). This function does several helpful
things:</p>
<ul class="simple">
<li><p>It creates a nursery internally, so that our server will be able to
handle multiple connections at the same time.</p></li>
<li><p>It listens for incoming TCP connections on the specified <code class="docutils literal notranslate"><span class="pre">PORT</span></code>.</p></li>
<li><p>Whenever a connection arrives, it starts a new task running the
function we pass (in this example it's <code class="docutils literal notranslate"><span class="pre">echo_server</span></code>), and passes
it a stream representing that connection.</p></li>
<li><p>When each task exits, it makes sure to close the corresponding
connection. (That's why you don't see any <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span>
<span class="pre">server_stream</span></code> in the server – <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> takes care of this
for us.)</p></li>
</ul>
<p>So <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> is pretty handy! This part works pretty much the
same for any server, whether it's an echo server, HTTP server, SSH
server, or whatever, so it makes sense to bundle it all up together in
a helper function like this.</p>
<p>Now let's look at <code class="docutils literal notranslate"><span class="pre">echo_server</span></code>, which handles each client
connection – so if there are multiple clients, there might be multiple
calls to <code class="docutils literal notranslate"><span class="pre">echo_server</span></code> running at the same time. This is where we
implement our server's "echo" behavior. This should be pretty
straightforward to understand, because it uses the same stream
functions we saw in the last section:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos">15</span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_server</span><span class="p">(</span><span class="n">server_stream</span><span class="p">):</span>
<span class="linenos">16</span>    <span class="c1"># Assign each connection a unique number to make our debug prints easier</span>
<span class="linenos">17</span>    <span class="c1"># to understand when there are multiple simultaneous connections.</span>
<span class="linenos">18</span>    <span class="n">ident</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">CONNECTION_COUNTER</span><span class="p">)</span>
<span class="linenos">19</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: started"</span><span class="p">)</span>
<span class="linenos">20</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">21</span>        <span class="k">async</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">server_stream</span><span class="p">:</span>
<span class="linenos">22</span>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: received data </span><span class="si">{</span><span class="n">data</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
<span class="linenos">23</span>            <span class="k">await</span> <span class="n">server_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="linenos">24</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: connection closed"</span><span class="p">)</span>
<span class="linenos">25</span>    <span class="c1"># FIXME: add discussion of (Base)ExceptionGroup to the tutorial, and use</span>
<span class="linenos">26</span>    <span class="c1"># exceptiongroup.catch() here. (Not important in this case, but important</span>
<span class="linenos">27</span>    <span class="c1"># if the server code uses nurseries internally.)</span>
<span class="linenos">28</span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="linenos">29</span>        <span class="c1"># Unhandled exceptions will propagate into our parent and take</span>
<span class="linenos">30</span>        <span class="c1"># down the whole program. If the exception is KeyboardInterrupt,</span>
<span class="linenos">31</span>        <span class="c1"># that's what we want, but otherwise maybe not...</span>
<span class="linenos">32</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"echo_server </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">: crashed: </span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">server_stream</span></code> is provided by <a class="reference internal" href="ref-io/abs_api.html#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a>, and
is the other end of the connection we made in the client: so the data
that the client passes to <code class="docutils literal notranslate"><span class="pre">send_all</span></code> will come out here. Then we
have a <code class="docutils literal notranslate"><span class="pre">try</span></code> block discussed below, and finally the server loop
which alternates between reading some data from the socket and then
sending it back out again (unless the socket was closed, in which case
we quit).</p>
<p>So what's that <code class="docutils literal notranslate"><span class="pre">try</span></code> block for? Remember that in Trio, like Python
in general, exceptions keep propagating until they're caught. Here we
think it's plausible there might be unexpected exceptions, and we want
to isolate that to making just this one task crash, without taking
down the whole program. For example, if the client closes the
connection at the wrong moment then it's possible this code will end
up calling <code class="docutils literal notranslate"><span class="pre">send_all</span></code> on a closed connection and get a
<a class="reference internal" href="ref-core/exc_warn.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>; that's unfortunate, and in a more serious
program we might want to handle it more explicitly, but it doesn't
indicate a problem for any <em>other</em> connections. On the other hand, if
the exception is something like a <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, we <em>do</em>
want that to propagate out into the parent task and cause the whole
program to exit. To express this, we use a <code class="docutils literal notranslate"><span class="pre">try</span></code> block with an
<code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception:</span></code> handler.</p>
<p>In general, Trio leaves it up to you to decide whether and how you
want to handle exceptions, just like Python in general.</p>
</div>
</div>
</section>
<section id="id9">
<h3>尝试一下<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h3>
<p><strong>Try it out</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--11-input--1" name="tab-set--11" type="radio"/><label class="tab-label" for="tab-set--11-input--1">中文</label><div class="tab-content docutils container">
<p>打开几个终端，在一个终端中运行 <code class="docutils literal notranslate"><span class="pre">echo-server.py</span></code>，在另一个终端中运行 <code class="docutils literal notranslate"><span class="pre">echo-client.py</span></code>，然后观察消息的滚动！当你感到无聊时，可以通过按 Ctrl-C 来退出。</p>
<p>可以尝试的几件事：</p>
<ul class="simple">
<li><p>打开多个终端，同时运行多个客户端，所有客户端都与同一个服务器进行通信。</p></li>
<li><p>观察当你在客户端按下 Ctrl-C 时，服务器的反应。</p></li>
<li><p>观察当你在服务器按下 Ctrl-C 时，客户端的反应。</p></li>
</ul>
</div>
<input class="tab-input" id="tab-set--11-input--2" name="tab-set--11" type="radio"/><label class="tab-label" for="tab-set--11-input--2">英文</label><div class="tab-content docutils container">
<p>Open a few terminals, run <code class="docutils literal notranslate"><span class="pre">echo-server.py</span></code> in one, run
<code class="docutils literal notranslate"><span class="pre">echo-client.py</span></code> in another, and watch the messages scroll by! When
you get bored, you can exit by hitting control-C.</p>
<p>Some things to try:</p>
<ul class="simple">
<li><p>Open several terminals, and run multiple clients at the same time,
all talking to the same server.</p></li>
<li><p>See how the server reacts when you hit control-C on the client.</p></li>
<li><p>See how the client reacts when you hit control-C on the server.</p></li>
</ul>
</div>
</div>
</section>
<section id="id10">
<h3>回显客户端和服务器中的流控制<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p><strong>Flow control in our echo client and server</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--12-input--1" name="tab-set--12" type="radio"/><label class="tab-label" for="tab-set--12-input--1">中文</label><div class="tab-content docutils container">
<p>你可能会有一个疑问：为什么我们的客户端使用两个独立的任务来发送和接收数据，而不是像服务器那样使用一个任务来交替执行发送和接收？例如，我们的客户端可以使用一个像这样的单一任务：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 你能发现这段代码的两个问题吗？</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">send_and_receive</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
      <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">received</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">receive_some</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">received</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
      <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>事实证明，这段代码有两个问题——一个是小问题，一个是大问题。两个问题都与流量控制有关。小问题是，当我们调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 时，我们并没有等待 <em>所有</em> 数据都可用； <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 会在 <em>任何</em> 数据可用时立即返回。如果 <code class="docutils literal notranslate"><span class="pre">data</span></code> 很小，那么操作系统/网络/服务器 <em>可能</em> 会把它们一起发送，但没有保证。如果服务器发送的是 <code class="docutils literal notranslate"><span class="pre">hello</span></code>，我们可能会收到 <code class="docutils literal notranslate"><span class="pre">hello</span></code>、 <code class="docutils literal notranslate"><span class="pre">he</span></code> <code class="docutils literal notranslate"><span class="pre">llo</span></code>、 <code class="docutils literal notranslate"><span class="pre">h</span></code> <code class="docutils literal notranslate"><span class="pre">e</span></code> <code class="docutils literal notranslate"><span class="pre">l</span></code> <code class="docutils literal notranslate"><span class="pre">l</span></code> <code class="docutils literal notranslate"><span class="pre">o</span></code>，或者... 总之，每当我们期望的数据超过一个字节时，我们就必须准备好多次调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>。</p>
<p>特别是在这种情况下，如果 <code class="docutils literal notranslate"><span class="pre">data</span></code> 足够大，超过了某个内部阈值，操作系统或网络可能决定总是将其分成多个部分。现在在每次循环中，我们发送了 <code class="docutils literal notranslate"><span class="pre">len(data)</span></code> 字节，但读取的却少于这个数量。结果就像是内存泄漏：数据会越来越多地堆积在网络中，直到最终某个地方出问题。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你想知道 <em>如何</em> 出问题，可以使用
<a class="reference internal" href="ref-io/abs_api.html#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-func docutils literal notranslate"><span class="pre">receive_some()</span></code></a> 的可选参数来限制每次读取的字节数，然后看看会发生什么。</p>
</div>
<p>我们可以通过跟踪每一时刻预期的数据量，并一直调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>，直到我们接收到所有数据，从而修复这个问题：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">expected</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#len" title="len"><span class="nb">len</span></a><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">while</span> <span class="n">expected</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
   <span class="n">received</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">receive_some</span><span class="p">(</span><span class="n">expected</span><span class="p">)</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">received</span><span class="p">:</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="n">expected</span> <span class="o">-=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#len" title="len"><span class="nb">len</span></a><span class="p">(</span><span class="n">received</span><span class="p">)</span>
</pre></div>
</div>
<p>虽然这有点繁琐，但它能解决这个问题。</p>
<p>然而，还有一个更深层次的问题。我们仍然在交替执行发送和接收操作。注意，当我们发送数据时，我们使用了 <code class="docutils literal notranslate"><span class="pre">await</span></code>：这意味着发送操作可能会 <em>阻塞</em>。为什么会这样？我们发送的任何数据首先都会进入操作系统的缓冲区，然后传输到网络，接着进入接收计算机的另一个操作系统缓冲区，最后接收程序调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 来从这些缓冲区中取出数据。如果我们用少量数据调用 <code class="docutils literal notranslate"><span class="pre">send_all</span></code>，它会进入这些缓冲区，<code class="docutils literal notranslate"><span class="pre">send_all</span></code> 会立即返回。但是，如果我们足够快速地发送大量数据，缓冲区最终会填满，<code class="docutils literal notranslate"><span class="pre">send_all</span></code> 会阻塞，直到远端调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 并释放一些空间。</p>
<p>现在从服务器的角度考虑。每次它调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 时，都会获取一些数据，并且需要将这些数据发送回去。在发送数据之前，暂时存储在内存中的数据占用了内存。计算机的 RAM 是有限的，所以如果我们的服务器行为规范，那么在某些时刻，它需要停止调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>，直到它通过自己的 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 调用清理掉一些旧数据。所以对于服务器而言，唯一可行的方案是交替执行接收和发送。</p>
<p>但是我们需要记住，不仅是客户端的 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 可能会阻塞：服务器的 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 也可能进入阻塞状态，直到客户端调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>。所以如果服务器在调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 之前等待 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 完成，而我们的客户端也在等待 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 完成后再调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>，... 我们就遇到问题了！客户端不会调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>，直到服务器调用了 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>；而服务器不会调用 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>，直到客户端调用了 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>。如果我们的客户端是按发送和接收交替进行编写的，而且它尝试发送的那块数据足够大（例如，10MB 的数据在大多数配置下应该就能触发问题），那么这两个进程就会 <a class="reference external" href="https://en.wikipedia.org/wiki/Deadlock">死锁</a>。</p>
<p>教训：Trio 提供了强大的工具来管理顺序和并发执行。在这个例子中，我们看到服务器需要 <code class="docutils literal notranslate"><span class="pre">send</span></code> 和 <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> 按顺序交替执行，而客户端则需要它们并发执行，且两者都很容易实现。但是当你在实现像这样的网络代码时，必须小心地考虑流量控制和缓冲问题，因为你必须选择正确的执行模式！</p>
<p>其他流行的异步库，比如 <a class="reference external" href="https://twistedmatrix.com/">Twisted</a> 和 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>，通常通过到处放置无限制的缓冲区来掩盖这些问题。这可以避免死锁，但也会带来其他问题，特别是会使得 <a class="reference external" href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/#three-bugs">内存使用和延迟</a> 难以控制。虽然这两种方法都有其优点，但 Trio 的立场是，最好尽可能直接暴露底层问题，并提供良好的工具来直面它。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你想试着故意制造死锁来亲自看看发生什么，并且你使用的是 Windows，那么你可能需要将 <code class="docutils literal notranslate"><span class="pre">send_all</span></code> 调用分成两个分别发送一半数据的调用。这是因为 Windows 在处理缓冲区时有一个 <a class="reference external" href="https://stackoverflow.com/questions/28785626/what-is-the-size-of-a-socket-send-buffer-in-windows">有些不寻常的方式</a>。</p>
</div>
</div>
<input class="tab-input" id="tab-set--12-input--2" name="tab-set--12" type="radio"/><label class="tab-label" for="tab-set--12-input--2">英文</label><div class="tab-content docutils container">
<p>Here's a question you might be wondering about: why does our client
use two separate tasks for sending and receiving, instead of a single
task that alternates between them – like the server has? For example,
our client could use a single task like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Can you spot the two problems with this code?</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">send_and_receive</span><span class="p">(</span><span class="n">client_stream</span><span class="p">):</span>
   <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
      <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">received</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">receive_some</span><span class="p">()</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">received</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
      <span class="k">await</span> <span class="n">trio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>It turns out there are two problems with this – one minor and one
major. Both relate to flow control. The minor problem is that when we
call <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> here we're not waiting for <em>all</em> the data to be
available; <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> returns as soon as <em>any</em> data is available. If
<code class="docutils literal notranslate"><span class="pre">data</span></code> is small, then our operating systems / network / server will
<em>probably</em> keep it all together in a single chunk, but there's no
guarantee. If the server sends <code class="docutils literal notranslate"><span class="pre">hello</span></code> then we might get <code class="docutils literal notranslate"><span class="pre">hello</span></code>,
or <code class="docutils literal notranslate"><span class="pre">he</span></code> <code class="docutils literal notranslate"><span class="pre">llo</span></code>, or <code class="docutils literal notranslate"><span class="pre">h</span></code> <code class="docutils literal notranslate"><span class="pre">e</span></code> <code class="docutils literal notranslate"><span class="pre">l</span></code> <code class="docutils literal notranslate"><span class="pre">l</span></code> <code class="docutils literal notranslate"><span class="pre">o</span></code>, or ... bottom
line, any time we're expecting more than one byte of data, we have to
be prepared to call <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> multiple times.</p>
<p>And where this would go especially wrong is if we find ourselves in
the situation where <code class="docutils literal notranslate"><span class="pre">data</span></code> is big enough that it passes some
internal threshold, and the operating system or network decide to
always break it up into multiple pieces. Now on each pass through the
loop, we send <code class="docutils literal notranslate"><span class="pre">len(data)</span></code> bytes, but read less than that. The result
is something like a memory leak: we'll end up with more and more data
backed up in the network, until eventually something breaks.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>If you're curious <em>how</em> things break, then you can use
<a class="reference internal" href="ref-io/abs_api.html#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-func docutils literal notranslate"><span class="pre">receive_some()</span></code></a>'s optional argument to put
a limit on how many bytes you read each time, and see what happens.</p>
</div>
<p>We could fix this by keeping track of how much data we're expecting at
each moment, and then keep calling <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> until we get it all:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">expected</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#len" title="len"><span class="nb">len</span></a><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">while</span> <span class="n">expected</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
   <span class="n">received</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client_stream</span><span class="o">.</span><span class="n">receive_some</span><span class="p">(</span><span class="n">expected</span><span class="p">)</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">received</span><span class="p">:</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="n">expected</span> <span class="o">-=</span> <a class="sphinx-codeautolink-a" href="https://docs.python.org/zh-cn/3/library/functions.html#len" title="len"><span class="nb">len</span></a><span class="p">(</span><span class="n">received</span><span class="p">)</span>
</pre></div>
</div>
<p>This is a bit cumbersome, but it would solve this problem.</p>
<p>There's another problem, though, that's deeper. We're still
alternating between sending and receiving. Notice that when we send
data, we use <code class="docutils literal notranslate"><span class="pre">await</span></code>: this means that sending can potentially
<em>block</em>. Why does this happen? Any data that we send goes first into
an operating system buffer, and from there onto the network, and then
another operating system buffer on the receiving computer, before the
receiving program finally calls <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> to take the data out
of these buffers. If we call <code class="docutils literal notranslate"><span class="pre">send_all</span></code> with a small amount of data,
then it goes into these buffers and <code class="docutils literal notranslate"><span class="pre">send_all</span></code> returns immediately.
But if we send enough data fast enough, eventually the buffers fill
up, and <code class="docutils literal notranslate"><span class="pre">send_all</span></code> will block until the remote side calls
<code class="docutils literal notranslate"><span class="pre">receive_some</span></code> and frees up some space.</p>
<p>Now let's think about this from the server's point of view. Each time
it calls <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>, it gets some data that it needs to send
back. And until it sends it back, the data that is sitting around takes up
memory. Computers have finite amounts of RAM, so if our server is well
behaved then at some point it needs to stop calling <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>
until it gets rid of some of the old data by doing its own call to
<code class="docutils literal notranslate"><span class="pre">send_all</span></code>. So for the server, really the only viable option is to
alternate between receiving and sending.</p>
<p>But we need to remember that it's not just the client's call to
<code class="docutils literal notranslate"><span class="pre">send_all</span></code> that might block: the server's call to <code class="docutils literal notranslate"><span class="pre">send_all</span></code> can
also get into a situation where it blocks until the client calls
<code class="docutils literal notranslate"><span class="pre">receive_some</span></code>. So if the server is waiting for <code class="docutils literal notranslate"><span class="pre">send_all</span></code> to
finish before it calls <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>, and our client also waits for
<code class="docutils literal notranslate"><span class="pre">send_all</span></code> to finish before it calls <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>,... we have a
problem! The client won't call <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> until the server has
called <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>, and the server won't call <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>
until the client has called <code class="docutils literal notranslate"><span class="pre">receive_some</span></code>. If our client is written
to alternate between sending and receiving, and the chunk of data it's
trying to send is large enough (e.g. 10 megabytes will probably do it
in most configurations), then the two processes will <a class="reference external" href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>.</p>
<p>Moral: Trio gives you powerful tools to manage sequential and
concurrent execution. In this example we saw that the server needs
<code class="docutils literal notranslate"><span class="pre">send</span></code> and <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> to alternate in sequence, while the
client needs them to run concurrently, and both were straightforward
to implement. But when you're implementing network code like this then
it's important to think carefully about flow control and buffering,
because it's up to you to choose the right execution mode!</p>
<p>Other popular async libraries like <a class="reference external" href="https://twistedmatrix.com/">Twisted</a> and <a class="reference external" href="https://docs.python.org/zh-cn/3/library/asyncio.html#module-asyncio" title="（在 Python v3.13）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> tend to paper over
these kinds of issues by throwing in unbounded buffers everywhere.
This can avoid deadlocks, but can introduce its own problems and in
particular can make it difficult to keep <a class="reference external" href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/#three-bugs">memory usage and latency
under control</a>.
While both approaches have their advantages, Trio takes the position
that it's better to expose the underlying problem as directly as
possible and provide good tools to confront it head-on.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>If you want to try and make the deadlock happen on purpose to see
for yourself, and you're using Windows, then you might need to
split the <code class="docutils literal notranslate"><span class="pre">send_all</span></code> call up into two calls that each send half of
the data. This is because Windows has a <a class="reference external" href="https://stackoverflow.com/questions/28785626/what-is-the-size-of-a-socket-send-buffer-in-windows">somewhat unusual way of
handling buffering</a>.</p>
</div>
</div>
</div>
</section>
</section>
<section id="id11">
<h2>当出现问题时：并发任务中的超时、取消和异常<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h2>
<p><strong>When things go wrong: timeouts, cancellation and exceptions in concurrent tasks</strong></p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--13-input--1" name="tab-set--13" type="radio"/><label class="tab-label" for="tab-set--13-input--1">中文</label><div class="tab-content docutils container">
<p>TODO: 给出一个使用 <a class="reference internal" href="ref-core/cancel_timeout.html#trio.fail_after" title="trio.fail_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_after()</span></code></a> 的例子</p>
<p>TODO: 解释 <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a></p>
<p>TODO: 解释当一个子任务抛出异常时如何使用取消</p>
<p>TODO: 可能简要讨论 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 的处理方式？</p>
</div>
<input class="tab-input" id="tab-set--13-input--2" name="tab-set--13" type="radio"/><label class="tab-label" for="tab-set--13-input--2">英文</label><div class="tab-content docutils container">
<p>TODO: give an example using <a class="reference internal" href="ref-core/cancel_timeout.html#trio.fail_after" title="trio.fail_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_after()</span></code></a></p>
<p>TODO: explain <a class="reference internal" href="ref-core/exc_warn.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a></p>
<p>TODO: explain how cancellation is also used when one child raises an
exception</p>
<p>TODO: maybe a brief discussion of <a class="reference external" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" title="（在 Python v3.13）"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> handling?</p>
</div>
</div>
</section>
</section>
</article>
</div>
<footer>
<div class="related-pages">
<a class="next-page" href="awesome-trio-libraries.html">
<div class="page-info">
<div class="context">
<span>Next</span>
</div>
<div class="title">超棒的 Trio 库</div>
</div>
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
</a>
<a class="prev-page" href="index.html">
<svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
<div class="page-info">
<div class="context">
<span>Previous</span>
</div>
<div class="title">Home</div>
</div>
</a>
</div>
<div class="bottom-of-page">
<div class="left-details">
<div class="copyright">
                Copyright © 2017, Nathaniel J. Smith
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
</div>
<div class="right-details">
<div class="icons">
<a aria-label="GitHub" class="muted-link" href="https://github.com/hellowac/trio-zh-cn">
<svg fill="currentColor" stroke="currentColor" stroke-width="0" viewbox="0 0 16 16">
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill-rule="evenodd"></path>
</svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<aside class="toc-drawer">
<div class="toc-sticky toc-scroll">
<div class="toc-title-container">
<span class="toc-title">
            On this page
          </span>
</div>
<div class="toc-tree-container">
<div class="toc-tree">
<ul>
<li><a class="reference internal" href="#">教程</a><ul>
<li><a class="reference internal" href="#id2">开始之前</a></li>
<li><a class="reference internal" href="#id3">如果您迷失或感到困惑……</a></li>
<li><a class="reference internal" href="#id4">异步函数</a><ul>
<li><a class="reference internal" href="#await">警告：不要忘记 <code class="docutils literal notranslate"><span class="pre">await</span></code> ！</a></li>
<li><a class="reference internal" href="#id5">好的，让我们看一些很酷的东西</a></li>
<li><a class="reference internal" href="#tutorial-instrument-example">任务切换说明</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gil">更友好、更温和的 GIL</a></li>
<li><a class="reference internal" href="#trio">使用 Trio 进行网络编程</a><ul>
<li><a class="reference internal" href="#id7">回显客户端</a></li>
<li><a class="reference internal" href="#tutorial-echo-server-example">回显服务器</a></li>
<li><a class="reference internal" href="#id9">尝试一下</a></li>
<li><a class="reference internal" href="#id10">回显客户端和服务器中的流控制</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">当出现问题时：并发任务中的超时、取消和异常</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</aside>
</div>
</div><script src="_static/documentation_options.js?v=d2451d57"></script>
<script src="_static/doctools.js?v=9bcbadda"></script>
<script src="_static/sphinx_highlight.js?v=dc90522c"></script>
<script src="_static/scripts/furo.js?v=5fa4622c"></script>
<script src="_static/tabs.js?v=3ee01567"></script>
<script src="_static/clipboard.min.js?v=a7894cd8"></script>
<script src="_static/copybutton.js?v=f281be69"></script>
<script src="_static/translations.js?v=beaddf03"></script>
</body>
</html>